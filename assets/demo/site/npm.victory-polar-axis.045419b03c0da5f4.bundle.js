"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[4634],{22528:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": () => (/* binding */ victory_polar_axis)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__(41609);\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/axis.js\nvar victory_util_axis = __webpack_require__(92555);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/common-props.js\nvar common_props = __webpack_require__(5734);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/line-segment.js + 1 modules\nvar line_segment = __webpack_require__(85287);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-label/victory-label.js + 2 modules\nvar victory_label = __webpack_require__(41248);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/arc.js\nvar arc = __webpack_require__(56733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/add-events.js + 3 modules\nvar add_events = __webpack_require__(73247);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/lodash/uniqBy.js\nvar uniqBy = __webpack_require__(45578);\nvar uniqBy_default = /*#__PURE__*/__webpack_require__.n(uniqBy);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/scale.js\nvar victory_util_scale = __webpack_require__(74765);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/label-helpers.js\nvar label_helpers = __webpack_require__(46144);\n;// CONCATENATED MODULE: ./node_modules/victory-polar-axis/es/helper-methods.js\n\n\n\n\n\nvar getPosition = function (r, angle, axis) {\n  return axis === "x" ? r * Math.cos(angle) : -r * Math.sin(angle);\n};\n\nvar getAxisType = function (props) {\n  var typicalType = props.dependentAxis ? "radial" : "angular";\n  var invertedType = typicalType === "angular" ? "radial" : "angular";\n  return props.horizontal ? invertedType : typicalType;\n};\n\nvar filterTicks = function (ticks, scale) {\n  var compareTicks = function (t) {\n    return scale(t) % (2 * Math.PI);\n  };\n\n  return uniqBy_default()(ticks, compareTicks);\n};\n\nvar getEvaluatedStyles = function (style, props) {\n  return {\n    tickStyle: helpers/* evaluateStyle */.F3(style.ticks, props),\n    labelStyle: helpers/* evaluateStyle */.F3(style.tickLabels, props),\n    gridStyle: helpers/* evaluateStyle */.F3(style.grid, props)\n  };\n};\n\nvar getStyleObject = function (props) {\n  var _props$theme = props.theme,\n      theme = _props$theme === void 0 ? {} : _props$theme,\n      dependentAxis = props.dependentAxis;\n  var generalAxisStyle = theme.polarAxis && theme.polarAxis.style || theme.axis && theme.axis.style;\n  var polarAxisType = dependentAxis ? "polarDependentAxis" : "polarIndependentAxis";\n  var standardAxisType = dependentAxis ? "dependentAxis" : "independentAxis";\n  var specificAxisStyle = theme[polarAxisType] && theme[polarAxisType].style || theme[standardAxisType] && theme[standardAxisType].style;\n\n  var mergeStyles = function () {\n    var styleNamespaces = ["axis", "axisLabel", "grid", "parent", "tickLabels", "ticks"];\n    return styleNamespaces.reduce(function (memo, curr) {\n      memo[curr] = defaults_default()({}, specificAxisStyle[curr], generalAxisStyle[curr]);\n      return memo;\n    }, {});\n  };\n\n  return generalAxisStyle && specificAxisStyle ? mergeStyles() : specificAxisStyle || generalAxisStyle;\n};\n\nvar getRadius = function (props) {\n  var _Helpers$getPadding = helpers/* getPadding */.tQ(props),\n      left = _Helpers$getPadding.left,\n      right = _Helpers$getPadding.right,\n      top = _Helpers$getPadding.top,\n      bottom = _Helpers$getPadding.bottom;\n\n  var width = props.width,\n      height = props.height;\n  return Math.min(width - left - right, height - top - bottom) / 2;\n};\n\nvar getRange = function (props, axis) {\n  // Return the range from props if one is given.\n  if (props.range && props.range[axis]) {\n    return props.range[axis];\n  } else if (props.range && Array.isArray(props.range)) {\n    return props.range;\n  }\n\n  var axisType = getAxisType(props);\n\n  if (axisType === "angular") {\n    var startAngle = helpers/* degreesToRadians */.Ht(props.startAngle);\n    var endAngle = helpers/* degreesToRadians */.Ht(props.endAngle);\n    return [startAngle, endAngle];\n  }\n\n  var radius = getRadius(props);\n  return [props.innerRadius || 0, radius];\n}; // exposed for use by VictoryChart (necessary?)\n\n\nvar getScale = function (props) {\n  var axis = victory_util_axis/* getAxis */.dd(props);\n  var scale = victory_util_scale/* getBaseScale */.q8(props, axis);\n  var domain = victory_util_axis/* getDomain */.ge(props, axis) || scale.domain();\n  var range = getRange(props, axis);\n  scale.range(range);\n  scale.domain(domain);\n  return scale;\n};\nvar getStyles = function (props, styleObject) {\n  if (props.disableInlineStyles) {\n    return {};\n  }\n\n  var style = props.style || {};\n  styleObject = styleObject || {};\n  var parentStyleProps = {\n    height: "auto",\n    width: "100%"\n  };\n  return {\n    parent: defaults_default()(parentStyleProps, style.parent, styleObject.parent),\n    axis: defaults_default()({}, style.axis, styleObject.axis),\n    axisLabel: defaults_default()({}, style.axisLabel, styleObject.axisLabel),\n    grid: defaults_default()({}, style.grid, styleObject.grid),\n    ticks: defaults_default()({}, style.ticks, styleObject.ticks),\n    tickLabels: defaults_default()({}, style.tickLabels, styleObject.tickLabels)\n  };\n};\n\nvar getAxisAngle = function (props) {\n  var axisAngle = props.axisAngle,\n      startAngle = props.startAngle,\n      dependentAxis = props.dependentAxis;\n  var axis = victory_util_axis/* getAxis */.dd(props);\n  var axisValue = victory_util_axis/* getAxisValue */.w5(props, axis);\n\n  if (axisValue === undefined || !dependentAxis) {\n    return axisAngle === undefined ? startAngle : axisAngle;\n  }\n\n  return helpers/* radiansToDegrees */.vi(axisValue);\n}; // eslint-disable-next-line max-params\n\n\nvar getTickProps = function (props, calculatedValues, tickValue, index) {\n  var axisType = calculatedValues.axisType,\n      radius = calculatedValues.radius,\n      scale = calculatedValues.scale,\n      style = calculatedValues.style,\n      stringTicks = calculatedValues.stringTicks,\n      ticks = calculatedValues.ticks,\n      tickFormat = calculatedValues.tickFormat,\n      origin = calculatedValues.origin;\n  var text = tickFormat(tickValue, index, ticks);\n  var tick = stringTicks ? stringTicks[index] : tickValue;\n\n  var _getEvaluatedStyles = getEvaluatedStyles(style, {\n    tick: tick,\n    tickValue: tickValue,\n    index: index,\n    ticks: ticks,\n    stringTicks: stringTicks,\n    radius: radius,\n    scale: scale,\n    axisType: axisType,\n    text: text\n  }),\n      tickStyle = _getEvaluatedStyles.tickStyle;\n\n  var axisAngle = axisType === "radial" ? getAxisAngle(props, scale) : undefined;\n  var tickPadding = tickStyle.padding || tickStyle.size || 0;\n  var padAngle = helpers/* degreesToRadians */.Ht(90 - axisAngle);\n  var tickAngle = axisType === "angular" ? scale(tickValue) : helpers/* degreesToRadians */.Ht(-1 * axisAngle);\n  var tickRadius = axisType === "angular" ? radius : scale(tickValue);\n  return axisType === "angular" ? {\n    index: index,\n    datum: tick,\n    style: tickStyle,\n    x1: getPosition(tickRadius, tickAngle, "x") + origin.x,\n    y1: getPosition(tickRadius, tickAngle, "y") + origin.y,\n    x2: getPosition(tickRadius + tickPadding, tickAngle, "x") + origin.x,\n    y2: getPosition(tickRadius + tickPadding, tickAngle, "y") + origin.y\n  } : {\n    index: index,\n    datum: tick,\n    style: tickStyle,\n    x1: tickRadius * Math.cos(tickAngle) + Math.cos(padAngle) * tickPadding + origin.x,\n    x2: tickRadius * Math.cos(tickAngle) - Math.cos(padAngle) * tickPadding + origin.x,\n    y1: tickRadius * Math.sin(tickAngle) + Math.sin(padAngle) * tickPadding + origin.y,\n    y2: tickRadius * Math.sin(tickAngle) - Math.sin(padAngle) * tickPadding + origin.y\n  };\n}; // eslint-disable-next-line max-params\n\n\nvar getTickLabelProps = function (props, calculatedValues, tickValue, index) {\n  var axisType = calculatedValues.axisType,\n      radius = calculatedValues.radius,\n      tickFormat = calculatedValues.tickFormat,\n      style = calculatedValues.style,\n      scale = calculatedValues.scale,\n      ticks = calculatedValues.ticks,\n      stringTicks = calculatedValues.stringTicks,\n      origin = calculatedValues.origin;\n  var text = tickFormat(tickValue, index, ticks);\n  var tick = stringTicks ? stringTicks[index] : tickValue;\n\n  var _getEvaluatedStyles2 = getEvaluatedStyles(style, {\n    text: text,\n    tick: tick,\n    tickValue: tickValue,\n    index: index,\n    ticks: ticks,\n    stringTicks: stringTicks,\n    radius: radius,\n    scale: scale,\n    axisType: axisType\n  }),\n      labelStyle = _getEvaluatedStyles2.labelStyle;\n\n  var tickLabelComponent = props.tickLabelComponent;\n  var labelPlacement = tickLabelComponent.props && tickLabelComponent.props.labelPlacement ? tickLabelComponent.props.labelPlacement : props.labelPlacement;\n  var tickPadding = labelStyle.padding || 0;\n  var angularPadding = 0; // TODO: do some geometry\n\n  var axisAngle = axisType === "radial" ? getAxisAngle(props, scale) : undefined;\n  var labelAngle = axisType === "angular" ? helpers/* radiansToDegrees */.vi(scale(tickValue)) : axisAngle + angularPadding;\n  var textAngle = labelStyle.angle === undefined ? label_helpers/* getPolarAngle */.Sw(assign_default()({}, props, {\n    labelPlacement: labelPlacement\n  }), labelAngle) : labelStyle.angle;\n  var labelRadius = axisType === "angular" ? radius + tickPadding : scale(tickValue);\n  var textAnchor = labelStyle.textAnchor || label_helpers/* getPolarTextAnchor */.Nf(assign_default()({}, props, {\n    labelPlacement: labelPlacement\n  }), labelAngle);\n  return {\n    index: index,\n    datum: tick,\n    style: labelStyle,\n    angle: textAngle,\n    textAnchor: textAnchor,\n    text: text,\n    x: labelRadius * Math.cos(helpers/* degreesToRadians */.Ht(labelAngle)) + origin.x,\n    y: -labelRadius * Math.sin(helpers/* degreesToRadians */.Ht(labelAngle)) + origin.y\n  };\n}; // eslint-disable-next-line max-params\n\n\nvar getGridProps = function (props, calculatedValues, tickValue, index) {\n  var axisType = calculatedValues.axisType,\n      radius = calculatedValues.radius,\n      style = calculatedValues.style,\n      scale = calculatedValues.scale,\n      stringTicks = calculatedValues.stringTicks,\n      ticks = calculatedValues.ticks,\n      tickFormat = calculatedValues.tickFormat,\n      origin = calculatedValues.origin;\n  var text = tickFormat(tickValue, index, ticks);\n  var startAngle = props.startAngle,\n      endAngle = props.endAngle,\n      _props$innerRadius = props.innerRadius,\n      innerRadius = _props$innerRadius === void 0 ? 0 : _props$innerRadius;\n  var tick = stringTicks ? stringTicks[index] : tickValue;\n\n  var _getEvaluatedStyles3 = getEvaluatedStyles(style, {\n    tick: tick,\n    tickValue: tickValue,\n    index: index,\n    ticks: ticks,\n    stringTicks: stringTicks,\n    radius: radius,\n    scale: scale,\n    axisType: axisType,\n    text: text\n  }),\n      gridStyle = _getEvaluatedStyles3.gridStyle;\n\n  var angle = scale(tickValue);\n  return axisType === "angular" ? {\n    index: index,\n    datum: tick,\n    style: gridStyle,\n    x1: getPosition(radius, angle, "x") + origin.x,\n    y1: getPosition(radius, angle, "y") + origin.y,\n    x2: getPosition(innerRadius, angle, "x") + origin.x,\n    y2: getPosition(innerRadius, angle, "y") + origin.y\n  } : {\n    style: gridStyle,\n    index: index,\n    datum: tick,\n    cx: origin.x,\n    cy: origin.y,\n    r: scale(tickValue),\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n};\n\nvar getAxisLabelProps = function (props, calculatedValues) {\n  var axisType = calculatedValues.axisType,\n      radius = calculatedValues.radius,\n      style = calculatedValues.style,\n      scale = calculatedValues.scale,\n      origin = calculatedValues.origin;\n  var axisLabelComponent = props.axisLabelComponent;\n\n  if (axisType !== "radial") {\n    return {};\n  }\n\n  var labelPlacement = axisLabelComponent.props && axisLabelComponent.props.labelPlacement ? axisLabelComponent.props.labelPlacement : props.labelPlacement;\n  var labelStyle = style && style.axisLabel || {};\n  var axisAngle = axisType === "radial" ? getAxisAngle(props, scale) : undefined;\n  var textAngle = labelStyle.angle === undefined ? label_helpers/* getPolarAngle */.Sw(assign_default()({}, props, {\n    labelPlacement: labelPlacement\n  }), axisAngle) : labelStyle.angle;\n  var labelRadius = radius + (labelStyle.padding || 0);\n  var textAnchor = labelStyle.textAnchor || label_helpers/* getPolarTextAnchor */.Nf(assign_default()({}, props, {\n    labelPlacement: labelPlacement\n  }), axisAngle);\n  var verticalAnchor = labelStyle.verticalAnchor || label_helpers/* getPolarVerticalAnchor */.nV(assign_default()({}, props, {\n    labelPlacement: labelPlacement\n  }), axisAngle);\n  return {\n    style: labelStyle,\n    angle: textAngle,\n    textAnchor: textAnchor,\n    verticalAnchor: verticalAnchor,\n    text: props.label,\n    x: getPosition(labelRadius, helpers/* degreesToRadians */.Ht(axisAngle), "x") + origin.x,\n    y: getPosition(labelRadius, helpers/* degreesToRadians */.Ht(axisAngle), "y") + origin.y\n  };\n};\n\nvar getAxisProps = function (modifiedProps, calculatedValues) {\n  var style = calculatedValues.style,\n      axisType = calculatedValues.axisType,\n      radius = calculatedValues.radius,\n      scale = calculatedValues.scale,\n      origin = calculatedValues.origin;\n  var startAngle = modifiedProps.startAngle,\n      endAngle = modifiedProps.endAngle,\n      _modifiedProps$innerR = modifiedProps.innerRadius,\n      innerRadius = _modifiedProps$innerR === void 0 ? 0 : _modifiedProps$innerR;\n  var axisAngle = axisType === "radial" ? helpers/* degreesToRadians */.Ht(getAxisAngle(modifiedProps, scale)) : undefined;\n  return axisType === "radial" ? {\n    style: style.axis,\n    x1: getPosition(innerRadius, axisAngle, "x") + origin.x,\n    x2: getPosition(radius, axisAngle, "x") + origin.x,\n    y1: getPosition(innerRadius, axisAngle, "y") + origin.y,\n    y2: getPosition(radius, axisAngle, "y") + origin.y\n  } : {\n    style: style.axis,\n    cx: origin.x,\n    cy: origin.y,\n    r: radius,\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n};\n\nvar getCalculatedValues = function (props) {\n  props = assign_default()({\n    polar: true\n  }, props);\n  var defaultStyles = getStyleObject(props);\n  var style = getStyles(props, defaultStyles);\n  var padding = helpers/* getPadding */.tQ(props);\n  var axis = victory_util_axis/* getAxis */.dd(props);\n  var axisType = getAxisType(props);\n  var stringTicks = victory_util_axis/* stringTicks */.kM(props) ? props.tickValues : undefined;\n  var domain = victory_util_axis/* getDomain */.ge(props, axis);\n  var range = getRange(props, axis);\n  var scale = getScale(props);\n  var initialTicks = victory_util_axis/* getTicks */.fj(props, scale);\n  var ticks = axisType === "angular" ? filterTicks(initialTicks, scale) : initialTicks;\n  var tickFormat = victory_util_axis/* getTickFormat */.Js(props, scale);\n  var radius = getRadius(props);\n  var origin = helpers/* getPolarOrigin */.IW(props);\n  return {\n    axis: axis,\n    style: style,\n    padding: padding,\n    stringTicks: stringTicks,\n    axisType: axisType,\n    scale: scale,\n    ticks: ticks,\n    tickFormat: tickFormat,\n    domain: domain,\n    range: range,\n    radius: radius,\n    origin: origin\n  };\n};\n\nvar getBaseProps = function (props, fallbackProps) {\n  props = victory_util_axis/* modifyProps */.TY(props, fallbackProps);\n  var calculatedValues = getCalculatedValues(props);\n  var style = calculatedValues.style,\n      scale = calculatedValues.scale,\n      ticks = calculatedValues.ticks,\n      domain = calculatedValues.domain;\n  var _props = props,\n      width = _props.width,\n      height = _props.height,\n      standalone = _props.standalone,\n      theme = _props.theme,\n      name = _props.name;\n  var axisProps = getAxisProps(props, calculatedValues);\n  var axisLabelProps = getAxisLabelProps(props, calculatedValues);\n  var initialChildProps = {\n    parent: {\n      style: style.parent,\n      ticks: ticks,\n      scale: scale,\n      width: width,\n      height: height,\n      domain: domain,\n      standalone: standalone,\n      theme: theme,\n      name: name\n    }\n  };\n  return ticks.reduce(function (childProps, tick, index) {\n    childProps[index] = {\n      axis: axisProps,\n      axisLabel: axisLabelProps,\n      ticks: getTickProps(props, calculatedValues, tick, index),\n      tickLabels: getTickLabelProps(props, calculatedValues, tick, index),\n      grid: getGridProps(props, calculatedValues, tick, index)\n    };\n    return childProps;\n  }, initialChildProps);\n};\n;// CONCATENATED MODULE: ./node_modules/victory-polar-axis/es/victory-polar-axis.js\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\nvar options = {\n  components: [{\n    name: "axis",\n    index: 0\n  }, {\n    name: "axisLabel",\n    index: 0\n  }, {\n    name: "grid"\n  }, {\n    name: "parent",\n    index: "parent"\n  }, {\n    name: "ticks"\n  }, {\n    name: "tickLabels"\n  }]\n};\n\nvar VictoryPolarAxis = /*#__PURE__*/function (_React$Component) {\n  _inherits(VictoryPolarAxis, _React$Component);\n\n  var _super = _createSuper(VictoryPolarAxis);\n\n  function VictoryPolarAxis() {\n    _classCallCheck(this, VictoryPolarAxis);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VictoryPolarAxis, [{\n    key: "renderAxisLine",\n    value: function renderAxisLine(props) {\n      var dependentAxis = props.dependentAxis;\n      var axisComponent = dependentAxis ? props.axisComponent : props.circularAxisComponent;\n      var axisProps = this.getComponentProps(axisComponent, "axis", 0);\n      return /*#__PURE__*/react.cloneElement(axisComponent, axisProps);\n    }\n  }, {\n    key: "renderLabel",\n    value: function renderLabel(props) {\n      var axisLabelComponent = props.axisLabelComponent,\n          dependentAxis = props.dependentAxis,\n          label = props.label;\n\n      if (!label || !dependentAxis) {\n        return null;\n      }\n\n      var axisLabelProps = this.getComponentProps(axisLabelComponent, "axisLabel", 0);\n      return /*#__PURE__*/react.cloneElement(axisLabelComponent, axisLabelProps);\n    }\n  }, {\n    key: "renderAxis",\n    value: function renderAxis(props) {\n      var _this = this;\n\n      var tickComponent = props.tickComponent,\n          tickLabelComponent = props.tickLabelComponent,\n          name = props.name;\n\n      var shouldRender = function (componentProps) {\n        var _componentProps$style = componentProps.style,\n            style = _componentProps$style === void 0 ? {} : _componentProps$style,\n            _componentProps$event = componentProps.events,\n            events = _componentProps$event === void 0 ? {} : _componentProps$event;\n        var visible = style.stroke !== "transparent" && style.stroke !== "none" && style.strokeWidth !== 0;\n        return visible || !isEmpty_default()(events);\n      };\n\n      var axisType = props.dependentAxis ? "radial" : "angular";\n      var gridComponent = axisType === "radial" ? props.circularGridComponent : props.gridComponent;\n      var tickComponents = this.dataKeys.map(function (key, index) {\n        var tickProps = assign_default()({\n          key: "".concat(name, "-tick-").concat(key)\n        }, _this.getComponentProps(tickComponent, "ticks", index));\n\n        var TickComponent = /*#__PURE__*/react.cloneElement(tickComponent, tickProps);\n        return shouldRender(TickComponent.props) ? TickComponent : undefined;\n      }).filter(Boolean);\n      var gridComponents = this.dataKeys.map(function (key, index) {\n        var gridProps = assign_default()({\n          key: "".concat(name, "-grid-").concat(key)\n        }, _this.getComponentProps(gridComponent, "grid", index));\n\n        var GridComponent = /*#__PURE__*/react.cloneElement(gridComponent, gridProps);\n        return shouldRender(GridComponent.props) ? GridComponent : undefined;\n      }).filter(Boolean);\n      var tickLabelComponents = this.dataKeys.map(function (key, index) {\n        var tickLabelProps = assign_default()({\n          key: "".concat(name, "-tick-").concat(key)\n        }, _this.getComponentProps(tickLabelComponent, "tickLabels", index));\n\n        return /*#__PURE__*/react.cloneElement(tickLabelComponent, tickLabelProps);\n      });\n      var axis = this.renderAxisLine(props);\n      var axisLabel = this.renderLabel(props);\n      var children = [axis, axisLabel].concat(_toConsumableArray(tickComponents), _toConsumableArray(gridComponents), _toConsumableArray(tickLabelComponents));\n      return this.renderGroup(props, children);\n    } // Overridden in victory-native\n\n  }, {\n    key: "renderGroup",\n    value: function renderGroup(props, children) {\n      var groupComponent = props.groupComponent;\n      return /*#__PURE__*/react.cloneElement(groupComponent, {}, children);\n    }\n  }, {\n    key: "shouldAnimate",\n    value: function shouldAnimate() {\n      return !!this.props.animate;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var animationWhitelist = VictoryPolarAxis.animationWhitelist;\n      var props = victory_util_axis/* modifyProps */.TY(this.props, fallbackProps);\n\n      if (this.shouldAnimate()) {\n        return this.animateComponent(props, animationWhitelist);\n      }\n\n      var children = this.renderAxis(props);\n      return props.standalone ? this.renderContainer(props.containerComponent, children) : children;\n    }\n  }]);\n\n  return VictoryPolarAxis;\n}(react.Component);\n\nVictoryPolarAxis.animationWhitelist = ["style", "domain", "range", "tickCount", "tickValues", "padding", "width", "height"];\nVictoryPolarAxis.displayName = "VictoryAxis";\nVictoryPolarAxis.role = "axis";\nVictoryPolarAxis.defaultTransitions = {\n  onExit: {\n    duration: 500\n  },\n  onEnter: {\n    duration: 500\n  }\n};\nVictoryPolarAxis.propTypes = _objectSpread(_objectSpread({}, common_props/* CommonProps.baseProps */.l.baseProps), {}, {\n  axisAngle: (prop_types_default()).number,\n  axisComponent: (prop_types_default()).element,\n  axisLabelComponent: (prop_types_default()).element,\n  axisValue: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string, (prop_types_default()).object]),\n  categories: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).string), prop_types_default().shape({\n    x: prop_types_default().arrayOf((prop_types_default()).string),\n    y: prop_types_default().arrayOf((prop_types_default()).string)\n  })]),\n  circularAxisComponent: (prop_types_default()).element,\n  circularGridComponent: (prop_types_default()).element,\n  containerComponent: (prop_types_default()).element,\n  dependentAxis: (prop_types_default()).bool,\n  disableInlineStyles: (prop_types_default()).bool,\n  endAngle: (prop_types_default()).number,\n  events: prop_types_default().arrayOf(prop_types_default().shape({\n    target: prop_types_default().oneOf(["axis", "axisLabel", "grid", "ticks", "tickLabels"]),\n    eventKey: prop_types_default().oneOfType([(prop_types_default()).array, victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* nonNegative */.A7]), (prop_types_default()).string]),\n    eventHandlers: (prop_types_default()).object\n  })),\n  gridComponent: (prop_types_default()).element,\n  innerRadius: victory_util_prop_types/* nonNegative */.A7,\n  labelPlacement: prop_types_default().oneOf(["parallel", "perpendicular", "vertical"]),\n  startAngle: (prop_types_default()).number,\n  stringMap: (prop_types_default()).object,\n  style: prop_types_default().shape({\n    parent: (prop_types_default()).object,\n    axis: (prop_types_default()).object,\n    axisLabel: (prop_types_default()).object,\n    grid: (prop_types_default()).object,\n    ticks: (prop_types_default()).object,\n    tickLabels: (prop_types_default()).object\n  }),\n  tickComponent: (prop_types_default()).element,\n  tickCount: victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* greaterThanZero */.KO]),\n  tickFormat: prop_types_default().oneOfType([(prop_types_default()).func, victory_util_prop_types/* homogeneousArray */.xx]),\n  tickLabelComponent: (prop_types_default()).element,\n  tickValues: victory_util_prop_types/* homogeneousArray */.xx\n});\nVictoryPolarAxis.defaultProps = {\n  axisComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  axisLabelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null),\n  circularAxisComponent: /*#__PURE__*/react.createElement(arc/* Arc */.w, null),\n  circularGridComponent: /*#__PURE__*/react.createElement(arc/* Arc */.w, null),\n  containerComponent: /*#__PURE__*/react.createElement(victory_container/* VictoryContainer */._, null),\n  endAngle: 360,\n  gridComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  groupComponent: /*#__PURE__*/react.createElement("g", {\n    role: "presentation"\n  }),\n  labelPlacement: "parallel",\n  startAngle: 0,\n  standalone: true,\n  theme: victory_theme/* VictoryTheme.grayscale */.J.grayscale,\n  tickComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  tickLabelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null)\n};\nVictoryPolarAxis.getDomain = victory_util_axis/* getDomain */.ge;\nVictoryPolarAxis.getAxis = victory_util_axis/* getAxis */.dd;\nVictoryPolarAxis.getScale = getScale;\n\nVictoryPolarAxis.getStyles = function (props) {\n  return getStyles(props, fallbackProps.style);\n};\n\nVictoryPolarAxis.getBaseProps = function (props) {\n  return getBaseProps(props, fallbackProps);\n};\n\nVictoryPolarAxis.expectedComponents = ["axisComponent", "circularAxisComponent", "groupComponent", "containerComponent", "tickComponent", "tickLabelComponent", "gridComponent", "circularGridComponent"];\n/* harmony default export */ const victory_polar_axis = ((0,add_events/* addEvents */.o)(VictoryPolarAxis, options));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNsQyxhQUFhLHlDQUF5QixFQUFFLHVDQUF1QixFQUFFLCtDQUErQjtBQUNoRyxjQUFjLDhCQUFtQixFQUFFLDJCQUFjLEVBQUUsZ0RBQWdDO0FBQ25GLHNCQUFzQiw4QkFBaUI7QUFDdkMsY0FBYyxnREFBZ0M7QUFDOUMsQ0FBQztBQUNEO0FBQ0EsOEJBQThCLG1CQUFtQixDQUFDLCtCQUFXO0FBQzdELG1DQUFtQyxtQkFBbUIsQ0FBQyxpQ0FBWTtBQUNuRSxzQ0FBc0MsbUJBQW1CLENBQUMsY0FBRztBQUM3RCxzQ0FBc0MsbUJBQW1CLENBQUMsY0FBRztBQUM3RCxtQ0FBbUMsbUJBQW1CLENBQUMseUNBQWdCO0FBQ3ZFO0FBQ0EsOEJBQThCLG1CQUFtQixDQUFDLCtCQUFXO0FBQzdELCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBc0I7QUFDL0IsOEJBQThCLG1CQUFtQixDQUFDLCtCQUFXO0FBQzdELG1DQUFtQyxtQkFBbUIsQ0FBQyxpQ0FBWTtBQUNuRTtBQUNBLDZCQUE2QixtQ0FBYztBQUMzQywyQkFBMkIsaUNBQVk7QUFDdkMsNEJBQTRCLFFBQVE7O0FBRXBDO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCOztBQUVBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCOztBQUVBO0FBQ0EseURBQWUsK0JBQVMsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3J5b3N0YXQtd2ViLy4vbm9kZV9tb2R1bGVzL3ZpY3RvcnktcG9sYXItYXhpcy9lcy9oZWxwZXItbWV0aG9kcy5qcz9iOThlIiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LXBvbGFyLWF4aXMvZXMvdmljdG9yeS1wb2xhci1heGlzLmpzPzY3ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZhdWx0cyBmcm9tIFwibG9kYXNoL2RlZmF1bHRzXCI7XG5pbXBvcnQgX3VuaXFCeSBmcm9tIFwibG9kYXNoL3VuaXFCeVwiO1xuaW1wb3J0IF9hc3NpZ24gZnJvbSBcImxvZGFzaC9hc3NpZ25cIjtcbmltcG9ydCB7IEhlbHBlcnMsIExhYmVsSGVscGVycywgU2NhbGUsIEF4aXMgfSBmcm9tIFwidmljdG9yeS1jb3JlXCI7XG5cbnZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChyLCBhbmdsZSwgYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gXCJ4XCIgPyByICogTWF0aC5jb3MoYW5nbGUpIDogLXIgKiBNYXRoLnNpbihhbmdsZSk7XG59O1xuXG52YXIgZ2V0QXhpc1R5cGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIHR5cGljYWxUeXBlID0gcHJvcHMuZGVwZW5kZW50QXhpcyA/IFwicmFkaWFsXCIgOiBcImFuZ3VsYXJcIjtcbiAgdmFyIGludmVydGVkVHlwZSA9IHR5cGljYWxUeXBlID09PSBcImFuZ3VsYXJcIiA/IFwicmFkaWFsXCIgOiBcImFuZ3VsYXJcIjtcbiAgcmV0dXJuIHByb3BzLmhvcml6b250YWwgPyBpbnZlcnRlZFR5cGUgOiB0eXBpY2FsVHlwZTtcbn07XG5cbnZhciBmaWx0ZXJUaWNrcyA9IGZ1bmN0aW9uICh0aWNrcywgc2NhbGUpIHtcbiAgdmFyIGNvbXBhcmVUaWNrcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHNjYWxlKHQpICUgKDIgKiBNYXRoLlBJKTtcbiAgfTtcblxuICByZXR1cm4gX3VuaXFCeSh0aWNrcywgY29tcGFyZVRpY2tzKTtcbn07XG5cbnZhciBnZXRFdmFsdWF0ZWRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGUsIHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgdGlja1N0eWxlOiBIZWxwZXJzLmV2YWx1YXRlU3R5bGUoc3R5bGUudGlja3MsIHByb3BzKSxcbiAgICBsYWJlbFN0eWxlOiBIZWxwZXJzLmV2YWx1YXRlU3R5bGUoc3R5bGUudGlja0xhYmVscywgcHJvcHMpLFxuICAgIGdyaWRTdHlsZTogSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLmdyaWQsIHByb3BzKVxuICB9O1xufTtcblxudmFyIGdldFN0eWxlT2JqZWN0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkdGhlbWUgPSBwcm9wcy50aGVtZSxcbiAgICAgIHRoZW1lID0gX3Byb3BzJHRoZW1lID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyR0aGVtZSxcbiAgICAgIGRlcGVuZGVudEF4aXMgPSBwcm9wcy5kZXBlbmRlbnRBeGlzO1xuICB2YXIgZ2VuZXJhbEF4aXNTdHlsZSA9IHRoZW1lLnBvbGFyQXhpcyAmJiB0aGVtZS5wb2xhckF4aXMuc3R5bGUgfHwgdGhlbWUuYXhpcyAmJiB0aGVtZS5heGlzLnN0eWxlO1xuICB2YXIgcG9sYXJBeGlzVHlwZSA9IGRlcGVuZGVudEF4aXMgPyBcInBvbGFyRGVwZW5kZW50QXhpc1wiIDogXCJwb2xhckluZGVwZW5kZW50QXhpc1wiO1xuICB2YXIgc3RhbmRhcmRBeGlzVHlwZSA9IGRlcGVuZGVudEF4aXMgPyBcImRlcGVuZGVudEF4aXNcIiA6IFwiaW5kZXBlbmRlbnRBeGlzXCI7XG4gIHZhciBzcGVjaWZpY0F4aXNTdHlsZSA9IHRoZW1lW3BvbGFyQXhpc1R5cGVdICYmIHRoZW1lW3BvbGFyQXhpc1R5cGVdLnN0eWxlIHx8IHRoZW1lW3N0YW5kYXJkQXhpc1R5cGVdICYmIHRoZW1lW3N0YW5kYXJkQXhpc1R5cGVdLnN0eWxlO1xuXG4gIHZhciBtZXJnZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGVOYW1lc3BhY2VzID0gW1wiYXhpc1wiLCBcImF4aXNMYWJlbFwiLCBcImdyaWRcIiwgXCJwYXJlbnRcIiwgXCJ0aWNrTGFiZWxzXCIsIFwidGlja3NcIl07XG4gICAgcmV0dXJuIHN0eWxlTmFtZXNwYWNlcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnIpIHtcbiAgICAgIG1lbW9bY3Vycl0gPSBfZGVmYXVsdHMoe30sIHNwZWNpZmljQXhpc1N0eWxlW2N1cnJdLCBnZW5lcmFsQXhpc1N0eWxlW2N1cnJdKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICByZXR1cm4gZ2VuZXJhbEF4aXNTdHlsZSAmJiBzcGVjaWZpY0F4aXNTdHlsZSA/IG1lcmdlU3R5bGVzKCkgOiBzcGVjaWZpY0F4aXNTdHlsZSB8fCBnZW5lcmFsQXhpc1N0eWxlO1xufTtcblxudmFyIGdldFJhZGl1cyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgX0hlbHBlcnMkZ2V0UGFkZGluZyA9IEhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyksXG4gICAgICBsZWZ0ID0gX0hlbHBlcnMkZ2V0UGFkZGluZy5sZWZ0LFxuICAgICAgcmlnaHQgPSBfSGVscGVycyRnZXRQYWRkaW5nLnJpZ2h0LFxuICAgICAgdG9wID0gX0hlbHBlcnMkZ2V0UGFkZGluZy50b3AsXG4gICAgICBib3R0b20gPSBfSGVscGVycyRnZXRQYWRkaW5nLmJvdHRvbTtcblxuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodDtcbiAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC0gbGVmdCAtIHJpZ2h0LCBoZWlnaHQgLSB0b3AgLSBib3R0b20pIC8gMjtcbn07XG5cbnZhciBnZXRSYW5nZSA9IGZ1bmN0aW9uIChwcm9wcywgYXhpcykge1xuICAvLyBSZXR1cm4gdGhlIHJhbmdlIGZyb20gcHJvcHMgaWYgb25lIGlzIGdpdmVuLlxuICBpZiAocHJvcHMucmFuZ2UgJiYgcHJvcHMucmFuZ2VbYXhpc10pIHtcbiAgICByZXR1cm4gcHJvcHMucmFuZ2VbYXhpc107XG4gIH0gZWxzZSBpZiAocHJvcHMucmFuZ2UgJiYgQXJyYXkuaXNBcnJheShwcm9wcy5yYW5nZSkpIHtcbiAgICByZXR1cm4gcHJvcHMucmFuZ2U7XG4gIH1cblxuICB2YXIgYXhpc1R5cGUgPSBnZXRBeGlzVHlwZShwcm9wcyk7XG5cbiAgaWYgKGF4aXNUeXBlID09PSBcImFuZ3VsYXJcIikge1xuICAgIHZhciBzdGFydEFuZ2xlID0gSGVscGVycy5kZWdyZWVzVG9SYWRpYW5zKHByb3BzLnN0YXJ0QW5nbGUpO1xuICAgIHZhciBlbmRBbmdsZSA9IEhlbHBlcnMuZGVncmVlc1RvUmFkaWFucyhwcm9wcy5lbmRBbmdsZSk7XG4gICAgcmV0dXJuIFtzdGFydEFuZ2xlLCBlbmRBbmdsZV07XG4gIH1cblxuICB2YXIgcmFkaXVzID0gZ2V0UmFkaXVzKHByb3BzKTtcbiAgcmV0dXJuIFtwcm9wcy5pbm5lclJhZGl1cyB8fCAwLCByYWRpdXNdO1xufTsgLy8gZXhwb3NlZCBmb3IgdXNlIGJ5IFZpY3RvcnlDaGFydCAobmVjZXNzYXJ5PylcblxuXG5leHBvcnQgdmFyIGdldFNjYWxlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciBheGlzID0gQXhpcy5nZXRBeGlzKHByb3BzKTtcbiAgdmFyIHNjYWxlID0gU2NhbGUuZ2V0QmFzZVNjYWxlKHByb3BzLCBheGlzKTtcbiAgdmFyIGRvbWFpbiA9IEF4aXMuZ2V0RG9tYWluKHByb3BzLCBheGlzKSB8fCBzY2FsZS5kb21haW4oKTtcbiAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UocHJvcHMsIGF4aXMpO1xuICBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICByZXR1cm4gc2NhbGU7XG59O1xuZXhwb3J0IHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAocHJvcHMsIHN0eWxlT2JqZWN0KSB7XG4gIGlmIChwcm9wcy5kaXNhYmxlSW5saW5lU3R5bGVzKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIHN0eWxlT2JqZWN0ID0gc3R5bGVPYmplY3QgfHwge307XG4gIHZhciBwYXJlbnRTdHlsZVByb3BzID0ge1xuICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgcGFyZW50OiBfZGVmYXVsdHMocGFyZW50U3R5bGVQcm9wcywgc3R5bGUucGFyZW50LCBzdHlsZU9iamVjdC5wYXJlbnQpLFxuICAgIGF4aXM6IF9kZWZhdWx0cyh7fSwgc3R5bGUuYXhpcywgc3R5bGVPYmplY3QuYXhpcyksXG4gICAgYXhpc0xhYmVsOiBfZGVmYXVsdHMoe30sIHN0eWxlLmF4aXNMYWJlbCwgc3R5bGVPYmplY3QuYXhpc0xhYmVsKSxcbiAgICBncmlkOiBfZGVmYXVsdHMoe30sIHN0eWxlLmdyaWQsIHN0eWxlT2JqZWN0LmdyaWQpLFxuICAgIHRpY2tzOiBfZGVmYXVsdHMoe30sIHN0eWxlLnRpY2tzLCBzdHlsZU9iamVjdC50aWNrcyksXG4gICAgdGlja0xhYmVsczogX2RlZmF1bHRzKHt9LCBzdHlsZS50aWNrTGFiZWxzLCBzdHlsZU9iamVjdC50aWNrTGFiZWxzKVxuICB9O1xufTtcblxudmFyIGdldEF4aXNBbmdsZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgYXhpc0FuZ2xlID0gcHJvcHMuYXhpc0FuZ2xlLFxuICAgICAgc3RhcnRBbmdsZSA9IHByb3BzLnN0YXJ0QW5nbGUsXG4gICAgICBkZXBlbmRlbnRBeGlzID0gcHJvcHMuZGVwZW5kZW50QXhpcztcbiAgdmFyIGF4aXMgPSBBeGlzLmdldEF4aXMocHJvcHMpO1xuICB2YXIgYXhpc1ZhbHVlID0gQXhpcy5nZXRBeGlzVmFsdWUocHJvcHMsIGF4aXMpO1xuXG4gIGlmIChheGlzVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhZGVwZW5kZW50QXhpcykge1xuICAgIHJldHVybiBheGlzQW5nbGUgPT09IHVuZGVmaW5lZCA/IHN0YXJ0QW5nbGUgOiBheGlzQW5nbGU7XG4gIH1cblxuICByZXR1cm4gSGVscGVycy5yYWRpYW5zVG9EZWdyZWVzKGF4aXNWYWx1ZSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG5cbnZhciBnZXRUaWNrUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIHRpY2tWYWx1ZSwgaW5kZXgpIHtcbiAgdmFyIGF4aXNUeXBlID0gY2FsY3VsYXRlZFZhbHVlcy5heGlzVHlwZSxcbiAgICAgIHJhZGl1cyA9IGNhbGN1bGF0ZWRWYWx1ZXMucmFkaXVzLFxuICAgICAgc2NhbGUgPSBjYWxjdWxhdGVkVmFsdWVzLnNjYWxlLFxuICAgICAgc3R5bGUgPSBjYWxjdWxhdGVkVmFsdWVzLnN0eWxlLFxuICAgICAgc3RyaW5nVGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnN0cmluZ1RpY2tzLFxuICAgICAgdGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IGNhbGN1bGF0ZWRWYWx1ZXMudGlja0Zvcm1hdCxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZ2luO1xuICB2YXIgdGV4dCA9IHRpY2tGb3JtYXQodGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICB2YXIgdGljayA9IHN0cmluZ1RpY2tzID8gc3RyaW5nVGlja3NbaW5kZXhdIDogdGlja1ZhbHVlO1xuXG4gIHZhciBfZ2V0RXZhbHVhdGVkU3R5bGVzID0gZ2V0RXZhbHVhdGVkU3R5bGVzKHN0eWxlLCB7XG4gICAgdGljazogdGljayxcbiAgICB0aWNrVmFsdWU6IHRpY2tWYWx1ZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgdGlja3M6IHRpY2tzLFxuICAgIHN0cmluZ1RpY2tzOiBzdHJpbmdUaWNrcyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgYXhpc1R5cGU6IGF4aXNUeXBlLFxuICAgIHRleHQ6IHRleHRcbiAgfSksXG4gICAgICB0aWNrU3R5bGUgPSBfZ2V0RXZhbHVhdGVkU3R5bGVzLnRpY2tTdHlsZTtcblxuICB2YXIgYXhpc0FuZ2xlID0gYXhpc1R5cGUgPT09IFwicmFkaWFsXCIgPyBnZXRBeGlzQW5nbGUocHJvcHMsIHNjYWxlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRpY2tQYWRkaW5nID0gdGlja1N0eWxlLnBhZGRpbmcgfHwgdGlja1N0eWxlLnNpemUgfHwgMDtcbiAgdmFyIHBhZEFuZ2xlID0gSGVscGVycy5kZWdyZWVzVG9SYWRpYW5zKDkwIC0gYXhpc0FuZ2xlKTtcbiAgdmFyIHRpY2tBbmdsZSA9IGF4aXNUeXBlID09PSBcImFuZ3VsYXJcIiA/IHNjYWxlKHRpY2tWYWx1ZSkgOiBIZWxwZXJzLmRlZ3JlZXNUb1JhZGlhbnMoLTEgKiBheGlzQW5nbGUpO1xuICB2YXIgdGlja1JhZGl1cyA9IGF4aXNUeXBlID09PSBcImFuZ3VsYXJcIiA/IHJhZGl1cyA6IHNjYWxlKHRpY2tWYWx1ZSk7XG4gIHJldHVybiBheGlzVHlwZSA9PT0gXCJhbmd1bGFyXCIgPyB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGRhdHVtOiB0aWNrLFxuICAgIHN0eWxlOiB0aWNrU3R5bGUsXG4gICAgeDE6IGdldFBvc2l0aW9uKHRpY2tSYWRpdXMsIHRpY2tBbmdsZSwgXCJ4XCIpICsgb3JpZ2luLngsXG4gICAgeTE6IGdldFBvc2l0aW9uKHRpY2tSYWRpdXMsIHRpY2tBbmdsZSwgXCJ5XCIpICsgb3JpZ2luLnksXG4gICAgeDI6IGdldFBvc2l0aW9uKHRpY2tSYWRpdXMgKyB0aWNrUGFkZGluZywgdGlja0FuZ2xlLCBcInhcIikgKyBvcmlnaW4ueCxcbiAgICB5MjogZ2V0UG9zaXRpb24odGlja1JhZGl1cyArIHRpY2tQYWRkaW5nLCB0aWNrQW5nbGUsIFwieVwiKSArIG9yaWdpbi55XG4gIH0gOiB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGRhdHVtOiB0aWNrLFxuICAgIHN0eWxlOiB0aWNrU3R5bGUsXG4gICAgeDE6IHRpY2tSYWRpdXMgKiBNYXRoLmNvcyh0aWNrQW5nbGUpICsgTWF0aC5jb3MocGFkQW5nbGUpICogdGlja1BhZGRpbmcgKyBvcmlnaW4ueCxcbiAgICB4MjogdGlja1JhZGl1cyAqIE1hdGguY29zKHRpY2tBbmdsZSkgLSBNYXRoLmNvcyhwYWRBbmdsZSkgKiB0aWNrUGFkZGluZyArIG9yaWdpbi54LFxuICAgIHkxOiB0aWNrUmFkaXVzICogTWF0aC5zaW4odGlja0FuZ2xlKSArIE1hdGguc2luKHBhZEFuZ2xlKSAqIHRpY2tQYWRkaW5nICsgb3JpZ2luLnksXG4gICAgeTI6IHRpY2tSYWRpdXMgKiBNYXRoLnNpbih0aWNrQW5nbGUpIC0gTWF0aC5zaW4ocGFkQW5nbGUpICogdGlja1BhZGRpbmcgKyBvcmlnaW4ueVxuICB9O1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblxuXG52YXIgZ2V0VGlja0xhYmVsUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIHRpY2tWYWx1ZSwgaW5kZXgpIHtcbiAgdmFyIGF4aXNUeXBlID0gY2FsY3VsYXRlZFZhbHVlcy5heGlzVHlwZSxcbiAgICAgIHJhZGl1cyA9IGNhbGN1bGF0ZWRWYWx1ZXMucmFkaXVzLFxuICAgICAgdGlja0Zvcm1hdCA9IGNhbGN1bGF0ZWRWYWx1ZXMudGlja0Zvcm1hdCxcbiAgICAgIHN0eWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zdHlsZSxcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zY2FsZSxcbiAgICAgIHRpY2tzID0gY2FsY3VsYXRlZFZhbHVlcy50aWNrcyxcbiAgICAgIHN0cmluZ1RpY2tzID0gY2FsY3VsYXRlZFZhbHVlcy5zdHJpbmdUaWNrcyxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZ2luO1xuICB2YXIgdGV4dCA9IHRpY2tGb3JtYXQodGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICB2YXIgdGljayA9IHN0cmluZ1RpY2tzID8gc3RyaW5nVGlja3NbaW5kZXhdIDogdGlja1ZhbHVlO1xuXG4gIHZhciBfZ2V0RXZhbHVhdGVkU3R5bGVzMiA9IGdldEV2YWx1YXRlZFN0eWxlcyhzdHlsZSwge1xuICAgIHRleHQ6IHRleHQsXG4gICAgdGljazogdGljayxcbiAgICB0aWNrVmFsdWU6IHRpY2tWYWx1ZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgdGlja3M6IHRpY2tzLFxuICAgIHN0cmluZ1RpY2tzOiBzdHJpbmdUaWNrcyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgYXhpc1R5cGU6IGF4aXNUeXBlXG4gIH0pLFxuICAgICAgbGFiZWxTdHlsZSA9IF9nZXRFdmFsdWF0ZWRTdHlsZXMyLmxhYmVsU3R5bGU7XG5cbiAgdmFyIHRpY2tMYWJlbENvbXBvbmVudCA9IHByb3BzLnRpY2tMYWJlbENvbXBvbmVudDtcbiAgdmFyIGxhYmVsUGxhY2VtZW50ID0gdGlja0xhYmVsQ29tcG9uZW50LnByb3BzICYmIHRpY2tMYWJlbENvbXBvbmVudC5wcm9wcy5sYWJlbFBsYWNlbWVudCA/IHRpY2tMYWJlbENvbXBvbmVudC5wcm9wcy5sYWJlbFBsYWNlbWVudCA6IHByb3BzLmxhYmVsUGxhY2VtZW50O1xuICB2YXIgdGlja1BhZGRpbmcgPSBsYWJlbFN0eWxlLnBhZGRpbmcgfHwgMDtcbiAgdmFyIGFuZ3VsYXJQYWRkaW5nID0gMDsgLy8gVE9ETzogZG8gc29tZSBnZW9tZXRyeVxuXG4gIHZhciBheGlzQW5nbGUgPSBheGlzVHlwZSA9PT0gXCJyYWRpYWxcIiA/IGdldEF4aXNBbmdsZShwcm9wcywgc2NhbGUpIDogdW5kZWZpbmVkO1xuICB2YXIgbGFiZWxBbmdsZSA9IGF4aXNUeXBlID09PSBcImFuZ3VsYXJcIiA/IEhlbHBlcnMucmFkaWFuc1RvRGVncmVlcyhzY2FsZSh0aWNrVmFsdWUpKSA6IGF4aXNBbmdsZSArIGFuZ3VsYXJQYWRkaW5nO1xuICB2YXIgdGV4dEFuZ2xlID0gbGFiZWxTdHlsZS5hbmdsZSA9PT0gdW5kZWZpbmVkID8gTGFiZWxIZWxwZXJzLmdldFBvbGFyQW5nbGUoX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBsYWJlbFBsYWNlbWVudDogbGFiZWxQbGFjZW1lbnRcbiAgfSksIGxhYmVsQW5nbGUpIDogbGFiZWxTdHlsZS5hbmdsZTtcbiAgdmFyIGxhYmVsUmFkaXVzID0gYXhpc1R5cGUgPT09IFwiYW5ndWxhclwiID8gcmFkaXVzICsgdGlja1BhZGRpbmcgOiBzY2FsZSh0aWNrVmFsdWUpO1xuICB2YXIgdGV4dEFuY2hvciA9IGxhYmVsU3R5bGUudGV4dEFuY2hvciB8fCBMYWJlbEhlbHBlcnMuZ2V0UG9sYXJUZXh0QW5jaG9yKF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgbGFiZWxQbGFjZW1lbnQ6IGxhYmVsUGxhY2VtZW50XG4gIH0pLCBsYWJlbEFuZ2xlKTtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZGF0dW06IHRpY2ssXG4gICAgc3R5bGU6IGxhYmVsU3R5bGUsXG4gICAgYW5nbGU6IHRleHRBbmdsZSxcbiAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgIHRleHQ6IHRleHQsXG4gICAgeDogbGFiZWxSYWRpdXMgKiBNYXRoLmNvcyhIZWxwZXJzLmRlZ3JlZXNUb1JhZGlhbnMobGFiZWxBbmdsZSkpICsgb3JpZ2luLngsXG4gICAgeTogLWxhYmVsUmFkaXVzICogTWF0aC5zaW4oSGVscGVycy5kZWdyZWVzVG9SYWRpYW5zKGxhYmVsQW5nbGUpKSArIG9yaWdpbi55XG4gIH07XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG5cbnZhciBnZXRHcmlkUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIHRpY2tWYWx1ZSwgaW5kZXgpIHtcbiAgdmFyIGF4aXNUeXBlID0gY2FsY3VsYXRlZFZhbHVlcy5heGlzVHlwZSxcbiAgICAgIHJhZGl1cyA9IGNhbGN1bGF0ZWRWYWx1ZXMucmFkaXVzLFxuICAgICAgc3R5bGUgPSBjYWxjdWxhdGVkVmFsdWVzLnN0eWxlLFxuICAgICAgc2NhbGUgPSBjYWxjdWxhdGVkVmFsdWVzLnNjYWxlLFxuICAgICAgc3RyaW5nVGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnN0cmluZ1RpY2tzLFxuICAgICAgdGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IGNhbGN1bGF0ZWRWYWx1ZXMudGlja0Zvcm1hdCxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZ2luO1xuICB2YXIgdGV4dCA9IHRpY2tGb3JtYXQodGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICB2YXIgc3RhcnRBbmdsZSA9IHByb3BzLnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IHByb3BzLmVuZEFuZ2xlLFxuICAgICAgX3Byb3BzJGlubmVyUmFkaXVzID0gcHJvcHMuaW5uZXJSYWRpdXMsXG4gICAgICBpbm5lclJhZGl1cyA9IF9wcm9wcyRpbm5lclJhZGl1cyA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyRpbm5lclJhZGl1cztcbiAgdmFyIHRpY2sgPSBzdHJpbmdUaWNrcyA/IHN0cmluZ1RpY2tzW2luZGV4XSA6IHRpY2tWYWx1ZTtcblxuICB2YXIgX2dldEV2YWx1YXRlZFN0eWxlczMgPSBnZXRFdmFsdWF0ZWRTdHlsZXMoc3R5bGUsIHtcbiAgICB0aWNrOiB0aWNrLFxuICAgIHRpY2tWYWx1ZTogdGlja1ZhbHVlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICB0aWNrczogdGlja3MsXG4gICAgc3RyaW5nVGlja3M6IHN0cmluZ1RpY2tzLFxuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgdGV4dDogdGV4dFxuICB9KSxcbiAgICAgIGdyaWRTdHlsZSA9IF9nZXRFdmFsdWF0ZWRTdHlsZXMzLmdyaWRTdHlsZTtcblxuICB2YXIgYW5nbGUgPSBzY2FsZSh0aWNrVmFsdWUpO1xuICByZXR1cm4gYXhpc1R5cGUgPT09IFwiYW5ndWxhclwiID8ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICBkYXR1bTogdGljayxcbiAgICBzdHlsZTogZ3JpZFN0eWxlLFxuICAgIHgxOiBnZXRQb3NpdGlvbihyYWRpdXMsIGFuZ2xlLCBcInhcIikgKyBvcmlnaW4ueCxcbiAgICB5MTogZ2V0UG9zaXRpb24ocmFkaXVzLCBhbmdsZSwgXCJ5XCIpICsgb3JpZ2luLnksXG4gICAgeDI6IGdldFBvc2l0aW9uKGlubmVyUmFkaXVzLCBhbmdsZSwgXCJ4XCIpICsgb3JpZ2luLngsXG4gICAgeTI6IGdldFBvc2l0aW9uKGlubmVyUmFkaXVzLCBhbmdsZSwgXCJ5XCIpICsgb3JpZ2luLnlcbiAgfSA6IHtcbiAgICBzdHlsZTogZ3JpZFN0eWxlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBkYXR1bTogdGljayxcbiAgICBjeDogb3JpZ2luLngsXG4gICAgY3k6IG9yaWdpbi55LFxuICAgIHI6IHNjYWxlKHRpY2tWYWx1ZSksXG4gICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgfTtcbn07XG5cbnZhciBnZXRBeGlzTGFiZWxQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcykge1xuICB2YXIgYXhpc1R5cGUgPSBjYWxjdWxhdGVkVmFsdWVzLmF4aXNUeXBlLFxuICAgICAgcmFkaXVzID0gY2FsY3VsYXRlZFZhbHVlcy5yYWRpdXMsXG4gICAgICBzdHlsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc3R5bGUsXG4gICAgICBzY2FsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc2NhbGUsXG4gICAgICBvcmlnaW4gPSBjYWxjdWxhdGVkVmFsdWVzLm9yaWdpbjtcbiAgdmFyIGF4aXNMYWJlbENvbXBvbmVudCA9IHByb3BzLmF4aXNMYWJlbENvbXBvbmVudDtcblxuICBpZiAoYXhpc1R5cGUgIT09IFwicmFkaWFsXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgbGFiZWxQbGFjZW1lbnQgPSBheGlzTGFiZWxDb21wb25lbnQucHJvcHMgJiYgYXhpc0xhYmVsQ29tcG9uZW50LnByb3BzLmxhYmVsUGxhY2VtZW50ID8gYXhpc0xhYmVsQ29tcG9uZW50LnByb3BzLmxhYmVsUGxhY2VtZW50IDogcHJvcHMubGFiZWxQbGFjZW1lbnQ7XG4gIHZhciBsYWJlbFN0eWxlID0gc3R5bGUgJiYgc3R5bGUuYXhpc0xhYmVsIHx8IHt9O1xuICB2YXIgYXhpc0FuZ2xlID0gYXhpc1R5cGUgPT09IFwicmFkaWFsXCIgPyBnZXRBeGlzQW5nbGUocHJvcHMsIHNjYWxlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRleHRBbmdsZSA9IGxhYmVsU3R5bGUuYW5nbGUgPT09IHVuZGVmaW5lZCA/IExhYmVsSGVscGVycy5nZXRQb2xhckFuZ2xlKF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgbGFiZWxQbGFjZW1lbnQ6IGxhYmVsUGxhY2VtZW50XG4gIH0pLCBheGlzQW5nbGUpIDogbGFiZWxTdHlsZS5hbmdsZTtcbiAgdmFyIGxhYmVsUmFkaXVzID0gcmFkaXVzICsgKGxhYmVsU3R5bGUucGFkZGluZyB8fCAwKTtcbiAgdmFyIHRleHRBbmNob3IgPSBsYWJlbFN0eWxlLnRleHRBbmNob3IgfHwgTGFiZWxIZWxwZXJzLmdldFBvbGFyVGV4dEFuY2hvcihfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGxhYmVsUGxhY2VtZW50OiBsYWJlbFBsYWNlbWVudFxuICB9KSwgYXhpc0FuZ2xlKTtcbiAgdmFyIHZlcnRpY2FsQW5jaG9yID0gbGFiZWxTdHlsZS52ZXJ0aWNhbEFuY2hvciB8fCBMYWJlbEhlbHBlcnMuZ2V0UG9sYXJWZXJ0aWNhbEFuY2hvcihfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGxhYmVsUGxhY2VtZW50OiBsYWJlbFBsYWNlbWVudFxuICB9KSwgYXhpc0FuZ2xlKTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogbGFiZWxTdHlsZSxcbiAgICBhbmdsZTogdGV4dEFuZ2xlLFxuICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgdmVydGljYWxBbmNob3I6IHZlcnRpY2FsQW5jaG9yLFxuICAgIHRleHQ6IHByb3BzLmxhYmVsLFxuICAgIHg6IGdldFBvc2l0aW9uKGxhYmVsUmFkaXVzLCBIZWxwZXJzLmRlZ3JlZXNUb1JhZGlhbnMoYXhpc0FuZ2xlKSwgXCJ4XCIpICsgb3JpZ2luLngsXG4gICAgeTogZ2V0UG9zaXRpb24obGFiZWxSYWRpdXMsIEhlbHBlcnMuZGVncmVlc1RvUmFkaWFucyhheGlzQW5nbGUpLCBcInlcIikgKyBvcmlnaW4ueVxuICB9O1xufTtcblxudmFyIGdldEF4aXNQcm9wcyA9IGZ1bmN0aW9uIChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSB7XG4gIHZhciBzdHlsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc3R5bGUsXG4gICAgICBheGlzVHlwZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuYXhpc1R5cGUsXG4gICAgICByYWRpdXMgPSBjYWxjdWxhdGVkVmFsdWVzLnJhZGl1cyxcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zY2FsZSxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZ2luO1xuICB2YXIgc3RhcnRBbmdsZSA9IG1vZGlmaWVkUHJvcHMuc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gbW9kaWZpZWRQcm9wcy5lbmRBbmdsZSxcbiAgICAgIF9tb2RpZmllZFByb3BzJGlubmVyUiA9IG1vZGlmaWVkUHJvcHMuaW5uZXJSYWRpdXMsXG4gICAgICBpbm5lclJhZGl1cyA9IF9tb2RpZmllZFByb3BzJGlubmVyUiA9PT0gdm9pZCAwID8gMCA6IF9tb2RpZmllZFByb3BzJGlubmVyUjtcbiAgdmFyIGF4aXNBbmdsZSA9IGF4aXNUeXBlID09PSBcInJhZGlhbFwiID8gSGVscGVycy5kZWdyZWVzVG9SYWRpYW5zKGdldEF4aXNBbmdsZShtb2RpZmllZFByb3BzLCBzY2FsZSkpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gYXhpc1R5cGUgPT09IFwicmFkaWFsXCIgPyB7XG4gICAgc3R5bGU6IHN0eWxlLmF4aXMsXG4gICAgeDE6IGdldFBvc2l0aW9uKGlubmVyUmFkaXVzLCBheGlzQW5nbGUsIFwieFwiKSArIG9yaWdpbi54LFxuICAgIHgyOiBnZXRQb3NpdGlvbihyYWRpdXMsIGF4aXNBbmdsZSwgXCJ4XCIpICsgb3JpZ2luLngsXG4gICAgeTE6IGdldFBvc2l0aW9uKGlubmVyUmFkaXVzLCBheGlzQW5nbGUsIFwieVwiKSArIG9yaWdpbi55LFxuICAgIHkyOiBnZXRQb3NpdGlvbihyYWRpdXMsIGF4aXNBbmdsZSwgXCJ5XCIpICsgb3JpZ2luLnlcbiAgfSA6IHtcbiAgICBzdHlsZTogc3R5bGUuYXhpcyxcbiAgICBjeDogb3JpZ2luLngsXG4gICAgY3k6IG9yaWdpbi55LFxuICAgIHI6IHJhZGl1cyxcbiAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICB9O1xufTtcblxudmFyIGdldENhbGN1bGF0ZWRWYWx1ZXMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICBwb2xhcjogdHJ1ZVxuICB9LCBwcm9wcyk7XG4gIHZhciBkZWZhdWx0U3R5bGVzID0gZ2V0U3R5bGVPYmplY3QocHJvcHMpO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZXMocHJvcHMsIGRlZmF1bHRTdHlsZXMpO1xuICB2YXIgcGFkZGluZyA9IEhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyk7XG4gIHZhciBheGlzID0gQXhpcy5nZXRBeGlzKHByb3BzKTtcbiAgdmFyIGF4aXNUeXBlID0gZ2V0QXhpc1R5cGUocHJvcHMpO1xuICB2YXIgc3RyaW5nVGlja3MgPSBBeGlzLnN0cmluZ1RpY2tzKHByb3BzKSA/IHByb3BzLnRpY2tWYWx1ZXMgOiB1bmRlZmluZWQ7XG4gIHZhciBkb21haW4gPSBBeGlzLmdldERvbWFpbihwcm9wcywgYXhpcyk7XG4gIHZhciByYW5nZSA9IGdldFJhbmdlKHByb3BzLCBheGlzKTtcbiAgdmFyIHNjYWxlID0gZ2V0U2NhbGUocHJvcHMpO1xuICB2YXIgaW5pdGlhbFRpY2tzID0gQXhpcy5nZXRUaWNrcyhwcm9wcywgc2NhbGUpO1xuICB2YXIgdGlja3MgPSBheGlzVHlwZSA9PT0gXCJhbmd1bGFyXCIgPyBmaWx0ZXJUaWNrcyhpbml0aWFsVGlja3MsIHNjYWxlKSA6IGluaXRpYWxUaWNrcztcbiAgdmFyIHRpY2tGb3JtYXQgPSBBeGlzLmdldFRpY2tGb3JtYXQocHJvcHMsIHNjYWxlKTtcbiAgdmFyIHJhZGl1cyA9IGdldFJhZGl1cyhwcm9wcyk7XG4gIHZhciBvcmlnaW4gPSBIZWxwZXJzLmdldFBvbGFyT3JpZ2luKHByb3BzKTtcbiAgcmV0dXJuIHtcbiAgICBheGlzOiBheGlzLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIHN0cmluZ1RpY2tzOiBzdHJpbmdUaWNrcyxcbiAgICBheGlzVHlwZTogYXhpc1R5cGUsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHRpY2tzOiB0aWNrcyxcbiAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgIGRvbWFpbjogZG9tYWluLFxuICAgIHJhbmdlOiByYW5nZSxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBvcmlnaW46IG9yaWdpblxuICB9O1xufTtcblxuZXhwb3J0IHZhciBnZXRCYXNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGZhbGxiYWNrUHJvcHMpIHtcbiAgcHJvcHMgPSBBeGlzLm1vZGlmeVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzKTtcbiAgdmFyIGNhbGN1bGF0ZWRWYWx1ZXMgPSBnZXRDYWxjdWxhdGVkVmFsdWVzKHByb3BzKTtcbiAgdmFyIHN0eWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zdHlsZSxcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zY2FsZSxcbiAgICAgIHRpY2tzID0gY2FsY3VsYXRlZFZhbHVlcy50aWNrcyxcbiAgICAgIGRvbWFpbiA9IGNhbGN1bGF0ZWRWYWx1ZXMuZG9tYWluO1xuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICB3aWR0aCA9IF9wcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9wcm9wcy5oZWlnaHQsXG4gICAgICBzdGFuZGFsb25lID0gX3Byb3BzLnN0YW5kYWxvbmUsXG4gICAgICB0aGVtZSA9IF9wcm9wcy50aGVtZSxcbiAgICAgIG5hbWUgPSBfcHJvcHMubmFtZTtcbiAgdmFyIGF4aXNQcm9wcyA9IGdldEF4aXNQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFZhbHVlcyk7XG4gIHZhciBheGlzTGFiZWxQcm9wcyA9IGdldEF4aXNMYWJlbFByb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKTtcbiAgdmFyIGluaXRpYWxDaGlsZFByb3BzID0ge1xuICAgIHBhcmVudDoge1xuICAgICAgc3R5bGU6IHN0eWxlLnBhcmVudCxcbiAgICAgIHRpY2tzOiB0aWNrcyxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICBzdGFuZGFsb25lOiBzdGFuZGFsb25lLFxuICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRpY2tzLnJlZHVjZShmdW5jdGlvbiAoY2hpbGRQcm9wcywgdGljaywgaW5kZXgpIHtcbiAgICBjaGlsZFByb3BzW2luZGV4XSA9IHtcbiAgICAgIGF4aXM6IGF4aXNQcm9wcyxcbiAgICAgIGF4aXNMYWJlbDogYXhpc0xhYmVsUHJvcHMsXG4gICAgICB0aWNrczogZ2V0VGlja1Byb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCB0aWNrLCBpbmRleCksXG4gICAgICB0aWNrTGFiZWxzOiBnZXRUaWNrTGFiZWxQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFZhbHVlcywgdGljaywgaW5kZXgpLFxuICAgICAgZ3JpZDogZ2V0R3JpZFByb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCB0aWNrLCBpbmRleClcbiAgICB9O1xuICAgIHJldHVybiBjaGlsZFByb3BzO1xuICB9LCBpbml0aWFsQ2hpbGRQcm9wcyk7XG59OyIsImltcG9ydCBfaXNFbXB0eSBmcm9tIFwibG9kYXNoL2lzRW1wdHlcIjtcbmltcG9ydCBfYXNzaWduIGZyb20gXCJsb2Rhc2gvYXNzaWduXCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgUHJvcFR5cGVzIGFzIEN1c3RvbVByb3BUeXBlcywgVmljdG9yeUxhYmVsLCBDb21tb25Qcm9wcywgVmljdG9yeUNvbnRhaW5lciwgVmljdG9yeVRoZW1lLCBMaW5lU2VnbWVudCwgYWRkRXZlbnRzLCBBcmMsIEF4aXMgfSBmcm9tIFwidmljdG9yeS1jb3JlXCI7XG5pbXBvcnQgeyBnZXRTY2FsZSwgZ2V0U3R5bGVzLCBnZXRCYXNlUHJvcHMgfSBmcm9tIFwiLi9oZWxwZXItbWV0aG9kc1wiO1xudmFyIGZhbGxiYWNrUHJvcHMgPSB7XG4gIHdpZHRoOiA0NTAsXG4gIGhlaWdodDogMzAwLFxuICBwYWRkaW5nOiA1MFxufTtcbnZhciBvcHRpb25zID0ge1xuICBjb21wb25lbnRzOiBbe1xuICAgIG5hbWU6IFwiYXhpc1wiLFxuICAgIGluZGV4OiAwXG4gIH0sIHtcbiAgICBuYW1lOiBcImF4aXNMYWJlbFwiLFxuICAgIGluZGV4OiAwXG4gIH0sIHtcbiAgICBuYW1lOiBcImdyaWRcIlxuICB9LCB7XG4gICAgbmFtZTogXCJwYXJlbnRcIixcbiAgICBpbmRleDogXCJwYXJlbnRcIlxuICB9LCB7XG4gICAgbmFtZTogXCJ0aWNrc1wiXG4gIH0sIHtcbiAgICBuYW1lOiBcInRpY2tMYWJlbHNcIlxuICB9XVxufTtcblxudmFyIFZpY3RvcnlQb2xhckF4aXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFZpY3RvcnlQb2xhckF4aXMsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVmljdG9yeVBvbGFyQXhpcyk7XG5cbiAgZnVuY3Rpb24gVmljdG9yeVBvbGFyQXhpcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmljdG9yeVBvbGFyQXhpcyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmljdG9yeVBvbGFyQXhpcywgW3tcbiAgICBrZXk6IFwicmVuZGVyQXhpc0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXhpc0xpbmUocHJvcHMpIHtcbiAgICAgIHZhciBkZXBlbmRlbnRBeGlzID0gcHJvcHMuZGVwZW5kZW50QXhpcztcbiAgICAgIHZhciBheGlzQ29tcG9uZW50ID0gZGVwZW5kZW50QXhpcyA/IHByb3BzLmF4aXNDb21wb25lbnQgOiBwcm9wcy5jaXJjdWxhckF4aXNDb21wb25lbnQ7XG4gICAgICB2YXIgYXhpc1Byb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhheGlzQ29tcG9uZW50LCBcImF4aXNcIiwgMCk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChheGlzQ29tcG9uZW50LCBheGlzUHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYWJlbChwcm9wcykge1xuICAgICAgdmFyIGF4aXNMYWJlbENvbXBvbmVudCA9IHByb3BzLmF4aXNMYWJlbENvbXBvbmVudCxcbiAgICAgICAgICBkZXBlbmRlbnRBeGlzID0gcHJvcHMuZGVwZW5kZW50QXhpcyxcbiAgICAgICAgICBsYWJlbCA9IHByb3BzLmxhYmVsO1xuXG4gICAgICBpZiAoIWxhYmVsIHx8ICFkZXBlbmRlbnRBeGlzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXhpc0xhYmVsUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKGF4aXNMYWJlbENvbXBvbmVudCwgXCJheGlzTGFiZWxcIiwgMCk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChheGlzTGFiZWxDb21wb25lbnQsIGF4aXNMYWJlbFByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBeGlzKHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdGlja0NvbXBvbmVudCA9IHByb3BzLnRpY2tDb21wb25lbnQsXG4gICAgICAgICAgdGlja0xhYmVsQ29tcG9uZW50ID0gcHJvcHMudGlja0xhYmVsQ29tcG9uZW50LFxuICAgICAgICAgIG5hbWUgPSBwcm9wcy5uYW1lO1xuXG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3BzKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50UHJvcHMkc3R5bGUgPSBjb21wb25lbnRQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlID0gX2NvbXBvbmVudFByb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9jb21wb25lbnRQcm9wcyRzdHlsZSxcbiAgICAgICAgICAgIF9jb21wb25lbnRQcm9wcyRldmVudCA9IGNvbXBvbmVudFByb3BzLmV2ZW50cyxcbiAgICAgICAgICAgIGV2ZW50cyA9IF9jb21wb25lbnRQcm9wcyRldmVudCA9PT0gdm9pZCAwID8ge30gOiBfY29tcG9uZW50UHJvcHMkZXZlbnQ7XG4gICAgICAgIHZhciB2aXNpYmxlID0gc3R5bGUuc3Ryb2tlICE9PSBcInRyYW5zcGFyZW50XCIgJiYgc3R5bGUuc3Ryb2tlICE9PSBcIm5vbmVcIiAmJiBzdHlsZS5zdHJva2VXaWR0aCAhPT0gMDtcbiAgICAgICAgcmV0dXJuIHZpc2libGUgfHwgIV9pc0VtcHR5KGV2ZW50cyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYXhpc1R5cGUgPSBwcm9wcy5kZXBlbmRlbnRBeGlzID8gXCJyYWRpYWxcIiA6IFwiYW5ndWxhclwiO1xuICAgICAgdmFyIGdyaWRDb21wb25lbnQgPSBheGlzVHlwZSA9PT0gXCJyYWRpYWxcIiA/IHByb3BzLmNpcmN1bGFyR3JpZENvbXBvbmVudCA6IHByb3BzLmdyaWRDb21wb25lbnQ7XG4gICAgICB2YXIgdGlja0NvbXBvbmVudHMgPSB0aGlzLmRhdGFLZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICB2YXIgdGlja1Byb3BzID0gX2Fzc2lnbih7XG4gICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChuYW1lLCBcIi10aWNrLVwiKS5jb25jYXQoa2V5KVxuICAgICAgICB9LCBfdGhpcy5nZXRDb21wb25lbnRQcm9wcyh0aWNrQ29tcG9uZW50LCBcInRpY2tzXCIsIGluZGV4KSk7XG5cbiAgICAgICAgdmFyIFRpY2tDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHRpY2tDb21wb25lbnQsIHRpY2tQcm9wcyk7XG4gICAgICAgIHJldHVybiBzaG91bGRSZW5kZXIoVGlja0NvbXBvbmVudC5wcm9wcykgPyBUaWNrQ29tcG9uZW50IDogdW5kZWZpbmVkO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdmFyIGdyaWRDb21wb25lbnRzID0gdGhpcy5kYXRhS2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGdyaWRQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICAgIGtleTogXCJcIi5jb25jYXQobmFtZSwgXCItZ3JpZC1cIikuY29uY2F0KGtleSlcbiAgICAgICAgfSwgX3RoaXMuZ2V0Q29tcG9uZW50UHJvcHMoZ3JpZENvbXBvbmVudCwgXCJncmlkXCIsIGluZGV4KSk7XG5cbiAgICAgICAgdmFyIEdyaWRDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGdyaWRDb21wb25lbnQsIGdyaWRQcm9wcyk7XG4gICAgICAgIHJldHVybiBzaG91bGRSZW5kZXIoR3JpZENvbXBvbmVudC5wcm9wcykgPyBHcmlkQ29tcG9uZW50IDogdW5kZWZpbmVkO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdmFyIHRpY2tMYWJlbENvbXBvbmVudHMgPSB0aGlzLmRhdGFLZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICB2YXIgdGlja0xhYmVsUHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KG5hbWUsIFwiLXRpY2stXCIpLmNvbmNhdChrZXkpXG4gICAgICAgIH0sIF90aGlzLmdldENvbXBvbmVudFByb3BzKHRpY2tMYWJlbENvbXBvbmVudCwgXCJ0aWNrTGFiZWxzXCIsIGluZGV4KSk7XG5cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQodGlja0xhYmVsQ29tcG9uZW50LCB0aWNrTGFiZWxQcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBheGlzID0gdGhpcy5yZW5kZXJBeGlzTGluZShwcm9wcyk7XG4gICAgICB2YXIgYXhpc0xhYmVsID0gdGhpcy5yZW5kZXJMYWJlbChwcm9wcyk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbYXhpcywgYXhpc0xhYmVsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRpY2tDb21wb25lbnRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGdyaWRDb21wb25lbnRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRpY2tMYWJlbENvbXBvbmVudHMpKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckdyb3VwKHByb3BzLCBjaGlsZHJlbik7XG4gICAgfSAvLyBPdmVycmlkZGVuIGluIHZpY3RvcnktbmF0aXZlXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJHcm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJHcm91cChwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgIHZhciBncm91cENvbXBvbmVudCA9IHByb3BzLmdyb3VwQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoZ3JvdXBDb21wb25lbnQsIHt9LCBjaGlsZHJlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3VsZEFuaW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQW5pbWF0ZSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMucHJvcHMuYW5pbWF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBhbmltYXRpb25XaGl0ZWxpc3QgPSBWaWN0b3J5UG9sYXJBeGlzLmFuaW1hdGlvbldoaXRlbGlzdDtcbiAgICAgIHZhciBwcm9wcyA9IEF4aXMubW9kaWZ5UHJvcHModGhpcy5wcm9wcywgZmFsbGJhY2tQcm9wcyk7XG5cbiAgICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlQ29tcG9uZW50KHByb3BzLCBhbmltYXRpb25XaGl0ZWxpc3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbmRlckF4aXMocHJvcHMpO1xuICAgICAgcmV0dXJuIHByb3BzLnN0YW5kYWxvbmUgPyB0aGlzLnJlbmRlckNvbnRhaW5lcihwcm9wcy5jb250YWluZXJDb21wb25lbnQsIGNoaWxkcmVuKSA6IGNoaWxkcmVuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWN0b3J5UG9sYXJBeGlzO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5WaWN0b3J5UG9sYXJBeGlzLmFuaW1hdGlvbldoaXRlbGlzdCA9IFtcInN0eWxlXCIsIFwiZG9tYWluXCIsIFwicmFuZ2VcIiwgXCJ0aWNrQ291bnRcIiwgXCJ0aWNrVmFsdWVzXCIsIFwicGFkZGluZ1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xuVmljdG9yeVBvbGFyQXhpcy5kaXNwbGF5TmFtZSA9IFwiVmljdG9yeUF4aXNcIjtcblZpY3RvcnlQb2xhckF4aXMucm9sZSA9IFwiYXhpc1wiO1xuVmljdG9yeVBvbGFyQXhpcy5kZWZhdWx0VHJhbnNpdGlvbnMgPSB7XG4gIG9uRXhpdDoge1xuICAgIGR1cmF0aW9uOiA1MDBcbiAgfSxcbiAgb25FbnRlcjoge1xuICAgIGR1cmF0aW9uOiA1MDBcbiAgfVxufTtcblZpY3RvcnlQb2xhckF4aXMucHJvcFR5cGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBDb21tb25Qcm9wcy5iYXNlUHJvcHMpLCB7fSwge1xuICBheGlzQW5nbGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGF4aXNDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBheGlzTGFiZWxDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBheGlzVmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgY2F0ZWdvcmllczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgeTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZylcbiAgfSldKSxcbiAgY2lyY3VsYXJBeGlzQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgY2lyY3VsYXJHcmlkQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgY29udGFpbmVyQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgZGVwZW5kZW50QXhpczogUHJvcFR5cGVzLmJvb2wsXG4gIGRpc2FibGVJbmxpbmVTdHlsZXM6IFByb3BUeXBlcy5ib29sLFxuICBlbmRBbmdsZTogUHJvcFR5cGVzLm51bWJlcixcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHRhcmdldDogUHJvcFR5cGVzLm9uZU9mKFtcImF4aXNcIiwgXCJheGlzTGFiZWxcIiwgXCJncmlkXCIsIFwidGlja3NcIiwgXCJ0aWNrTGFiZWxzXCJdKSxcbiAgICBldmVudEtleTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBDdXN0b21Qcm9wVHlwZXMuYWxsT2ZUeXBlKFtDdXN0b21Qcm9wVHlwZXMuaW50ZWdlciwgQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlXSksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBldmVudEhhbmRsZXJzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pKSxcbiAgZ3JpZENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIGlubmVyUmFkaXVzOiBDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmUsXG4gIGxhYmVsUGxhY2VtZW50OiBQcm9wVHlwZXMub25lT2YoW1wicGFyYWxsZWxcIiwgXCJwZXJwZW5kaWN1bGFyXCIsIFwidmVydGljYWxcIl0pLFxuICBzdGFydEFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJpbmdNYXA6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHBhcmVudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBheGlzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGF4aXNMYWJlbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBncmlkOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRpY2tzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRpY2tMYWJlbHM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSksXG4gIHRpY2tDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICB0aWNrQ291bnQ6IEN1c3RvbVByb3BUeXBlcy5hbGxPZlR5cGUoW0N1c3RvbVByb3BUeXBlcy5pbnRlZ2VyLCBDdXN0b21Qcm9wVHlwZXMuZ3JlYXRlclRoYW5aZXJvXSksXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBDdXN0b21Qcm9wVHlwZXMuaG9tb2dlbmVvdXNBcnJheV0pLFxuICB0aWNrTGFiZWxDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICB0aWNrVmFsdWVzOiBDdXN0b21Qcm9wVHlwZXMuaG9tb2dlbmVvdXNBcnJheVxufSk7XG5WaWN0b3J5UG9sYXJBeGlzLmRlZmF1bHRQcm9wcyA9IHtcbiAgYXhpc0NvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZVNlZ21lbnQsIG51bGwpLFxuICBheGlzTGFiZWxDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlMYWJlbCwgbnVsbCksXG4gIGNpcmN1bGFyQXhpc0NvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJjLCBudWxsKSxcbiAgY2lyY3VsYXJHcmlkQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcmMsIG51bGwpLFxuICBjb250YWluZXJDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlDb250YWluZXIsIG51bGwpLFxuICBlbmRBbmdsZTogMzYwLFxuICBncmlkQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lU2VnbWVudCwgbnVsbCksXG4gIGdyb3VwQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgfSksXG4gIGxhYmVsUGxhY2VtZW50OiBcInBhcmFsbGVsXCIsXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIHRoZW1lOiBWaWN0b3J5VGhlbWUuZ3JheXNjYWxlLFxuICB0aWNrQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lU2VnbWVudCwgbnVsbCksXG4gIHRpY2tMYWJlbENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUxhYmVsLCBudWxsKVxufTtcblZpY3RvcnlQb2xhckF4aXMuZ2V0RG9tYWluID0gQXhpcy5nZXREb21haW47XG5WaWN0b3J5UG9sYXJBeGlzLmdldEF4aXMgPSBBeGlzLmdldEF4aXM7XG5WaWN0b3J5UG9sYXJBeGlzLmdldFNjYWxlID0gZ2V0U2NhbGU7XG5cblZpY3RvcnlQb2xhckF4aXMuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBnZXRTdHlsZXMocHJvcHMsIGZhbGxiYWNrUHJvcHMuc3R5bGUpO1xufTtcblxuVmljdG9yeVBvbGFyQXhpcy5nZXRCYXNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIGdldEJhc2VQcm9wcyhwcm9wcywgZmFsbGJhY2tQcm9wcyk7XG59O1xuXG5WaWN0b3J5UG9sYXJBeGlzLmV4cGVjdGVkQ29tcG9uZW50cyA9IFtcImF4aXNDb21wb25lbnRcIiwgXCJjaXJjdWxhckF4aXNDb21wb25lbnRcIiwgXCJncm91cENvbXBvbmVudFwiLCBcImNvbnRhaW5lckNvbXBvbmVudFwiLCBcInRpY2tDb21wb25lbnRcIiwgXCJ0aWNrTGFiZWxDb21wb25lbnRcIiwgXCJncmlkQ29tcG9uZW50XCIsIFwiY2lyY3VsYXJHcmlkQ29tcG9uZW50XCJdO1xuZXhwb3J0IGRlZmF1bHQgYWRkRXZlbnRzKFZpY3RvcnlQb2xhckF4aXMsIG9wdGlvbnMpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22528\n')}}]);