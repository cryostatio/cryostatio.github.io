"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[9346],{50408:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"aO\": () => (/* binding */ ACTIONS),\n  \"FP\": () => (/* binding */ EVENTS),\n  \"Q_\": () => (/* binding */ STATUS),\n  \"ZP\": () => (/* binding */ Joyride)\n});\n\n// UNUSED EXPORTS: LIFECYCLE\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/tree-changes/esm/index.js + 1 modules\nvar esm = __webpack_require__(2494);\n;// CONCATENATED MODULE: ./node_modules/react-joyride/node_modules/is-lite/dist/index.mjs\n// src/index.ts\nvar DOM_PROPERTIES_TO_CHECK = [\n  \"innerHTML\",\n  \"ownerDocument\",\n  \"style\",\n  \"attributes\",\n  \"nodeValue\"\n];\nvar objectTypes = [\n  \"Array\",\n  \"ArrayBuffer\",\n  \"AsyncFunction\",\n  \"AsyncGenerator\",\n  \"AsyncGeneratorFunction\",\n  \"Date\",\n  \"Error\",\n  \"Function\",\n  \"Generator\",\n  \"GeneratorFunction\",\n  \"HTMLElement\",\n  \"Map\",\n  \"Object\",\n  \"Promise\",\n  \"RegExp\",\n  \"Set\",\n  \"WeakMap\",\n  \"WeakSet\"\n];\nvar primitiveTypes = [\n  \"bigint\",\n  \"boolean\",\n  \"null\",\n  \"number\",\n  \"string\",\n  \"symbol\",\n  \"undefined\"\n];\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (/HTML\\w+Element/.test(objectTypeName)) {\n    return \"HTMLElement\";\n  }\n  if (isObjectType(objectTypeName)) {\n    return objectTypeName;\n  }\n  return void 0;\n}\nfunction isObjectOfType(type) {\n  return (value) => getObjectType(value) === type;\n}\nfunction isObjectType(name) {\n  return objectTypes.includes(name);\n}\nfunction isOfType(type) {\n  return (value) => typeof value === type;\n}\nfunction isPrimitiveType(name) {\n  return primitiveTypes.includes(name);\n}\nfunction is(value) {\n  if (value === null) {\n    return \"null\";\n  }\n  switch (typeof value) {\n    case \"bigint\":\n      return \"bigint\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n    case \"string\":\n      return \"string\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"undefined\":\n      return \"undefined\";\n    default:\n  }\n  if (is.array(value)) {\n    return \"Array\";\n  }\n  if (is.plainFunction(value)) {\n    return \"Function\";\n  }\n  const tagType = getObjectType(value);\n  if (tagType) {\n    return tagType;\n  }\n  return \"Object\";\n}\nis.array = Array.isArray;\nis.arrayOf = (target, predicate) => {\n  if (!is.array(target) && !is.function(predicate)) {\n    return false;\n  }\n  return target.every((d) => predicate(d));\n};\nis.asyncGeneratorFunction = (value) => getObjectType(value) === \"AsyncGeneratorFunction\";\nis.asyncFunction = isObjectOfType(\"AsyncFunction\");\nis.bigint = isOfType(\"bigint\");\nis.boolean = (value) => {\n  return value === true || value === false;\n};\nis.date = isObjectOfType(\"Date\");\nis.defined = (value) => !is.undefined(value);\nis.domElement = (value) => {\n  return is.object(value) && !is.plainObject(value) && value.nodeType === 1 && is.string(value.nodeName) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);\n};\nis.empty = (value) => {\n  return is.string(value) && value.length === 0 || is.array(value) && value.length === 0 || is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0 || is.set(value) && value.size === 0 || is.map(value) && value.size === 0;\n};\nis.error = isObjectOfType(\"Error\");\nis.function = isOfType(\"function\");\nis.generator = (value) => {\n  return is.iterable(value) && is.function(value.next) && is.function(value.throw);\n};\nis.generatorFunction = isObjectOfType(\"GeneratorFunction\");\nis.instanceOf = (instance, class_) => {\n  if (!instance || !class_) {\n    return false;\n  }\n  return Object.getPrototypeOf(instance) === class_.prototype;\n};\nis.iterable = (value) => {\n  return !is.nullOrUndefined(value) && is.function(value[Symbol.iterator]);\n};\nis.map = isObjectOfType(\"Map\");\nis.nan = (value) => {\n  return Number.isNaN(value);\n};\nis.null = (value) => {\n  return value === null;\n};\nis.nullOrUndefined = (value) => {\n  return is.null(value) || is.undefined(value);\n};\nis.number = (value) => {\n  return isOfType(\"number\")(value) && !is.nan(value);\n};\nis.numericString = (value) => {\n  return is.string(value) && value.length > 0 && !Number.isNaN(Number(value));\n};\nis.object = (value) => {\n  return !is.nullOrUndefined(value) && (is.function(value) || typeof value === \"object\");\n};\nis.oneOf = (target, value) => {\n  if (!is.array(target)) {\n    return false;\n  }\n  return target.indexOf(value) > -1;\n};\nis.plainFunction = isObjectOfType(\"Function\");\nis.plainObject = (value) => {\n  if (getObjectType(value) !== \"Object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.getPrototypeOf({});\n};\nis.primitive = (value) => is.null(value) || isPrimitiveType(typeof value);\nis.promise = isObjectOfType(\"Promise\");\nis.propertyOf = (target, key, predicate) => {\n  if (!is.object(target) || !key) {\n    return false;\n  }\n  const value = target[key];\n  if (is.function(predicate)) {\n    return predicate(value);\n  }\n  return is.defined(value);\n};\nis.regexp = isObjectOfType(\"RegExp\");\nis.set = isObjectOfType(\"Set\");\nis.string = isOfType(\"string\");\nis.symbol = isOfType(\"symbol\");\nis.undefined = isOfType(\"undefined\");\nis.weakMap = isObjectOfType(\"WeakMap\");\nis.weakSet = isObjectOfType(\"WeakSet\");\nvar src_default = is;\n\n//# sourceMappingURL=index.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(73935);\n// EXTERNAL MODULE: ./node_modules/exenv/index.js\nvar exenv = __webpack_require__(58875);\nvar exenv_default = /*#__PURE__*/__webpack_require__.n(exenv);\n// EXTERNAL MODULE: ./node_modules/scroll/index.js\nvar node_modules_scroll = __webpack_require__(67339);\nvar scroll_default = /*#__PURE__*/__webpack_require__.n(node_modules_scroll);\n// EXTERNAL MODULE: ./node_modules/scrollparent/scrollparent.js\nvar scrollparent = __webpack_require__(27274);\nvar scrollparent_default = /*#__PURE__*/__webpack_require__.n(scrollparent);\n// EXTERNAL MODULE: ./node_modules/react-is/index.js\nvar react_is = __webpack_require__(59864);\n// EXTERNAL MODULE: ./node_modules/deepmerge/dist/cjs.js\nvar cjs = __webpack_require__(9996);\nvar cjs_default = /*#__PURE__*/__webpack_require__.n(cjs);\n// EXTERNAL MODULE: ./node_modules/react-floater/es/index.js\nvar es = __webpack_require__(53898);\n;// CONCATENATED MODULE: ./node_modules/react-joyride/es/index.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar ACTIONS = {\n  INIT: 'init',\n  START: 'start',\n  STOP: 'stop',\n  RESET: 'reset',\n  PREV: 'prev',\n  NEXT: 'next',\n  GO: 'go',\n  CLOSE: 'close',\n  SKIP: 'skip',\n  UPDATE: 'update'\n};\n\nvar EVENTS = {\n  TOUR_START: 'tour:start',\n  STEP_BEFORE: 'step:before',\n  BEACON: 'beacon',\n  TOOLTIP: 'tooltip',\n  STEP_AFTER: 'step:after',\n  TOUR_END: 'tour:end',\n  TOUR_STATUS: 'tour:status',\n  TARGET_NOT_FOUND: 'error:target_not_found',\n  ERROR: 'error'\n};\n\nvar LIFECYCLE = {\n  INIT: 'init',\n  READY: 'ready',\n  BEACON: 'beacon',\n  TOOLTIP: 'tooltip',\n  COMPLETE: 'complete',\n  ERROR: 'error'\n};\n\nvar STATUS = {\n  IDLE: 'idle',\n  READY: 'ready',\n  WAITING: 'waiting',\n  RUNNING: 'running',\n  PAUSED: 'paused',\n  SKIPPED: 'skipped',\n  FINISHED: 'finished',\n  ERROR: 'error'\n};\n\nvar canUseDOM = (exenv_default()).canUseDOM;\nvar isReact16 = react_dom.createPortal !== undefined;\n/**\n * Get the current browser\n *\n * @param {string} userAgent\n *\n * @returns {String}\n */\n\nfunction getBrowser() {\n  var userAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : navigator.userAgent;\n  var browser = userAgent;\n\n  if (typeof window === 'undefined') {\n    browser = 'node';\n  } else if (document.documentMode) {\n    browser = 'ie';\n  } else if (/Edge/.test(userAgent)) {\n    browser = 'edge';\n  } // Opera 8.0+\n  else if (Boolean(window.opera) || userAgent.indexOf(' OPR/') >= 0) {\n    browser = 'opera';\n  } // Firefox 1.0+\n  else if (typeof window.InstallTrigger !== 'undefined') {\n    browser = 'firefox';\n  } // Chrome 1+\n  else if (window.chrome) {\n    browser = 'chrome';\n  } // Safari (and Chrome iOS, Firefox iOS)\n  else if (/(Version\\/([0-9._]+).*Safari|CriOS|FxiOS| Mobile\\/)/.test(userAgent)) {\n    browser = 'safari';\n  }\n\n  return browser;\n}\n/**\n * Get the toString Object type\n * @param {*} value\n * @returns {string}\n */\n\nfunction es_getObjectType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n}\n/**\n * Get text from React components\n *\n * @param {*} root\n *\n * @returns {string}\n */\n\nfunction getText(root) {\n  var content = [];\n\n  var recurse = function recurse(child) {\n    /* istanbul ignore else */\n    if (typeof child === 'string' || typeof child === 'number') {\n      content.push(child);\n    } else if (Array.isArray(child)) {\n      child.forEach(function (c) {\n        return recurse(c);\n      });\n    } else if (child && child.props) {\n      var children = child.props.children;\n\n      if (Array.isArray(children)) {\n        children.forEach(function (c) {\n          return recurse(c);\n        });\n      } else {\n        recurse(children);\n      }\n    }\n  };\n\n  recurse(root);\n  return content.join(' ').trim();\n}\nfunction es_hasOwnProperty(value, key) {\n  return Object.prototype.hasOwnProperty.call(value, key);\n}\nfunction hasValidKeys(value, keys) {\n  if (!src_default.plainObject(value) || !src_default.array(keys)) {\n    return false;\n  }\n\n  return Object.keys(value).every(function (d) {\n    return keys.indexOf(d) !== -1;\n  });\n}\n/**\n * Convert hex to RGB\n *\n * @param {string} hex\n * @returns {Array}\n */\n\nfunction hexToRGB(hex) {\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  var properHex = hex.replace(shorthandRegex, function (m, r, g, b) {\n    return r + r + g + g + b + b;\n  });\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(properHex);\n  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [];\n}\n/**\n * Decide if the step shouldn't skip the beacon\n * @param {Object} step\n *\n * @returns {boolean}\n */\n\nfunction hideBeacon(step) {\n  return step.disableBeacon || step.placement === 'center';\n}\n/**\n * Compare if two variables are equal\n *\n * @param {*} left\n * @param {*} right\n *\n * @returns {boolean}\n */\n\nfunction isEqual(left, right) {\n  var type;\n  var hasReactElement = /*#__PURE__*/(0,react.isValidElement)(left) || /*#__PURE__*/(0,react.isValidElement)(right);\n  var hasUndefined = src_default.undefined(left) || src_default.undefined(right);\n\n  if (es_getObjectType(left) !== es_getObjectType(right) || hasReactElement || hasUndefined) {\n    return false;\n  }\n\n  if (src_default.domElement(left)) {\n    return left.isSameNode(right);\n  }\n\n  if (src_default.number(left)) {\n    return left === right;\n  }\n\n  if (src_default[\"function\"](left)) {\n    return left.toString() === right.toString();\n  }\n\n  for (var key in left) {\n    /* istanbul ignore else */\n    if (es_hasOwnProperty(left, key)) {\n      if (typeof left[key] === 'undefined' || typeof right[key] === 'undefined') {\n        return false;\n      }\n\n      type = es_getObjectType(left[key]);\n\n      if (['object', 'array'].indexOf(type) !== -1 && isEqual(left[key], right[key])) {\n        continue;\n      }\n\n      if (type === 'function' && isEqual(left[key], right[key])) {\n        continue;\n      }\n\n      if (left[key] !== right[key]) {\n        return false;\n      }\n    }\n  }\n\n  for (var p in right) {\n    /* istanbul ignore else */\n    if (es_hasOwnProperty(right, p)) {\n      if (typeof left[p] === 'undefined') {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Detect legacy browsers\n *\n * @returns {boolean}\n */\n\nfunction isLegacy() {\n  return !(['chrome', 'safari', 'firefox', 'opera'].indexOf(getBrowser()) !== -1);\n}\n/**\n * Log method calls if debug is enabled\n *\n * @private\n * @param {Object}       arg\n * @param {string}       arg.title    - The title the logger was called from\n * @param {Object|Array} [arg.data]   - The data to be logged\n * @param {boolean}      [arg.warn]  - If true, the message will be a warning\n * @param {boolean}      [arg.debug] - Nothing will be logged unless debug is true\n */\n\nfunction log(_ref) {\n  var title = _ref.title,\n      data = _ref.data,\n      _ref$warn = _ref.warn,\n      warn = _ref$warn === void 0 ? false : _ref$warn,\n      _ref$debug = _ref.debug,\n      debug = _ref$debug === void 0 ? false : _ref$debug;\n\n  /* eslint-disable no-console */\n  var logFn = warn ? console.warn || console.error : console.log;\n\n  if (debug) {\n    if (title && data) {\n      console.groupCollapsed(\"%creact-joyride: \".concat(title), 'color: #ff0044; font-weight: bold; font-size: 12px;');\n\n      if (Array.isArray(data)) {\n        data.forEach(function (d) {\n          if (src_default.plainObject(d) && d.key) {\n            logFn.apply(console, [d.key, d.value]);\n          } else {\n            logFn.apply(console, [d]);\n          }\n        });\n      } else {\n        logFn.apply(console, [data]);\n      }\n\n      console.groupEnd();\n    } else {\n      console.error('Missing title or data props');\n    }\n  }\n  /* eslint-enable */\n\n}\n\nvar defaultState = {\n  action: '',\n  controlled: false,\n  index: 0,\n  lifecycle: LIFECYCLE.INIT,\n  size: 0,\n  status: STATUS.IDLE\n};\nvar validKeys = ['action', 'index', 'lifecycle', 'status'];\nfunction createStore(props) {\n  var store = new Map();\n  var data = new Map();\n\n  var Store = /*#__PURE__*/function () {\n    function Store() {\n      var _this = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$continuous = _ref.continuous,\n          continuous = _ref$continuous === void 0 ? false : _ref$continuous,\n          stepIndex = _ref.stepIndex,\n          _ref$steps = _ref.steps,\n          _steps = _ref$steps === void 0 ? [] : _ref$steps;\n\n      _classCallCheck(this, Store);\n\n      _defineProperty(this, \"listener\", void 0);\n\n      _defineProperty(this, \"setSteps\", function (steps) {\n        var _this$getState = _this.getState(),\n            size = _this$getState.size,\n            status = _this$getState.status;\n\n        var state = {\n          size: steps.length,\n          status: status\n        };\n        data.set('steps', steps);\n\n        if (status === STATUS.WAITING && !size && steps.length) {\n          state.status = STATUS.RUNNING;\n        }\n\n        _this.setState(state);\n      });\n\n      _defineProperty(this, \"addListener\", function (listener) {\n        _this.listener = listener;\n      });\n\n      _defineProperty(this, \"update\", function (state) {\n        if (!hasValidKeys(state, validKeys)) {\n          throw new Error(\"State is not valid. Valid keys: \".concat(validKeys.join(', ')));\n        }\n\n        _this.setState(_objectSpread2({}, _this.getNextState(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.getState()), state), {}, {\n          action: state.action || ACTIONS.UPDATE\n        }), true)));\n      });\n\n      _defineProperty(this, \"start\", function (nextIndex) {\n        var _this$getState2 = _this.getState(),\n            index = _this$getState2.index,\n            size = _this$getState2.size;\n\n        _this.setState(_objectSpread2(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.START,\n          index: src_default.number(nextIndex) ? nextIndex : index\n        }, true)), {}, {\n          status: size ? STATUS.RUNNING : STATUS.WAITING\n        }));\n      });\n\n      _defineProperty(this, \"stop\", function () {\n        var advance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        var _this$getState3 = _this.getState(),\n            index = _this$getState3.index,\n            status = _this$getState3.status;\n\n        if ([STATUS.FINISHED, STATUS.SKIPPED].indexOf(status) !== -1) return;\n\n        _this.setState(_objectSpread2(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.STOP,\n          index: index + (advance ? 1 : 0)\n        })), {}, {\n          status: STATUS.PAUSED\n        }));\n      });\n\n      _defineProperty(this, \"close\", function () {\n        var _this$getState4 = _this.getState(),\n            index = _this$getState4.index,\n            status = _this$getState4.status;\n\n        if (status !== STATUS.RUNNING) return;\n\n        _this.setState(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.CLOSE,\n          index: index + 1\n        })));\n      });\n\n      _defineProperty(this, \"go\", function (nextIndex) {\n        var _this$getState5 = _this.getState(),\n            controlled = _this$getState5.controlled,\n            status = _this$getState5.status;\n\n        if (controlled || status !== STATUS.RUNNING) return;\n\n        var step = _this.getSteps()[nextIndex];\n\n        _this.setState(_objectSpread2(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.GO,\n          index: nextIndex\n        })), {}, {\n          status: step ? status : STATUS.FINISHED\n        }));\n      });\n\n      _defineProperty(this, \"info\", function () {\n        return _this.getState();\n      });\n\n      _defineProperty(this, \"next\", function () {\n        var _this$getState6 = _this.getState(),\n            index = _this$getState6.index,\n            status = _this$getState6.status;\n\n        if (status !== STATUS.RUNNING) return;\n\n        _this.setState(_this.getNextState({\n          action: ACTIONS.NEXT,\n          index: index + 1\n        }));\n      });\n\n      _defineProperty(this, \"open\", function () {\n        var _this$getState7 = _this.getState(),\n            status = _this$getState7.status;\n\n        if (status !== STATUS.RUNNING) return;\n\n        _this.setState(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.UPDATE,\n          lifecycle: LIFECYCLE.TOOLTIP\n        })));\n      });\n\n      _defineProperty(this, \"prev\", function () {\n        var _this$getState8 = _this.getState(),\n            index = _this$getState8.index,\n            status = _this$getState8.status;\n\n        if (status !== STATUS.RUNNING) return;\n\n        _this.setState(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.PREV,\n          index: index - 1\n        })));\n      });\n\n      _defineProperty(this, \"reset\", function () {\n        var restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        var _this$getState9 = _this.getState(),\n            controlled = _this$getState9.controlled;\n\n        if (controlled) return;\n\n        _this.setState(_objectSpread2(_objectSpread2({}, _this.getNextState({\n          action: ACTIONS.RESET,\n          index: 0\n        })), {}, {\n          status: restart ? STATUS.RUNNING : STATUS.READY\n        }));\n      });\n\n      _defineProperty(this, \"skip\", function () {\n        var _this$getState10 = _this.getState(),\n            status = _this$getState10.status;\n\n        if (status !== STATUS.RUNNING) return;\n\n        _this.setState({\n          action: ACTIONS.SKIP,\n          lifecycle: LIFECYCLE.INIT,\n          status: STATUS.SKIPPED\n        });\n      });\n\n      this.setState({\n        action: ACTIONS.INIT,\n        controlled: src_default.number(stepIndex),\n        continuous: continuous,\n        index: src_default.number(stepIndex) ? stepIndex : 0,\n        lifecycle: LIFECYCLE.INIT,\n        status: _steps.length ? STATUS.READY : STATUS.IDLE\n      }, true);\n      this.setSteps(_steps);\n    }\n\n    _createClass(Store, [{\n      key: \"setState\",\n      value: function setState(nextState) {\n        var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var state = this.getState();\n\n        var _state$nextState = _objectSpread2(_objectSpread2({}, state), nextState),\n            action = _state$nextState.action,\n            index = _state$nextState.index,\n            lifecycle = _state$nextState.lifecycle,\n            size = _state$nextState.size,\n            status = _state$nextState.status;\n\n        store.set('action', action);\n        store.set('index', index);\n        store.set('lifecycle', lifecycle);\n        store.set('size', size);\n        store.set('status', status);\n\n        if (initial) {\n          store.set('controlled', nextState.controlled);\n          store.set('continuous', nextState.continuous);\n        }\n        /* istanbul ignore else */\n\n\n        if (this.listener && this.hasUpdatedState(state)) {\n          // console.log('▶ ▶ ▶ NEW STATE', this.getState());\n          this.listener(this.getState());\n        }\n      }\n    }, {\n      key: \"getState\",\n      value: function getState() {\n        if (!store.size) {\n          return _objectSpread2({}, defaultState);\n        }\n\n        return {\n          action: store.get('action') || '',\n          controlled: store.get('controlled') || false,\n          index: parseInt(store.get('index'), 10),\n          lifecycle: store.get('lifecycle') || '',\n          size: store.get('size') || 0,\n          status: store.get('status') || ''\n        };\n      }\n    }, {\n      key: \"getNextState\",\n      value: function getNextState(state) {\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var _this$getState11 = this.getState(),\n            action = _this$getState11.action,\n            controlled = _this$getState11.controlled,\n            index = _this$getState11.index,\n            size = _this$getState11.size,\n            status = _this$getState11.status;\n\n        var newIndex = src_default.number(state.index) ? state.index : index;\n        var nextIndex = controlled && !force ? index : Math.min(Math.max(newIndex, 0), size);\n        return {\n          action: state.action || action,\n          controlled: controlled,\n          index: nextIndex,\n          lifecycle: state.lifecycle || LIFECYCLE.INIT,\n          size: state.size || size,\n          status: nextIndex === size ? STATUS.FINISHED : state.status || status\n        };\n      }\n    }, {\n      key: \"hasUpdatedState\",\n      value: function hasUpdatedState(oldState) {\n        var before = JSON.stringify(oldState);\n        var after = JSON.stringify(this.getState());\n        return before !== after;\n      }\n    }, {\n      key: \"getSteps\",\n      value: function getSteps() {\n        var steps = data.get('steps');\n        return Array.isArray(steps) ? steps : [];\n      }\n    }, {\n      key: \"getHelpers\",\n      value: function getHelpers() {\n        return {\n          close: this.close,\n          go: this.go,\n          info: this.info,\n          next: this.next,\n          open: this.open,\n          prev: this.prev,\n          reset: this.reset,\n          skip: this.skip\n        };\n      }\n    }]);\n\n    return Store;\n  }();\n\n  return new Store(props);\n}\n\n/**\n * Find the bounding client rect\n *\n * @private\n * @param {HTMLElement} element - The target element\n * @returns {Object}\n */\n\nfunction getClientRect(element) {\n  if (!element) {\n    return {};\n  }\n\n  return element.getBoundingClientRect();\n}\n/**\n * Helper function to get the browser-normalized \"document height\"\n * @returns {Number}\n */\n\nfunction getDocumentHeight() {\n  var _document = document,\n      body = _document.body,\n      html = _document.documentElement;\n\n  if (!body || !html) {\n    return 0;\n  }\n\n  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n}\n/**\n * Find and return the target DOM element based on a step's 'target'.\n *\n * @private\n * @param {string|HTMLElement} element\n *\n * @returns {HTMLElement|null}\n */\n\nfunction getElement(element) {\n  /* istanbul ignore else */\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  return element;\n}\n/**\n *  Get computed style property\n *\n * @param {HTMLElement} el\n *\n * @returns {Object}\n */\n\nfunction getStyleComputedProperty(el) {\n  if (!el || el.nodeType !== 1) {\n    return {};\n  }\n\n  return getComputedStyle(el);\n}\n/**\n * Get scroll parent with fix\n *\n * @param {HTMLElement} element\n * @param {boolean} skipFix\n * @param {boolean} [forListener]\n *\n * @returns {*}\n */\n\nfunction getScrollParent(element, skipFix, forListener) {\n  var parent = scrollparent_default()(element);\n\n  if (parent.isSameNode(scrollDoc())) {\n    if (forListener) {\n      return document;\n    }\n\n    return scrollDoc();\n  }\n\n  var hasScrolling = parent.scrollHeight > parent.offsetHeight;\n  /* istanbul ignore else */\n\n  if (!hasScrolling && !skipFix) {\n    parent.style.overflow = 'initial';\n    return scrollDoc();\n  }\n\n  return parent;\n}\n/**\n * Check if the element has custom scroll parent\n *\n * @param {HTMLElement} element\n * @param {boolean} skipFix\n *\n * @returns {boolean}\n */\n\nfunction hasCustomScrollParent(element, skipFix) {\n  if (!element) return false;\n  var parent = getScrollParent(element, skipFix);\n  return !parent.isSameNode(scrollDoc());\n}\n/**\n * Check if the element has custom offset parent\n *\n * @param {HTMLElement} element\n *\n * @returns {boolean}\n */\n\nfunction hasCustomOffsetParent(element) {\n  return element.offsetParent !== document.body;\n}\n/**\n * Check if an element has fixed/sticky position\n * @param {HTMLElement|Node} el\n * @param {string} [type]\n *\n * @returns {boolean}\n */\n\nfunction hasPosition(el) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fixed';\n\n  if (!el || !(el instanceof HTMLElement)) {\n    return false;\n  }\n\n  var nodeName = el.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(el).position === type) {\n    return true;\n  }\n\n  return hasPosition(el.parentNode, type);\n}\n/**\n * Check if the element is visible\n *\n * @param {HTMLElement} element\n *\n * @returns {boolean}\n */\n\nfunction isElementVisible(element) {\n  if (!element) return false;\n  var parentElement = element;\n\n  while (parentElement) {\n    if (parentElement === document.body) break;\n    /* istanbul ignore else */\n\n    if (parentElement instanceof HTMLElement) {\n      var _getComputedStyle = getComputedStyle(parentElement),\n          display = _getComputedStyle.display,\n          visibility = _getComputedStyle.visibility;\n\n      if (display === 'none' || visibility === 'hidden') {\n        return false;\n      }\n    }\n\n    parentElement = parentElement.parentNode;\n  }\n\n  return true;\n}\n/**\n * Find and return the target DOM element based on a step's 'target'.\n *\n * @private\n * @param {string|HTMLElement} element\n * @param {number} offset\n * @param {boolean} skipFix\n *\n * @returns {HTMLElement|undefined}\n */\n\nfunction getElementPosition(element, offset, skipFix) {\n  var elementRect = getClientRect(element);\n  var parent = getScrollParent(element, skipFix);\n  var hasScrollParent = hasCustomScrollParent(element, skipFix);\n  var parentTop = 0;\n  /* istanbul ignore else */\n\n  if (parent instanceof HTMLElement) {\n    parentTop = parent.scrollTop;\n  }\n\n  var top = elementRect.top + (!hasScrollParent && !hasPosition(element) ? parentTop : 0);\n  return Math.floor(top - offset);\n}\n/**\n * Get the offsetTop of each element up to the body\n *\n * @param {HTMLElement} element\n *\n * @returns {number}\n */\n\nfunction getTopOffset(element) {\n  if (element instanceof HTMLElement) {\n    if (element.offsetParent instanceof HTMLElement) {\n      return getTopOffset(element.offsetParent) + element.offsetTop;\n    }\n\n    return element.offsetTop;\n  }\n\n  return 0;\n}\n/**\n * Get the scrollTop position\n *\n * @param {HTMLElement} element\n * @param {number} offset\n * @param {boolean} skipFix\n *\n * @returns {number}\n */\n\nfunction getScrollTo(element, offset, skipFix) {\n  if (!element) {\n    return 0;\n  }\n\n  var parent = scrollparent_default()(element);\n  var top = getTopOffset(element);\n\n  if (hasCustomScrollParent(element, skipFix) && !hasCustomOffsetParent(element)) {\n    top -= getTopOffset(parent);\n  }\n\n  return Math.floor(top - offset);\n}\nfunction scrollDoc() {\n  return document.scrollingElement || document.createElement('body');\n}\n/**\n * Scroll to position\n * @param {number} value\n * @param {HTMLElement} element\n * @param {number} scrollDuration\n * @returns {Promise<*>}\n */\n\nfunction scrollTo(value) {\n  var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scrollDoc();\n  var scrollDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n  return new Promise(function (resolve, reject) {\n    var scrollTop = element.scrollTop;\n    var limit = value > scrollTop ? value - scrollTop : scrollTop - value;\n    scroll_default().top(element, value, {\n      duration: limit < 100 ? 50 : scrollDuration\n    }, function (error) {\n      if (error && error.message !== 'Element already at target scroll position') {\n        return reject(error);\n      }\n\n      return resolve();\n    });\n  });\n}\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    var componentNameSafe = componentName || '<<anonymous>>';\n    var propFullNameSafe = propFullName || propName;\n    /* istanbul ignore else */\n\n    if (props[propName] == null) {\n      if (isRequired) {\n        return new Error(\"Required \".concat(location, \" `\").concat(propFullNameSafe, \"` was not specified in `\").concat(componentNameSafe, \"`.\"));\n      }\n\n      return null;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n      args[_key - 6] = arguments[_key];\n    }\n\n    return validate.apply(void 0, [props, propName, componentNameSafe, location, propFullNameSafe].concat(args));\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n}\n\ncreateChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n  var propValue = props[propName];\n  var Component = propValue;\n\n  if (! /*#__PURE__*/react.isValidElement(propValue) && (0,react_is.isValidElementType)(propValue)) {\n    var ownProps = {\n      ref: function ref() {},\n      step: {}\n    };\n    Component = /*#__PURE__*/react.createElement(Component, ownProps);\n  }\n\n  if (src_default.string(propValue) || src_default.number(propValue) || !(0,react_is.isValidElementType)(propValue) || !([react_is.Element, react_is.ForwardRef].indexOf((0,react_is.typeOf)(Component)) !== -1)) {\n    return new Error(\"Invalid \".concat(location, \" `\").concat(propFullName, \"` supplied to `\").concat(componentName, \"`. Expected a React class or forwardRef.\"));\n  }\n\n  return undefined;\n});\n\nvar defaultOptions = {\n  arrowColor: '#fff',\n  backgroundColor: '#fff',\n  beaconSize: 36,\n  overlayColor: 'rgba(0, 0, 0, 0.5)',\n  primaryColor: '#f04',\n  spotlightShadow: '0 0 15px rgba(0, 0, 0, 0.5)',\n  textColor: '#333',\n  zIndex: 100\n};\nvar buttonBase = {\n  backgroundColor: 'transparent',\n  border: 0,\n  borderRadius: 0,\n  color: '#555',\n  cursor: 'pointer',\n  fontSize: 16,\n  lineHeight: 1,\n  padding: 8,\n  WebkitAppearance: 'none'\n};\nvar spotlight = {\n  borderRadius: 4,\n  position: 'absolute'\n};\nfunction getStyles() {\n  var stepStyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = cjs_default()(defaultOptions, stepStyles.options || {});\n  var width = 290;\n\n  if (window.innerWidth > 480) {\n    width = 380;\n  }\n\n  if (options.width) {\n    if (window.innerWidth < options.width) {\n      width = window.innerWidth - 30;\n    } else {\n      width = options.width; //eslint-disable-line prefer-destructuring\n    }\n  }\n\n  var overlay = {\n    bottom: 0,\n    left: 0,\n    overflow: 'hidden',\n    position: 'absolute',\n    right: 0,\n    top: 0,\n    zIndex: options.zIndex\n  };\n  var defaultStyles = {\n    beacon: _objectSpread2(_objectSpread2({}, buttonBase), {}, {\n      display: 'inline-block',\n      height: options.beaconSize,\n      position: 'relative',\n      width: options.beaconSize,\n      zIndex: options.zIndex\n    }),\n    beaconInner: {\n      animation: 'joyride-beacon-inner 1.2s infinite ease-in-out',\n      backgroundColor: options.primaryColor,\n      borderRadius: '50%',\n      display: 'block',\n      height: '50%',\n      left: '50%',\n      opacity: 0.7,\n      position: 'absolute',\n      top: '50%',\n      transform: 'translate(-50%, -50%)',\n      width: '50%'\n    },\n    beaconOuter: {\n      animation: 'joyride-beacon-outer 1.2s infinite ease-in-out',\n      backgroundColor: \"rgba(\".concat(hexToRGB(options.primaryColor).join(','), \", 0.2)\"),\n      border: \"2px solid \".concat(options.primaryColor),\n      borderRadius: '50%',\n      boxSizing: 'border-box',\n      display: 'block',\n      height: '100%',\n      left: 0,\n      opacity: 0.9,\n      position: 'absolute',\n      top: 0,\n      transformOrigin: 'center',\n      width: '100%'\n    },\n    tooltip: {\n      backgroundColor: options.backgroundColor,\n      borderRadius: 5,\n      boxSizing: 'border-box',\n      color: options.textColor,\n      fontSize: 16,\n      maxWidth: '100%',\n      padding: 15,\n      position: 'relative',\n      width: width\n    },\n    tooltipContainer: {\n      lineHeight: 1.4,\n      textAlign: 'center'\n    },\n    tooltipTitle: {\n      fontSize: 18,\n      margin: 0\n    },\n    tooltipContent: {\n      padding: '20px 10px'\n    },\n    tooltipFooter: {\n      alignItems: 'center',\n      display: 'flex',\n      justifyContent: 'flex-end',\n      marginTop: 15\n    },\n    tooltipFooterSpacer: {\n      flex: 1\n    },\n    buttonNext: _objectSpread2(_objectSpread2({}, buttonBase), {}, {\n      backgroundColor: options.primaryColor,\n      borderRadius: 4,\n      color: '#fff'\n    }),\n    buttonBack: _objectSpread2(_objectSpread2({}, buttonBase), {}, {\n      color: options.primaryColor,\n      marginLeft: 'auto',\n      marginRight: 5\n    }),\n    buttonClose: _objectSpread2(_objectSpread2({}, buttonBase), {}, {\n      color: options.textColor,\n      height: 14,\n      padding: 15,\n      position: 'absolute',\n      right: 0,\n      top: 0,\n      width: 14\n    }),\n    buttonSkip: _objectSpread2(_objectSpread2({}, buttonBase), {}, {\n      color: options.textColor,\n      fontSize: 14\n    }),\n    overlay: _objectSpread2(_objectSpread2({}, overlay), {}, {\n      backgroundColor: options.overlayColor,\n      mixBlendMode: 'hard-light'\n    }),\n    overlayLegacy: _objectSpread2({}, overlay),\n    overlayLegacyCenter: _objectSpread2(_objectSpread2({}, overlay), {}, {\n      backgroundColor: options.overlayColor\n    }),\n    spotlight: _objectSpread2(_objectSpread2({}, spotlight), {}, {\n      backgroundColor: 'gray'\n    }),\n    spotlightLegacy: _objectSpread2(_objectSpread2({}, spotlight), {}, {\n      boxShadow: \"0 0 0 9999px \".concat(options.overlayColor, \", \").concat(options.spotlightShadow)\n    }),\n    floaterStyles: {\n      arrow: {\n        color: options.arrowColor\n      },\n      options: {\n        zIndex: options.zIndex + 100\n      }\n    },\n    options: options\n  };\n  return cjs_default()(defaultStyles, stepStyles);\n}\n\nvar DEFAULTS = {\n  floaterProps: {\n    options: {\n      preventOverflow: {\n        boundariesElement: 'scrollParent'\n      }\n    },\n    wrapperOptions: {\n      offset: -18,\n      position: true\n    }\n  },\n  locale: {\n    back: 'Back',\n    close: 'Close',\n    last: 'Last',\n    next: 'Next',\n    open: 'Open the dialog',\n    skip: 'Skip'\n  },\n  step: {\n    event: 'click',\n    placement: 'bottom',\n    offset: 10\n  }\n};\n\nfunction getTourProps(props) {\n  var sharedTourProps = ['beaconComponent', 'disableCloseOnEsc', 'disableOverlay', 'disableOverlayClose', 'disableScrolling', 'disableScrollParentFix', 'floaterProps', 'hideBackButton', 'hideCloseButton', 'locale', 'showProgress', 'showSkipButton', 'spotlightClicks', 'spotlightPadding', 'styles', 'tooltipComponent'];\n  return Object.keys(props).filter(function (d) {\n    return sharedTourProps.indexOf(d) !== -1;\n  }).reduce(function (acc, i) {\n    acc[i] = props[i]; //eslint-disable-line react/destructuring-assignment\n\n    return acc;\n  }, {});\n}\n\nfunction getMergedStep(step, props) {\n  if (!step) return null;\n  var mergedStep = cjs_default().all([getTourProps(props), DEFAULTS.step, step], {\n    isMergeableObject: src_default.plainObject\n  });\n  var mergedStyles = getStyles(cjs_default()(props.styles || {}, step.styles || {}));\n  var scrollParent = hasCustomScrollParent(getElement(step.target), mergedStep.disableScrollParentFix);\n  var floaterProps = cjs_default().all([props.floaterProps || {}, DEFAULTS.floaterProps, mergedStep.floaterProps || {}]); // Set react-floater props\n\n  floaterProps.offset = mergedStep.offset;\n  floaterProps.styles = cjs_default()(floaterProps.styles || {}, mergedStyles.floaterStyles || {});\n  delete mergedStyles.floaterStyles;\n  floaterProps.offset += props.spotlightPadding || step.spotlightPadding || 0;\n\n  if (step.placementBeacon) {\n    floaterProps.wrapperOptions.placement = step.placementBeacon;\n  }\n\n  if (scrollParent) {\n    floaterProps.options.preventOverflow.boundariesElement = 'window';\n  }\n\n  return _objectSpread2(_objectSpread2({}, mergedStep), {}, {\n    locale: cjs_default().all([DEFAULTS.locale, props.locale || {}, mergedStep.locale || {}]),\n    floaterProps: floaterProps,\n    styles: mergedStyles\n  });\n}\n/**\n * Validate if a step is valid\n *\n * @param {Object} step - A step object\n * @param {boolean} debug\n *\n * @returns {boolean} - True if the step is valid, false otherwise\n */\n\nfunction validateStep(step) {\n  var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!src_default.plainObject(step)) {\n    log({\n      title: 'validateStep',\n      data: 'step must be an object',\n      warn: true,\n      debug: debug\n    });\n    return false;\n  }\n\n  if (!step.target) {\n    log({\n      title: 'validateStep',\n      data: 'target is missing from the step',\n      warn: true,\n      debug: debug\n    });\n    return false;\n  }\n\n  return true;\n}\n/**\n * Validate if steps is valid\n *\n * @param {Array} steps - A steps array\n * @param {boolean} debug\n *\n * @returns {boolean} - True if the steps are valid, false otherwise\n */\n\nfunction validateSteps(steps) {\n  var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!src_default.array(steps)) {\n    log({\n      title: 'validateSteps',\n      data: 'steps must be an array',\n      warn: true,\n      debug: debug\n    });\n    return false;\n  }\n\n  return steps.every(function (d) {\n    return validateStep(d, debug);\n  });\n}\n\nvar Scope = /*#__PURE__*/_createClass(function Scope(_element) {\n  var _this = this;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  _classCallCheck(this, Scope);\n\n  _defineProperty(this, \"element\", void 0);\n\n  _defineProperty(this, \"options\", void 0);\n\n  _defineProperty(this, \"canBeTabbed\", function (element) {\n    var tabIndex = element.tabIndex;\n    if (tabIndex === null || tabIndex < 0) tabIndex = undefined;\n    var isTabIndexNaN = isNaN(tabIndex);\n    return !isTabIndexNaN && _this.canHaveFocus(element);\n  });\n\n  _defineProperty(this, \"canHaveFocus\", function (element) {\n    var validTabNodes = /input|select|textarea|button|object/;\n    var nodeName = element.nodeName.toLowerCase();\n    var res = validTabNodes.test(nodeName) && !element.getAttribute('disabled') || nodeName === 'a' && !!element.getAttribute('href');\n    return res && _this.isVisible(element);\n  });\n\n  _defineProperty(this, \"findValidTabElements\", function () {\n    return [].slice.call(_this.element.querySelectorAll('*'), 0).filter(_this.canBeTabbed);\n  });\n\n  _defineProperty(this, \"handleKeyDown\", function (e) {\n    var _this$options$keyCode = _this.options.keyCode,\n        keyCode = _this$options$keyCode === void 0 ? 9 : _this$options$keyCode;\n    /* istanbul ignore else */\n\n    if (e.keyCode === keyCode) {\n      _this.interceptTab(e);\n    }\n  });\n\n  _defineProperty(this, \"interceptTab\", function (event) {\n    var elements = _this.findValidTabElements();\n\n    if (!elements.length) {\n      return;\n    }\n\n    event.preventDefault();\n    var shiftKey = event.shiftKey;\n    var x = elements.indexOf(document.activeElement);\n\n    if (x === -1 || !shiftKey && x + 1 === elements.length) {\n      x = 0;\n    } else if (shiftKey && x === 0) {\n      x = elements.length - 1;\n    } else {\n      x += shiftKey ? -1 : 1;\n    }\n\n    elements[x].focus();\n  });\n\n  _defineProperty(this, \"isHidden\", function (element) {\n    var noSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n    var style = window.getComputedStyle(element);\n    if (noSize && !element.innerHTML) return true;\n    return noSize && style.getPropertyValue('overflow') !== 'visible' || style.getPropertyValue('display') === 'none';\n  });\n\n  _defineProperty(this, \"isVisible\", function (element) {\n    var parentElement = element;\n\n    while (parentElement) {\n      /* istanbul ignore else */\n      if (parentElement instanceof HTMLElement) {\n        if (parentElement === document.body) break;\n        /* istanbul ignore else */\n\n        if (_this.isHidden(parentElement)) return false;\n        parentElement = parentElement.parentNode;\n      }\n    }\n\n    return true;\n  });\n\n  _defineProperty(this, \"removeScope\", function () {\n    window.removeEventListener('keydown', _this.handleKeyDown);\n  });\n\n  _defineProperty(this, \"checkFocus\", function (target) {\n    if (document.activeElement !== target) {\n      target.focus();\n      window.requestAnimationFrame(function () {\n        return _this.checkFocus(target);\n      });\n    }\n  });\n\n  _defineProperty(this, \"setFocus\", function () {\n    var selector = _this.options.selector;\n    if (!selector) return;\n\n    var target = _this.element.querySelector(selector);\n    /* istanbul ignore else */\n\n\n    if (target) {\n      window.requestAnimationFrame(function () {\n        return _this.checkFocus(target);\n      });\n    }\n  });\n\n  if (!(_element instanceof HTMLElement)) {\n    throw new TypeError('Invalid parameter: element must be an HTMLElement');\n  }\n\n  this.element = _element;\n  this.options = options;\n  window.addEventListener('keydown', this.handleKeyDown, false);\n  this.setFocus();\n});\n\nvar JoyrideBeacon = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyrideBeacon, _React$Component);\n\n  var _super = _createSuper(JoyrideBeacon);\n\n  function JoyrideBeacon(props) {\n    var _this;\n\n    _classCallCheck(this, JoyrideBeacon);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"setBeaconRef\", function (c) {\n      _this.beacon = c;\n    });\n\n    if (!props.beaconComponent) {\n      var head = document.head || document.getElementsByTagName('head')[0];\n      var style = document.createElement('style');\n      var css = \"\\n        @keyframes joyride-beacon-inner {\\n          20% {\\n            opacity: 0.9;\\n          }\\n        \\n          90% {\\n            opacity: 0.7;\\n          }\\n        }\\n        \\n        @keyframes joyride-beacon-outer {\\n          0% {\\n            transform: scale(1);\\n          }\\n        \\n          45% {\\n            opacity: 0.7;\\n            transform: scale(0.75);\\n          }\\n        \\n          100% {\\n            opacity: 0.9;\\n            transform: scale(1);\\n          }\\n        }\\n      \";\n      style.type = 'text/css';\n      style.id = 'joyride-beacon-animation';\n\n      if (props.nonce !== undefined) {\n        style.setAttribute('nonce', props.nonce);\n      }\n\n      style.appendChild(document.createTextNode(css));\n      head.appendChild(style);\n    }\n\n    return _this;\n  }\n\n  _createClass(JoyrideBeacon, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var shouldFocus = this.props.shouldFocus;\n\n      setTimeout(function () {\n        if (src_default.domElement(_this2.beacon) && shouldFocus) {\n          _this2.beacon.focus();\n        }\n      }, 0);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var style = document.getElementById('joyride-beacon-animation');\n\n      if (style) {\n        style.parentNode.removeChild(style);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          beaconComponent = _this$props.beaconComponent,\n          locale = _this$props.locale,\n          onClickOrHover = _this$props.onClickOrHover,\n          styles = _this$props.styles;\n      var props = {\n        'aria-label': locale.open,\n        onClick: onClickOrHover,\n        onMouseEnter: onClickOrHover,\n        ref: this.setBeaconRef,\n        title: locale.open\n      };\n      var component;\n\n      if (beaconComponent) {\n        var BeaconComponent = beaconComponent;\n        component = /*#__PURE__*/react.createElement(BeaconComponent, props);\n      } else {\n        component = /*#__PURE__*/react.createElement(\"button\", _extends({\n          key: \"JoyrideBeacon\",\n          className: \"react-joyride__beacon\",\n          style: styles.beacon,\n          type: \"button\"\n        }, props), /*#__PURE__*/react.createElement(\"span\", {\n          style: styles.beaconInner\n        }), /*#__PURE__*/react.createElement(\"span\", {\n          style: styles.beaconOuter\n        }));\n      }\n\n      return component;\n    }\n  }]);\n\n  return JoyrideBeacon;\n}(react.Component);\n\nfunction JoyrideSpotlight(_ref) {\n  var styles = _ref.styles;\n  return /*#__PURE__*/react.createElement(\"div\", {\n    key: \"JoyrideSpotlight\",\n    className: \"react-joyride__spotlight\",\n    style: styles\n  });\n}\n\nvar _excluded$2 = [\"mixBlendMode\", \"zIndex\"];\n\nvar JoyrideOverlay = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyrideOverlay, _React$Component);\n\n  var _super = _createSuper(JoyrideOverlay);\n\n  function JoyrideOverlay() {\n    var _this;\n\n    _classCallCheck(this, JoyrideOverlay);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_isMounted\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      mouseOverSpotlight: false,\n      isScrolling: false,\n      showSpotlight: true\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseMove\", function (e) {\n      var mouseOverSpotlight = _this.state.mouseOverSpotlight;\n      var _this$spotlightStyles = _this.spotlightStyles,\n          height = _this$spotlightStyles.height,\n          left = _this$spotlightStyles.left,\n          position = _this$spotlightStyles.position,\n          top = _this$spotlightStyles.top,\n          width = _this$spotlightStyles.width;\n      var offsetY = position === 'fixed' ? e.clientY : e.pageY;\n      var offsetX = position === 'fixed' ? e.clientX : e.pageX;\n      var inSpotlightHeight = offsetY >= top && offsetY <= top + height;\n      var inSpotlightWidth = offsetX >= left && offsetX <= left + width;\n      var inSpotlight = inSpotlightWidth && inSpotlightHeight;\n\n      if (inSpotlight !== mouseOverSpotlight) {\n        _this.updateState({\n          mouseOverSpotlight: inSpotlight\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleScroll\", function () {\n      var target = _this.props.target;\n      var element = getElement(target);\n\n      if (_this.scrollParent !== document) {\n        var isScrolling = _this.state.isScrolling;\n\n        if (!isScrolling) {\n          _this.updateState({\n            isScrolling: true,\n            showSpotlight: false\n          });\n        }\n\n        clearTimeout(_this.scrollTimeout);\n        _this.scrollTimeout = setTimeout(function () {\n          _this.updateState({\n            isScrolling: false,\n            showSpotlight: true\n          });\n        }, 50);\n      } else if (hasPosition(element, 'sticky')) {\n        _this.updateState({});\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleResize\", function () {\n      clearTimeout(_this.resizeTimeout);\n      _this.resizeTimeout = setTimeout(function () {\n        if (!_this._isMounted) {\n          return;\n        }\n\n        _this.forceUpdate();\n      }, 100);\n    });\n\n    return _this;\n  }\n\n  _createClass(JoyrideOverlay, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props;\n          _this$props.debug;\n          _this$props.disableScrolling;\n          var disableScrollParentFix = _this$props.disableScrollParentFix,\n          target = _this$props.target;\n      var element = getElement(target);\n      this.scrollParent = getScrollParent(element, disableScrollParentFix, true);\n      this._isMounted = true;\n\n      window.addEventListener('resize', this.handleResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          lifecycle = _this$props2.lifecycle,\n          spotlightClicks = _this$props2.spotlightClicks;\n\n      var _treeChanges = (0,esm/* default */.Z)(prevProps, this.props),\n          changed = _treeChanges.changed;\n      /* istanbul ignore else */\n\n\n      if (changed('lifecycle', LIFECYCLE.TOOLTIP)) {\n        this.scrollParent.addEventListener('scroll', this.handleScroll, {\n          passive: true\n        });\n        setTimeout(function () {\n          var isScrolling = _this2.state.isScrolling;\n\n          if (!isScrolling) {\n            _this2.updateState({\n              showSpotlight: true\n            });\n          }\n        }, 100);\n      }\n\n      if (changed('spotlightClicks') || changed('disableOverlay') || changed('lifecycle')) {\n        if (spotlightClicks && lifecycle === LIFECYCLE.TOOLTIP) {\n          window.addEventListener('mousemove', this.handleMouseMove, false);\n        } else if (lifecycle !== LIFECYCLE.TOOLTIP) {\n          window.removeEventListener('mousemove', this.handleMouseMove);\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n      window.removeEventListener('mousemove', this.handleMouseMove);\n      window.removeEventListener('resize', this.handleResize);\n      clearTimeout(this.resizeTimeout);\n      clearTimeout(this.scrollTimeout);\n      this.scrollParent.removeEventListener('scroll', this.handleScroll);\n    }\n  }, {\n    key: \"spotlightStyles\",\n    get: function get() {\n      var showSpotlight = this.state.showSpotlight;\n      var _this$props3 = this.props,\n          disableScrollParentFix = _this$props3.disableScrollParentFix,\n          spotlightClicks = _this$props3.spotlightClicks,\n          spotlightPadding = _this$props3.spotlightPadding,\n          styles = _this$props3.styles,\n          target = _this$props3.target;\n      var element = getElement(target);\n      var elementRect = getClientRect(element);\n      var isFixedTarget = hasPosition(element);\n      var top = getElementPosition(element, spotlightPadding, disableScrollParentFix);\n      return _objectSpread2(_objectSpread2({}, isLegacy() ? styles.spotlightLegacy : styles.spotlight), {}, {\n        height: Math.round(elementRect.height + spotlightPadding * 2),\n        left: Math.round(elementRect.left - spotlightPadding),\n        opacity: showSpotlight ? 1 : 0,\n        pointerEvents: spotlightClicks ? 'none' : 'auto',\n        position: isFixedTarget ? 'fixed' : 'absolute',\n        top: top,\n        transition: 'opacity 0.2s',\n        width: Math.round(elementRect.width + spotlightPadding * 2)\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(state) {\n      if (!this._isMounted) {\n        return;\n      }\n\n      this.setState(state);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state = this.state,\n          mouseOverSpotlight = _this$state.mouseOverSpotlight,\n          showSpotlight = _this$state.showSpotlight;\n      var _this$props4 = this.props,\n          disableOverlay = _this$props4.disableOverlay,\n          disableOverlayClose = _this$props4.disableOverlayClose,\n          lifecycle = _this$props4.lifecycle,\n          onClickOverlay = _this$props4.onClickOverlay,\n          placement = _this$props4.placement,\n          styles = _this$props4.styles;\n\n      if (disableOverlay || lifecycle !== LIFECYCLE.TOOLTIP) {\n        return null;\n      }\n\n      var baseStyles = styles.overlay;\n      /* istanbul ignore else */\n\n      if (isLegacy()) {\n        baseStyles = placement === 'center' ? styles.overlayLegacyCenter : styles.overlayLegacy;\n      }\n\n      var stylesOverlay = _objectSpread2({\n        cursor: disableOverlayClose ? 'default' : 'pointer',\n        height: getDocumentHeight(),\n        pointerEvents: mouseOverSpotlight ? 'none' : 'auto'\n      }, baseStyles);\n\n      var spotlight = placement !== 'center' && showSpotlight && /*#__PURE__*/react.createElement(JoyrideSpotlight, {\n        styles: this.spotlightStyles\n      }); // Hack for Safari bug with mix-blend-mode with z-index\n\n      if (getBrowser() === 'safari') {\n        stylesOverlay.mixBlendMode;\n            stylesOverlay.zIndex;\n            var safarOverlay = _objectWithoutProperties(stylesOverlay, _excluded$2);\n\n        spotlight = /*#__PURE__*/react.createElement(\"div\", {\n          style: _objectSpread2({}, safarOverlay)\n        }, spotlight);\n        delete stylesOverlay.backgroundColor;\n      }\n\n      return /*#__PURE__*/react.createElement(\"div\", {\n        className: \"react-joyride__overlay\",\n        style: stylesOverlay,\n        onClick: onClickOverlay\n      }, spotlight);\n    }\n  }]);\n\n  return JoyrideOverlay;\n}(react.Component);\n\nvar _excluded$1 = [\"styles\"],\n    _excluded2 = [\"color\", \"height\", \"width\"];\n\nfunction JoyrideTooltipCloseBtn(_ref) {\n  var styles = _ref.styles,\n      props = _objectWithoutProperties(_ref, _excluded$1);\n\n  var color = styles.color,\n      height = styles.height,\n      width = styles.width,\n      style = _objectWithoutProperties(styles, _excluded2);\n\n  return /*#__PURE__*/react.createElement(\"button\", _extends({\n    style: style,\n    type: \"button\"\n  }, props), /*#__PURE__*/react.createElement(\"svg\", {\n    width: typeof width === 'number' ? \"\".concat(width, \"px\") : width,\n    height: typeof height === 'number' ? \"\".concat(height, \"px\") : height,\n    viewBox: \"0 0 18 18\",\n    version: \"1.1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    preserveAspectRatio: \"xMidYMid\"\n  }, /*#__PURE__*/react.createElement(\"g\", null, /*#__PURE__*/react.createElement(\"path\", {\n    d: \"M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z\",\n    fill: color\n  }))));\n}\n\nvar JoyrideTooltipContainer = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyrideTooltipContainer, _React$Component);\n\n  var _super = _createSuper(JoyrideTooltipContainer);\n\n  function JoyrideTooltipContainer() {\n    _classCallCheck(this, JoyrideTooltipContainer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(JoyrideTooltipContainer, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          backProps = _this$props.backProps,\n          closeProps = _this$props.closeProps,\n          continuous = _this$props.continuous,\n          index = _this$props.index,\n          isLastStep = _this$props.isLastStep,\n          primaryProps = _this$props.primaryProps,\n          size = _this$props.size,\n          skipProps = _this$props.skipProps,\n          step = _this$props.step,\n          tooltipProps = _this$props.tooltipProps;\n      var content = step.content,\n          hideBackButton = step.hideBackButton,\n          hideCloseButton = step.hideCloseButton,\n          hideFooter = step.hideFooter,\n          showProgress = step.showProgress,\n          showSkipButton = step.showSkipButton,\n          title = step.title,\n          styles = step.styles;\n      var _step$locale = step.locale,\n          back = _step$locale.back,\n          close = _step$locale.close,\n          last = _step$locale.last,\n          next = _step$locale.next,\n          skip = _step$locale.skip;\n      var output = {\n        primary: close\n      };\n\n      if (continuous) {\n        output.primary = isLastStep ? last : next;\n\n        if (showProgress) {\n          output.primary = /*#__PURE__*/react.createElement(\"span\", null, output.primary, \" (\", index + 1, \"/\", size, \")\");\n        }\n      }\n\n      if (showSkipButton && !isLastStep) {\n        output.skip = /*#__PURE__*/react.createElement(\"button\", _extends({\n          style: styles.buttonSkip,\n          type: \"button\",\n          \"aria-live\": \"off\"\n        }, skipProps), skip);\n      }\n\n      if (!hideBackButton && index > 0) {\n        output.back = /*#__PURE__*/react.createElement(\"button\", _extends({\n          style: styles.buttonBack,\n          type: \"button\"\n        }, backProps), back);\n      }\n\n      output.close = !hideCloseButton && /*#__PURE__*/react.createElement(JoyrideTooltipCloseBtn, _extends({\n        styles: styles.buttonClose\n      }, closeProps));\n      return /*#__PURE__*/react.createElement(\"div\", _extends({\n        key: \"JoyrideTooltip\",\n        className: \"react-joyride__tooltip\",\n        style: styles.tooltip\n      }, tooltipProps), /*#__PURE__*/react.createElement(\"div\", {\n        style: styles.tooltipContainer\n      }, title && /*#__PURE__*/react.createElement(\"h4\", {\n        style: styles.tooltipTitle,\n        \"aria-label\": title\n      }, title), /*#__PURE__*/react.createElement(\"div\", {\n        style: styles.tooltipContent\n      }, content)), !hideFooter && /*#__PURE__*/react.createElement(\"div\", {\n        style: styles.tooltipFooter\n      }, /*#__PURE__*/react.createElement(\"div\", {\n        style: styles.tooltipFooterSpacer\n      }, output.skip), output.back, /*#__PURE__*/react.createElement(\"button\", _extends({\n        style: styles.buttonNext,\n        type: \"button\"\n      }, primaryProps), output.primary)), output.close);\n    }\n  }]);\n\n  return JoyrideTooltipContainer;\n}(react.Component);\n\nvar _excluded = [\"beaconComponent\", \"tooltipComponent\"];\n\nvar JoyrideTooltip = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyrideTooltip, _React$Component);\n\n  var _super = _createSuper(JoyrideTooltip);\n\n  function JoyrideTooltip() {\n    var _this;\n\n    _classCallCheck(this, JoyrideTooltip);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickBack\", function (e) {\n      e.preventDefault();\n      var helpers = _this.props.helpers;\n      helpers.prev();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickClose\", function (e) {\n      e.preventDefault();\n      var helpers = _this.props.helpers;\n      helpers.close();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickPrimary\", function (e) {\n      e.preventDefault();\n      var _this$props = _this.props,\n          continuous = _this$props.continuous,\n          helpers = _this$props.helpers;\n\n      if (!continuous) {\n        helpers.close();\n        return;\n      }\n\n      helpers.next();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickSkip\", function (e) {\n      e.preventDefault();\n      var helpers = _this.props.helpers;\n      helpers.skip();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getElementsProps\", function () {\n      var _this$props2 = _this.props,\n          continuous = _this$props2.continuous,\n          isLastStep = _this$props2.isLastStep,\n          setTooltipRef = _this$props2.setTooltipRef,\n          step = _this$props2.step;\n      var back = getText(step.locale.back);\n      var close = getText(step.locale.close);\n      var last = getText(step.locale.last);\n      var next = getText(step.locale.next);\n      var skip = getText(step.locale.skip);\n      var primaryText = continuous ? next : close;\n\n      if (isLastStep) {\n        primaryText = last;\n      }\n\n      return {\n        backProps: {\n          'aria-label': back,\n          'data-action': 'back',\n          onClick: _this.handleClickBack,\n          role: 'button',\n          title: back\n        },\n        closeProps: {\n          'aria-label': close,\n          'data-action': 'close',\n          onClick: _this.handleClickClose,\n          role: 'button',\n          title: close\n        },\n        primaryProps: {\n          'aria-label': primaryText,\n          'data-action': 'primary',\n          onClick: _this.handleClickPrimary,\n          role: 'button',\n          title: primaryText\n        },\n        skipProps: {\n          'aria-label': skip,\n          'data-action': 'skip',\n          onClick: _this.handleClickSkip,\n          role: 'button',\n          title: skip\n        },\n        tooltipProps: {\n          'aria-modal': true,\n          ref: setTooltipRef,\n          role: 'alertdialog'\n        }\n      };\n    });\n\n    return _this;\n  }\n\n  _createClass(JoyrideTooltip, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          continuous = _this$props3.continuous,\n          index = _this$props3.index,\n          isLastStep = _this$props3.isLastStep,\n          size = _this$props3.size,\n          step = _this$props3.step;\n\n      step.beaconComponent;\n          var tooltipComponent = step.tooltipComponent,\n          cleanStep = _objectWithoutProperties(step, _excluded);\n\n      var component;\n\n      if (tooltipComponent) {\n        var renderProps = _objectSpread2(_objectSpread2({}, this.getElementsProps()), {}, {\n          continuous: continuous,\n          index: index,\n          isLastStep: isLastStep,\n          size: size,\n          step: cleanStep\n        });\n\n        var TooltipComponent = tooltipComponent;\n        component = /*#__PURE__*/react.createElement(TooltipComponent, renderProps);\n      } else {\n        component = /*#__PURE__*/react.createElement(JoyrideTooltipContainer, _extends({}, this.getElementsProps(), {\n          continuous: continuous,\n          index: index,\n          isLastStep: isLastStep,\n          size: size,\n          step: step\n        }));\n      }\n\n      return component;\n    }\n  }]);\n\n  return JoyrideTooltip;\n}(react.Component);\n\nvar JoyridePortal = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyridePortal, _React$Component);\n\n  var _super = _createSuper(JoyridePortal);\n\n  function JoyridePortal() {\n    _classCallCheck(this, JoyridePortal);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(JoyridePortal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!canUseDOM) return;\n\n      if (!isReact16) {\n        this.renderReact15();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (!canUseDOM) return;\n\n      if (!isReact16) {\n        this.renderReact15();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!canUseDOM || !this.node) return;\n\n      if (!isReact16) {\n        react_dom.unmountComponentAtNode(this.node);\n      }\n\n      if (this.node.parentNode === document.body) {\n        document.body.removeChild(this.node);\n        this.node = undefined;\n      }\n    }\n  }, {\n    key: \"appendNode\",\n    value: function appendNode() {\n      var id = this.props.id;\n\n      if (!this.node) {\n        this.node = document.createElement('div');\n        /* istanbul ignore else */\n\n        if (id) {\n          this.node.id = id;\n        }\n\n        document.body.appendChild(this.node);\n      }\n    }\n  }, {\n    key: \"renderReact15\",\n    value: function renderReact15() {\n      if (!canUseDOM) return null;\n      var children = this.props.children;\n\n      if (!this.node) {\n        this.appendNode();\n      }\n\n      react_dom.unstable_renderSubtreeIntoContainer(this, children, this.node);\n      return null;\n    }\n  }, {\n    key: \"renderReact16\",\n    value: function renderReact16() {\n      if (!canUseDOM || !isReact16) return null;\n      var children = this.props.children;\n\n      if (!this.node) {\n        this.appendNode();\n      }\n\n      return /*#__PURE__*/react_dom.createPortal(children, this.node);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!isReact16) {\n        return null;\n      }\n\n      return this.renderReact16();\n    }\n  }]);\n\n  return JoyridePortal;\n}(react.Component);\n\nvar JoyrideStep = /*#__PURE__*/function (_React$Component) {\n  _inherits(JoyrideStep, _React$Component);\n\n  var _super = _createSuper(JoyrideStep);\n\n  function JoyrideStep() {\n    var _this;\n\n    _classCallCheck(this, JoyrideStep);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"scope\", {\n      removeScope: function removeScope() {}\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickHoverBeacon\", function (e) {\n      var _this$props = _this.props,\n          step = _this$props.step,\n          update = _this$props.update;\n\n      if (e.type === 'mouseenter' && step.event !== 'hover') {\n        return;\n      }\n\n      update({\n        lifecycle: LIFECYCLE.TOOLTIP\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickOverlay\", function () {\n      var _this$props2 = _this.props,\n          helpers = _this$props2.helpers,\n          step = _this$props2.step;\n\n      if (!step.disableOverlayClose) {\n        helpers.close();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setTooltipRef\", function (c) {\n      _this.tooltip = c;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setPopper\", function (popper, type) {\n      var _this$props3 = _this.props,\n          action = _this$props3.action,\n          setPopper = _this$props3.setPopper,\n          update = _this$props3.update;\n\n      if (type === 'wrapper') {\n        _this.beaconPopper = popper;\n      } else {\n        _this.tooltipPopper = popper;\n      }\n\n      setPopper(popper, type);\n\n      if (_this.beaconPopper && _this.tooltipPopper) {\n        update({\n          action: action === ACTIONS.CLOSE ? ACTIONS.CLOSE : action,\n          lifecycle: LIFECYCLE.READY\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(JoyrideStep, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          debug = _this$props4.debug,\n          index = _this$props4.index;\n      log({\n        title: \"step:\".concat(index),\n        data: [{\n          key: 'props',\n          value: this.props\n        }],\n        debug: debug\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props5 = this.props,\n          action = _this$props5.action,\n          callback = _this$props5.callback,\n          continuous = _this$props5.continuous,\n          controlled = _this$props5.controlled,\n          debug = _this$props5.debug,\n          index = _this$props5.index,\n          lifecycle = _this$props5.lifecycle,\n          size = _this$props5.size,\n          status = _this$props5.status,\n          step = _this$props5.step,\n          update = _this$props5.update;\n\n      var _treeChanges = (0,esm/* default */.Z)(prevProps, this.props),\n          changed = _treeChanges.changed,\n          changedFrom = _treeChanges.changedFrom;\n\n      var state = {\n        action: action,\n        controlled: controlled,\n        index: index,\n        lifecycle: lifecycle,\n        size: size,\n        status: status\n      };\n      var skipBeacon = continuous && action !== ACTIONS.CLOSE && (index > 0 || action === ACTIONS.PREV);\n      var hasStoreChanged = changed('action') || changed('index') || changed('lifecycle') || changed('status');\n      var hasStarted = changedFrom('lifecycle', [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT);\n      var isAfterAction = changed('action', [ACTIONS.NEXT, ACTIONS.PREV, ACTIONS.SKIP, ACTIONS.CLOSE]);\n\n      if (isAfterAction && (hasStarted || controlled)) {\n        callback(_objectSpread2(_objectSpread2({}, state), {}, {\n          index: prevProps.index,\n          lifecycle: LIFECYCLE.COMPLETE,\n          step: prevProps.step,\n          type: EVENTS.STEP_AFTER\n        }));\n      }\n\n      if (step.placement === 'center' && status === STATUS.RUNNING && changed('index') && action !== ACTIONS.START && lifecycle === LIFECYCLE.INIT) {\n        update({\n          lifecycle: LIFECYCLE.READY\n        });\n      } // There's a step to use, but there's no target in the DOM\n\n\n      if (hasStoreChanged) {\n        var element = getElement(step.target);\n        var elementExists = !!element;\n        var hasRenderedTarget = elementExists && isElementVisible(element);\n\n        if (hasRenderedTarget) {\n          if (changedFrom('status', STATUS.READY, STATUS.RUNNING) || changedFrom('lifecycle', LIFECYCLE.INIT, LIFECYCLE.READY)) {\n            callback(_objectSpread2(_objectSpread2({}, state), {}, {\n              step: step,\n              type: EVENTS.STEP_BEFORE\n            }));\n          }\n        } else {\n          console.warn(elementExists ? 'Target not visible' : 'Target not mounted', step); //eslint-disable-line no-console\n\n          callback(_objectSpread2(_objectSpread2({}, state), {}, {\n            type: EVENTS.TARGET_NOT_FOUND,\n            step: step\n          }));\n\n          if (!controlled) {\n            update({\n              index: index + ([ACTIONS.PREV].indexOf(action) !== -1 ? -1 : 1)\n            });\n          }\n        }\n      }\n\n      if (changedFrom('lifecycle', LIFECYCLE.INIT, LIFECYCLE.READY)) {\n        update({\n          lifecycle: hideBeacon(step) || skipBeacon ? LIFECYCLE.TOOLTIP : LIFECYCLE.BEACON\n        });\n      }\n\n      if (changed('index')) {\n        log({\n          title: \"step:\".concat(lifecycle),\n          data: [{\n            key: 'props',\n            value: this.props\n          }],\n          debug: debug\n        });\n      }\n      /* istanbul ignore else */\n\n\n      if (changed('lifecycle', LIFECYCLE.BEACON)) {\n        callback(_objectSpread2(_objectSpread2({}, state), {}, {\n          step: step,\n          type: EVENTS.BEACON\n        }));\n      }\n\n      if (changed('lifecycle', LIFECYCLE.TOOLTIP)) {\n        callback(_objectSpread2(_objectSpread2({}, state), {}, {\n          step: step,\n          type: EVENTS.TOOLTIP\n        }));\n        this.scope = new Scope(this.tooltip, {\n          selector: '[data-action=primary]'\n        });\n        this.scope.setFocus();\n      }\n\n      if (changedFrom('lifecycle', [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT)) {\n        this.scope.removeScope();\n        delete this.beaconPopper;\n        delete this.tooltipPopper;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.scope.removeScope();\n    }\n    /**\n     * Beacon click/hover event listener\n     *\n     * @param {Event} e\n     */\n\n  }, {\n    key: \"open\",\n    get: function get() {\n      var _this$props6 = this.props,\n          step = _this$props6.step,\n          lifecycle = _this$props6.lifecycle;\n      return !!(hideBeacon(step) || lifecycle === LIFECYCLE.TOOLTIP);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props7 = this.props,\n          continuous = _this$props7.continuous,\n          debug = _this$props7.debug,\n          helpers = _this$props7.helpers,\n          index = _this$props7.index,\n          lifecycle = _this$props7.lifecycle,\n          nonce = _this$props7.nonce,\n          shouldScroll = _this$props7.shouldScroll,\n          size = _this$props7.size,\n          step = _this$props7.step;\n      var target = getElement(step.target);\n\n      if (!validateStep(step) || !src_default.domElement(target)) {\n        return null;\n      }\n\n      return /*#__PURE__*/react.createElement(\"div\", {\n        key: \"JoyrideStep-\".concat(index),\n        className: \"react-joyride__step\"\n      }, /*#__PURE__*/react.createElement(JoyridePortal, {\n        id: \"react-joyride-portal\"\n      }, /*#__PURE__*/react.createElement(JoyrideOverlay, _extends({}, step, {\n        debug: debug,\n        lifecycle: lifecycle,\n        onClickOverlay: this.handleClickOverlay\n      }))), /*#__PURE__*/react.createElement(es/* default */.Z, _extends({\n        component: /*#__PURE__*/react.createElement(JoyrideTooltip, {\n          continuous: continuous,\n          helpers: helpers,\n          index: index,\n          isLastStep: index + 1 === size,\n          setTooltipRef: this.setTooltipRef,\n          size: size,\n          step: step\n        }),\n        debug: debug,\n        getPopper: this.setPopper,\n        id: \"react-joyride-step-\".concat(index),\n        isPositioned: step.isFixed || hasPosition(target),\n        open: this.open,\n        placement: step.placement,\n        target: step.target\n      }, step.floaterProps), /*#__PURE__*/react.createElement(JoyrideBeacon, {\n        beaconComponent: step.beaconComponent,\n        locale: step.locale,\n        nonce: nonce,\n        onClickOrHover: this.handleClickHoverBeacon,\n        shouldFocus: shouldScroll,\n        styles: step.styles\n      })));\n    }\n  }]);\n\n  return JoyrideStep;\n}(react.Component);\n\nvar Joyride = /*#__PURE__*/function (_React$Component) {\n  _inherits(Joyride, _React$Component);\n\n  var _super = _createSuper(Joyride);\n\n  function Joyride(props) {\n    var _this;\n\n    _classCallCheck(this, Joyride);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"initStore\", function () {\n      var _this$props = _this.props,\n          debug = _this$props.debug,\n          getHelpers = _this$props.getHelpers,\n          run = _this$props.run,\n          stepIndex = _this$props.stepIndex;\n      _this.store = new createStore(_objectSpread2(_objectSpread2({}, _this.props), {}, {\n        controlled: run && src_default.number(stepIndex)\n      }));\n      _this.helpers = _this.store.getHelpers();\n      var addListener = _this.store.addListener;\n      log({\n        title: 'init',\n        data: [{\n          key: 'props',\n          value: _this.props\n        }, {\n          key: 'state',\n          value: _this.state\n        }],\n        debug: debug\n      }); // Sync the store to this component's state.\n\n      addListener(_this.syncState);\n      getHelpers(_this.helpers);\n      return _this.store.getState();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"callback\", function (data) {\n      var callback = _this.props.callback;\n      /* istanbul ignore else */\n\n      if (src_default[\"function\"](callback)) {\n        callback(data);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleKeyboard\", function (e) {\n      var _this$state = _this.state,\n          index = _this$state.index,\n          lifecycle = _this$state.lifecycle;\n      var steps = _this.props.steps;\n      var step = steps[index];\n      var intKey = window.Event ? e.which : e.keyCode;\n\n      if (lifecycle === LIFECYCLE.TOOLTIP) {\n        if (intKey === 27 && step && !step.disableCloseOnEsc) {\n          _this.store.close();\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"syncState\", function (state) {\n      _this.setState(state);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setPopper\", function (popper, type) {\n      if (type === 'wrapper') {\n        _this.beaconPopper = popper;\n      } else {\n        _this.tooltipPopper = popper;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"shouldScroll\", function (disableScrolling, index, scrollToFirstStep, lifecycle, step, target, prevState) {\n      return !disableScrolling && (index !== 0 || scrollToFirstStep || lifecycle === LIFECYCLE.TOOLTIP) && step.placement !== 'center' && (!step.isFixed || !hasPosition(target)) && // fixed steps don't need to scroll\n      prevState.lifecycle !== lifecycle && [LIFECYCLE.BEACON, LIFECYCLE.TOOLTIP].indexOf(lifecycle) !== -1;\n    });\n\n    _this.state = _this.initStore();\n    return _this;\n  }\n\n  _createClass(Joyride, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!canUseDOM) return;\n      var _this$props2 = this.props,\n          disableCloseOnEsc = _this$props2.disableCloseOnEsc,\n          debug = _this$props2.debug,\n          run = _this$props2.run,\n          steps = _this$props2.steps;\n      var start = this.store.start;\n\n      if (validateSteps(steps, debug) && run) {\n        start();\n      }\n      /* istanbul ignore else */\n\n\n      if (!disableCloseOnEsc) {\n        document.body.addEventListener('keydown', this.handleKeyboard, {\n          passive: true\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (!canUseDOM) return;\n      var _this$state2 = this.state,\n          action = _this$state2.action,\n          controlled = _this$state2.controlled,\n          index = _this$state2.index,\n          lifecycle = _this$state2.lifecycle,\n          status = _this$state2.status;\n      var _this$props3 = this.props,\n          debug = _this$props3.debug,\n          run = _this$props3.run,\n          stepIndex = _this$props3.stepIndex,\n          steps = _this$props3.steps;\n      var prevSteps = prevProps.steps,\n          prevStepIndex = prevProps.stepIndex;\n      var _this$store = this.store,\n          reset = _this$store.reset,\n          setSteps = _this$store.setSteps,\n          start = _this$store.start,\n          stop = _this$store.stop,\n          update = _this$store.update;\n\n      var _treeChanges = (0,esm/* default */.Z)(prevProps, this.props),\n          changedProps = _treeChanges.changed;\n\n      var _treeChanges2 = (0,esm/* default */.Z)(prevState, this.state),\n          changed = _treeChanges2.changed,\n          changedFrom = _treeChanges2.changedFrom;\n\n      var step = getMergedStep(steps[index], this.props);\n      var stepsChanged = !isEqual(prevSteps, steps);\n      var stepIndexChanged = src_default.number(stepIndex) && changedProps('stepIndex');\n      var target = getElement(step === null || step === void 0 ? void 0 : step.target);\n\n      if (stepsChanged) {\n        if (validateSteps(steps, debug)) {\n          setSteps(steps);\n        } else {\n          console.warn('Steps are not valid', steps); //eslint-disable-line no-console\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (changedProps('run')) {\n        if (run) {\n          start(stepIndex);\n        } else {\n          stop();\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (stepIndexChanged) {\n        var nextAction = prevStepIndex < stepIndex ? ACTIONS.NEXT : ACTIONS.PREV;\n\n        if (action === ACTIONS.STOP) {\n          nextAction = ACTIONS.START;\n        }\n\n        if (!([STATUS.FINISHED, STATUS.SKIPPED].indexOf(status) !== -1)) {\n          update({\n            action: action === ACTIONS.CLOSE ? ACTIONS.CLOSE : nextAction,\n            index: stepIndex,\n            lifecycle: LIFECYCLE.INIT\n          });\n        }\n      } // Update the index if the first step is not found\n\n\n      if (!controlled && status === STATUS.RUNNING && index === 0 && !target) {\n        update({\n          index: index + 1\n        });\n        this.callback(_objectSpread2(_objectSpread2({}, this.state), {}, {\n          type: EVENTS.TARGET_NOT_FOUND,\n          step: step\n        }));\n      }\n\n      var callbackData = _objectSpread2(_objectSpread2({}, this.state), {}, {\n        index: index,\n        step: step\n      });\n\n      var isAfterAction = changed('action', [ACTIONS.NEXT, ACTIONS.PREV, ACTIONS.SKIP, ACTIONS.CLOSE]);\n\n      if (isAfterAction && changed('status', STATUS.PAUSED)) {\n        var prevStep = getMergedStep(steps[prevState.index], this.props);\n        this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n          index: prevState.index,\n          lifecycle: LIFECYCLE.COMPLETE,\n          step: prevStep,\n          type: EVENTS.STEP_AFTER\n        }));\n      }\n\n      if (changed('status', [STATUS.FINISHED, STATUS.SKIPPED])) {\n        var _prevStep = getMergedStep(steps[prevState.index], this.props);\n\n        if (!controlled) {\n          this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n            index: prevState.index,\n            lifecycle: LIFECYCLE.COMPLETE,\n            step: _prevStep,\n            type: EVENTS.STEP_AFTER\n          }));\n        }\n\n        this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n          index: prevState.index,\n          // Return the last step when the tour is finished\n          step: _prevStep,\n          type: EVENTS.TOUR_END\n        }));\n        reset();\n      } else if (changedFrom('status', [STATUS.IDLE, STATUS.READY], STATUS.RUNNING)) {\n        this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n          type: EVENTS.TOUR_START\n        }));\n      } else if (changed('status')) {\n        this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n          type: EVENTS.TOUR_STATUS\n        }));\n      } else if (changed('action', ACTIONS.RESET)) {\n        this.callback(_objectSpread2(_objectSpread2({}, callbackData), {}, {\n          type: EVENTS.TOUR_STATUS\n        }));\n      }\n\n      if (step) {\n        this.scrollToStep(prevState);\n\n        if (step.placement === 'center' && status === STATUS.RUNNING && action === ACTIONS.START && lifecycle === LIFECYCLE.INIT) {\n          update({\n            lifecycle: LIFECYCLE.READY\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var disableCloseOnEsc = this.props.disableCloseOnEsc;\n      /* istanbul ignore else */\n\n      if (!disableCloseOnEsc) {\n        document.body.removeEventListener('keydown', this.handleKeyboard);\n      }\n    }\n  }, {\n    key: \"scrollToStep\",\n    value: function scrollToStep(prevState) {\n      var _this$state3 = this.state,\n          index = _this$state3.index,\n          lifecycle = _this$state3.lifecycle,\n          status = _this$state3.status;\n      var _this$props4 = this.props,\n          debug = _this$props4.debug,\n          disableScrolling = _this$props4.disableScrolling,\n          disableScrollParentFix = _this$props4.disableScrollParentFix,\n          scrollToFirstStep = _this$props4.scrollToFirstStep,\n          scrollOffset = _this$props4.scrollOffset,\n          scrollDuration = _this$props4.scrollDuration,\n          steps = _this$props4.steps;\n      var step = getMergedStep(steps[index], this.props);\n      /* istanbul ignore else */\n\n      if (step) {\n        var target = getElement(step.target);\n        var shouldScroll = this.shouldScroll(disableScrolling, index, scrollToFirstStep, lifecycle, step, target, prevState);\n\n        if (status === STATUS.RUNNING && shouldScroll) {\n          var hasCustomScroll = hasCustomScrollParent(target, disableScrollParentFix);\n          var scrollParent = getScrollParent(target, disableScrollParentFix);\n          var scrollY = Math.floor(getScrollTo(target, scrollOffset, disableScrollParentFix)) || 0;\n          log({\n            title: 'scrollToStep',\n            data: [{\n              key: 'index',\n              value: index\n            }, {\n              key: 'lifecycle',\n              value: lifecycle\n            }, {\n              key: 'status',\n              value: status\n            }],\n            debug: debug\n          });\n          /* istanbul ignore else */\n\n          if (lifecycle === LIFECYCLE.BEACON && this.beaconPopper) {\n            var _this$beaconPopper = this.beaconPopper,\n                placement = _this$beaconPopper.placement,\n                popper = _this$beaconPopper.popper;\n            /* istanbul ignore else */\n\n            if (!(['bottom'].indexOf(placement) !== -1) && !hasCustomScroll) {\n              scrollY = Math.floor(popper.top - scrollOffset);\n            }\n          } else if (lifecycle === LIFECYCLE.TOOLTIP && this.tooltipPopper) {\n            var _this$tooltipPopper = this.tooltipPopper,\n                flipped = _this$tooltipPopper.flipped,\n                _placement = _this$tooltipPopper.placement,\n                _popper = _this$tooltipPopper.popper;\n\n            if (['top', 'right', 'left'].indexOf(_placement) !== -1 && !flipped && !hasCustomScroll) {\n              scrollY = Math.floor(_popper.top - scrollOffset);\n            } else {\n              scrollY -= step.spotlightPadding;\n            }\n          }\n\n          scrollY = scrollY >= 0 ? scrollY : 0;\n          /* istanbul ignore else */\n\n          if (status === STATUS.RUNNING) {\n            scrollTo(scrollY, scrollParent, scrollDuration);\n          }\n        }\n      }\n    }\n    /**\n     * Trigger the callback.\n     *\n     * @private\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!canUseDOM) return null;\n      var _this$state4 = this.state,\n          index = _this$state4.index,\n          status = _this$state4.status;\n      var _this$props5 = this.props,\n          continuous = _this$props5.continuous,\n          debug = _this$props5.debug,\n          nonce = _this$props5.nonce,\n          scrollToFirstStep = _this$props5.scrollToFirstStep,\n          steps = _this$props5.steps;\n      var step = getMergedStep(steps[index], this.props);\n      var output;\n\n      if (status === STATUS.RUNNING && step) {\n        output = /*#__PURE__*/react.createElement(JoyrideStep, _extends({}, this.state, {\n          callback: this.callback,\n          continuous: continuous,\n          debug: debug,\n          setPopper: this.setPopper,\n          helpers: this.helpers,\n          nonce: nonce,\n          shouldScroll: !step.disableScrolling && (index !== 0 || scrollToFirstStep),\n          step: step,\n          update: this.store.update\n        }));\n      }\n\n      return /*#__PURE__*/react.createElement(\"div\", {\n        className: \"react-joyride\"\n      }, output);\n    }\n  }]);\n\n  return Joyride;\n}(react.Component);\n\n_defineProperty(Joyride, \"defaultProps\", {\n  continuous: false,\n  debug: false,\n  disableCloseOnEsc: false,\n  disableOverlay: false,\n  disableOverlayClose: false,\n  disableScrolling: false,\n  disableScrollParentFix: false,\n  getHelpers: function getHelpers() {},\n  hideBackButton: false,\n  run: true,\n  scrollOffset: 20,\n  scrollDuration: 300,\n  scrollToFirstStep: false,\n  showSkipButton: false,\n  showProgress: false,\n  spotlightClicks: false,\n  spotlightPadding: 10,\n  steps: []\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA0MDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMOEM7QUFDMUI7QUFDbUI7QUFDZDtBQUMwQjtBQUNWO0FBQ2I7QUFDWTtBQUNtQztBQUN6QztBQUNFOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDJCQUE4QjtBQUM5QyxnQkFBZ0Isc0JBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjs7QUFFQSxTQUFTLGdCQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVCQUFjLFlBQVksaUJBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsd0JBQWMsdUJBQXVCLHdCQUFjO0FBQ3hGLHFCQUFxQixxQkFBWSxVQUFVLHFCQUFZOztBQUV2RCxNQUFNLGdCQUFhLFdBQVcsZ0JBQWE7QUFDM0M7QUFDQTs7QUFFQSxNQUFNLHNCQUFhO0FBQ25CO0FBQ0E7O0FBRUEsTUFBTSxrQkFBUztBQUNmO0FBQ0E7O0FBRUEsTUFBTSx1QkFBYztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGlCQUFjO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFhOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsaUJBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRkFBaUYsbUJBQW1CLGdCQUFnQjs7QUFFcEg7QUFDQTtBQUNBLGNBQWMsdUJBQWM7QUFDNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0Msb0VBQW9FLCtCQUErQjtBQUMzSTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBLGlCQUFpQixrQkFBUztBQUMxQixTQUFTLFlBQVk7QUFDckI7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQVM7QUFDN0I7QUFDQSxlQUFlLGtCQUFTO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxlQUFlLHNCQUFZOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsc0JBQVk7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQVU7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixvQkFBb0IsZUFBZSwrQkFBa0I7QUFDMUU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7O0FBRUEsTUFBTSxrQkFBUyxlQUFlLGtCQUFTLGdCQUFnQiwrQkFBa0Isa0JBQWtCLGdCQUFPLEVBQUUsbUJBQVUsVUFBVSxtQkFBTTtBQUM5SDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBUyx5Q0FBeUM7QUFDbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DO0FBQ3BDLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0EsS0FBSztBQUNMLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQSxLQUFLO0FBQ0wscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLGFBQVM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUI7O0FBRXZCO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixpQkFBYTtBQUNoQyx1QkFBdUIsdUJBQWM7QUFDckMsR0FBRztBQUNILCtCQUErQixhQUFTLG1CQUFtQixtQkFBbUI7QUFDOUU7QUFDQSxxQkFBcUIsaUJBQWEsMEJBQTBCLHNEQUFzRCxJQUFJOztBQUV0SDtBQUNBLHdCQUF3QixhQUFTLDBCQUEwQixrQ0FBa0M7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxpQkFBaUI7QUFDMUQsWUFBWSxpQkFBYSxxQ0FBcUMseUJBQXlCO0FBQ3ZGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUEsT0FBTyx1QkFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQSxPQUFPLGlCQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQiwyQkFBMkIsYUFBYSwyQkFBMkIsMkJBQTJCLGFBQWEsV0FBVyxxREFBcUQsZ0JBQWdCLGtDQUFrQyxhQUFhLDJCQUEyQiwyQkFBMkIscUNBQXFDLGFBQWEsNEJBQTRCLDJCQUEyQixrQ0FBa0MsYUFBYSxXQUFXO0FBQ2hoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksc0JBQWE7QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BELFFBQVE7QUFDUixpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1QkFBdUIsbUJBQW1CO0FBQ25EO0FBQ0EsU0FBUyxnQkFBZ0IsbUJBQW1CO0FBQzVDO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLGVBQWU7O0FBRWpCO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1IsNEJBQTRCO0FBQzVCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixzQkFBVztBQUNwQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2REFBNkQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsOEVBQThFLG1CQUFtQjtBQUNqRztBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BELGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLENBQUMsZUFBZTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRyx1QkFBdUIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSxtQkFBbUIseUJBQXlCLG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0EsT0FBTztBQUNQLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4QkFBOEIsbUJBQW1CO0FBQ3hEO0FBQ0EsT0FBTyx3QkFBd0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSxPQUFPLHVCQUF1QixtQkFBbUI7QUFDakQ7QUFDQSxPQUFPLHlDQUF5QyxtQkFBbUI7QUFDbkU7QUFDQSxPQUFPLGVBQWUsbUJBQW1CO0FBQ3pDO0FBQ0EsT0FBTywwQ0FBMEMsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLGVBQWU7O0FBRWpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwREFBMEQsOEJBQThCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRCxRQUFRO0FBQ1IsaUNBQWlDLG1CQUFtQixxQ0FBcUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyxlQUFlOztBQUVqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQ0FBK0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sNkNBQTRDO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixzQkFBcUI7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyxlQUFlOztBQUVqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixzQkFBVztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDViwyRkFBMkY7O0FBRTNGLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxzQkFBYTtBQUMvQztBQUNBOztBQUVBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBLE9BQU8sZUFBZSxtQkFBbUI7QUFDekM7QUFDQSxPQUFPLGVBQWUsbUJBQW1CLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtCQUFrQixtQkFBbUIsQ0FBQyxpQkFBTztBQUNwRCxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQ0FBbUMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLENBQUMsZUFBZTs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0I7QUFDdEYsMkJBQTJCLGtCQUFTO0FBQ3BDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFVBQVUsdUJBQWM7QUFDeEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsc0JBQVc7QUFDcEM7O0FBRUEsMEJBQTBCLHNCQUFXO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixrQkFBUztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1Isc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1Isc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQkFBbUIseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsQ0FBQyxlQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFaUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvcmVhY3Qtam95cmlkZS9ub2RlX21vZHVsZXMvaXMtbGl0ZS9kaXN0L2luZGV4Lm1qcz81YjFjIiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy9yZWFjdC1qb3lyaWRlL2VzL2luZGV4LmpzPzhlM2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG52YXIgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0sgPSBbXG4gIFwiaW5uZXJIVE1MXCIsXG4gIFwib3duZXJEb2N1bWVudFwiLFxuICBcInN0eWxlXCIsXG4gIFwiYXR0cmlidXRlc1wiLFxuICBcIm5vZGVWYWx1ZVwiXG5dO1xudmFyIG9iamVjdFR5cGVzID0gW1xuICBcIkFycmF5XCIsXG4gIFwiQXJyYXlCdWZmZXJcIixcbiAgXCJBc3luY0Z1bmN0aW9uXCIsXG4gIFwiQXN5bmNHZW5lcmF0b3JcIixcbiAgXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXG4gIFwiRGF0ZVwiLFxuICBcIkVycm9yXCIsXG4gIFwiRnVuY3Rpb25cIixcbiAgXCJHZW5lcmF0b3JcIixcbiAgXCJHZW5lcmF0b3JGdW5jdGlvblwiLFxuICBcIkhUTUxFbGVtZW50XCIsXG4gIFwiTWFwXCIsXG4gIFwiT2JqZWN0XCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIlJlZ0V4cFwiLFxuICBcIlNldFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJXZWFrU2V0XCJcbl07XG52YXIgcHJpbWl0aXZlVHlwZXMgPSBbXG4gIFwiYmlnaW50XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcIm51bGxcIixcbiAgXCJudW1iZXJcIixcbiAgXCJzdHJpbmdcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJ1bmRlZmluZWRcIlxuXTtcbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUodmFsdWUpIHtcbiAgY29uc3Qgb2JqZWN0VHlwZU5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgaWYgKC9IVE1MXFx3K0VsZW1lbnQvLnRlc3Qob2JqZWN0VHlwZU5hbWUpKSB7XG4gICAgcmV0dXJuIFwiSFRNTEVsZW1lbnRcIjtcbiAgfVxuICBpZiAoaXNPYmplY3RUeXBlKG9iamVjdFR5cGVOYW1lKSkge1xuICAgIHJldHVybiBvYmplY3RUeXBlTmFtZTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNPYmplY3RPZlR5cGUodHlwZSkge1xuICByZXR1cm4gKHZhbHVlKSA9PiBnZXRPYmplY3RUeXBlKHZhbHVlKSA9PT0gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZShuYW1lKSB7XG4gIHJldHVybiBvYmplY3RUeXBlcy5pbmNsdWRlcyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlKHR5cGUpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSB0eXBlO1xufVxuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlKG5hbWUpIHtcbiAgcmV0dXJuIHByaW1pdGl2ZVR5cGVzLmluY2x1ZGVzKG5hbWUpO1xufVxuZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJzeW1ib2xcIjtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBkZWZhdWx0OlxuICB9XG4gIGlmIChpcy5hcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJBcnJheVwiO1xuICB9XG4gIGlmIChpcy5wbGFpbkZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiBcIkZ1bmN0aW9uXCI7XG4gIH1cbiAgY29uc3QgdGFnVHlwZSA9IGdldE9iamVjdFR5cGUodmFsdWUpO1xuICBpZiAodGFnVHlwZSkge1xuICAgIHJldHVybiB0YWdUeXBlO1xuICB9XG4gIHJldHVybiBcIk9iamVjdFwiO1xufVxuaXMuYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaXMuYXJyYXlPZiA9ICh0YXJnZXQsIHByZWRpY2F0ZSkgPT4ge1xuICBpZiAoIWlzLmFycmF5KHRhcmdldCkgJiYgIWlzLmZ1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC5ldmVyeSgoZCkgPT4gcHJlZGljYXRlKGQpKTtcbn07XG5pcy5hc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gKHZhbHVlKSA9PiBnZXRPYmplY3RUeXBlKHZhbHVlKSA9PT0gXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCI7XG5pcy5hc3luY0Z1bmN0aW9uID0gaXNPYmplY3RPZlR5cGUoXCJBc3luY0Z1bmN0aW9uXCIpO1xuaXMuYmlnaW50ID0gaXNPZlR5cGUoXCJiaWdpbnRcIik7XG5pcy5ib29sZWFuID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59O1xuaXMuZGF0ZSA9IGlzT2JqZWN0T2ZUeXBlKFwiRGF0ZVwiKTtcbmlzLmRlZmluZWQgPSAodmFsdWUpID0+ICFpcy51bmRlZmluZWQodmFsdWUpO1xuaXMuZG9tRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gaXMub2JqZWN0KHZhbHVlKSAmJiAhaXMucGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzLnN0cmluZyh2YWx1ZS5ub2RlTmFtZSkgJiYgRE9NX1BST1BFUlRJRVNfVE9fQ0hFQ0suZXZlcnkoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eSBpbiB2YWx1ZSk7XG59O1xuaXMuZW1wdHkgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwIHx8IGlzLmFycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgfHwgaXMub2JqZWN0KHZhbHVlKSAmJiAhaXMubWFwKHZhbHVlKSAmJiAhaXMuc2V0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwIHx8IGlzLnNldCh2YWx1ZSkgJiYgdmFsdWUuc2l6ZSA9PT0gMCB8fCBpcy5tYXAodmFsdWUpICYmIHZhbHVlLnNpemUgPT09IDA7XG59O1xuaXMuZXJyb3IgPSBpc09iamVjdE9mVHlwZShcIkVycm9yXCIpO1xuaXMuZnVuY3Rpb24gPSBpc09mVHlwZShcImZ1bmN0aW9uXCIpO1xuaXMuZ2VuZXJhdG9yID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpcy5pdGVyYWJsZSh2YWx1ZSkgJiYgaXMuZnVuY3Rpb24odmFsdWUubmV4dCkgJiYgaXMuZnVuY3Rpb24odmFsdWUudGhyb3cpO1xufTtcbmlzLmdlbmVyYXRvckZ1bmN0aW9uID0gaXNPYmplY3RPZlR5cGUoXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbmlzLmluc3RhbmNlT2YgPSAoaW5zdGFuY2UsIGNsYXNzXykgPT4ge1xuICBpZiAoIWluc3RhbmNlIHx8ICFjbGFzc18pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSkgPT09IGNsYXNzXy5wcm90b3R5cGU7XG59O1xuaXMuaXRlcmFibGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmIGlzLmZ1bmN0aW9uKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pO1xufTtcbmlzLm1hcCA9IGlzT2JqZWN0T2ZUeXBlKFwiTWFwXCIpO1xuaXMubmFuID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4odmFsdWUpO1xufTtcbmlzLm51bGwgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufTtcbmlzLm51bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gaXMubnVsbCh2YWx1ZSkgfHwgaXMudW5kZWZpbmVkKHZhbHVlKTtcbn07XG5pcy5udW1iZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzT2ZUeXBlKFwibnVtYmVyXCIpKHZhbHVlKSAmJiAhaXMubmFuKHZhbHVlKTtcbn07XG5pcy5udW1lcmljU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpcy5zdHJpbmcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDAgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKTtcbn07XG5pcy5vYmplY3QgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpICYmIChpcy5mdW5jdGlvbih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKTtcbn07XG5pcy5vbmVPZiA9ICh0YXJnZXQsIHZhbHVlKSA9PiB7XG4gIGlmICghaXMuYXJyYXkodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0LmluZGV4T2YodmFsdWUpID4gLTE7XG59O1xuaXMucGxhaW5GdW5jdGlvbiA9IGlzT2JqZWN0T2ZUeXBlKFwiRnVuY3Rpb25cIik7XG5pcy5wbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoZ2V0T2JqZWN0VHlwZSh2YWx1ZSkgIT09IFwiT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG59O1xuaXMucHJpbWl0aXZlID0gKHZhbHVlKSA9PiBpcy5udWxsKHZhbHVlKSB8fCBpc1ByaW1pdGl2ZVR5cGUodHlwZW9mIHZhbHVlKTtcbmlzLnByb21pc2UgPSBpc09iamVjdE9mVHlwZShcIlByb21pc2VcIik7XG5pcy5wcm9wZXJ0eU9mID0gKHRhcmdldCwga2V5LCBwcmVkaWNhdGUpID0+IHtcbiAgaWYgKCFpcy5vYmplY3QodGFyZ2V0KSB8fCAha2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gdGFyZ2V0W2tleV07XG4gIGlmIChpcy5mdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGlzLmRlZmluZWQodmFsdWUpO1xufTtcbmlzLnJlZ2V4cCA9IGlzT2JqZWN0T2ZUeXBlKFwiUmVnRXhwXCIpO1xuaXMuc2V0ID0gaXNPYmplY3RPZlR5cGUoXCJTZXRcIik7XG5pcy5zdHJpbmcgPSBpc09mVHlwZShcInN0cmluZ1wiKTtcbmlzLnN5bWJvbCA9IGlzT2ZUeXBlKFwic3ltYm9sXCIpO1xuaXMudW5kZWZpbmVkID0gaXNPZlR5cGUoXCJ1bmRlZmluZWRcIik7XG5pcy53ZWFrTWFwID0gaXNPYmplY3RPZlR5cGUoXCJXZWFrTWFwXCIpO1xuaXMud2Vha1NldCA9IGlzT2JqZWN0T2ZUeXBlKFwiV2Vha1NldFwiKTtcbnZhciBzcmNfZGVmYXVsdCA9IGlzO1xuZXhwb3J0IHtcbiAgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2V0T2JqZWN0VHlwZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCBSZWFjdCwgeyBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAncHJvcC10eXBlcyc7XG5pbXBvcnQgdHJlZUNoYW5nZXMgZnJvbSAndHJlZS1jaGFuZ2VzJztcbmltcG9ydCBpcyBmcm9tICdpcy1saXRlJztcbmltcG9ydCBSZWFjdERPTSwgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IEV4ZWN1dGlvbkVudmlyb25tZW50IGZyb20gJ2V4ZW52JztcbmltcG9ydCBzY3JvbGwgZnJvbSAnc2Nyb2xsJztcbmltcG9ydCBzY3JvbGxQYXJlbnQgZnJvbSAnc2Nyb2xscGFyZW50JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSwgRWxlbWVudCwgRm9yd2FyZFJlZiwgdHlwZU9mIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IEZsb2F0ZXIgZnJvbSAncmVhY3QtZmxvYXRlcic7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxudmFyIEFDVElPTlMgPSB7XG4gIElOSVQ6ICdpbml0JyxcbiAgU1RBUlQ6ICdzdGFydCcsXG4gIFNUT1A6ICdzdG9wJyxcbiAgUkVTRVQ6ICdyZXNldCcsXG4gIFBSRVY6ICdwcmV2JyxcbiAgTkVYVDogJ25leHQnLFxuICBHTzogJ2dvJyxcbiAgQ0xPU0U6ICdjbG9zZScsXG4gIFNLSVA6ICdza2lwJyxcbiAgVVBEQVRFOiAndXBkYXRlJ1xufTtcblxudmFyIEVWRU5UUyA9IHtcbiAgVE9VUl9TVEFSVDogJ3RvdXI6c3RhcnQnLFxuICBTVEVQX0JFRk9SRTogJ3N0ZXA6YmVmb3JlJyxcbiAgQkVBQ09OOiAnYmVhY29uJyxcbiAgVE9PTFRJUDogJ3Rvb2x0aXAnLFxuICBTVEVQX0FGVEVSOiAnc3RlcDphZnRlcicsXG4gIFRPVVJfRU5EOiAndG91cjplbmQnLFxuICBUT1VSX1NUQVRVUzogJ3RvdXI6c3RhdHVzJyxcbiAgVEFSR0VUX05PVF9GT1VORDogJ2Vycm9yOnRhcmdldF9ub3RfZm91bmQnLFxuICBFUlJPUjogJ2Vycm9yJ1xufTtcblxudmFyIExJRkVDWUNMRSA9IHtcbiAgSU5JVDogJ2luaXQnLFxuICBSRUFEWTogJ3JlYWR5JyxcbiAgQkVBQ09OOiAnYmVhY29uJyxcbiAgVE9PTFRJUDogJ3Rvb2x0aXAnLFxuICBDT01QTEVURTogJ2NvbXBsZXRlJyxcbiAgRVJST1I6ICdlcnJvcidcbn07XG5cbnZhciBTVEFUVVMgPSB7XG4gIElETEU6ICdpZGxlJyxcbiAgUkVBRFk6ICdyZWFkeScsXG4gIFdBSVRJTkc6ICd3YWl0aW5nJyxcbiAgUlVOTklORzogJ3J1bm5pbmcnLFxuICBQQVVTRUQ6ICdwYXVzZWQnLFxuICBTS0lQUEVEOiAnc2tpcHBlZCcsXG4gIEZJTklTSEVEOiAnZmluaXNoZWQnLFxuICBFUlJPUjogJ2Vycm9yJ1xufTtcblxudmFyIGNhblVzZURPTSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTTtcbnZhciBpc1JlYWN0MTYgPSBjcmVhdGVQb3J0YWwgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGJyb3dzZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50XG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRCcm93c2VyKCkge1xuICB2YXIgdXNlckFnZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB2YXIgYnJvd3NlciA9IHVzZXJBZ2VudDtcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBicm93c2VyID0gJ25vZGUnO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50TW9kZSkge1xuICAgIGJyb3dzZXIgPSAnaWUnO1xuICB9IGVsc2UgaWYgKC9FZGdlLy50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBicm93c2VyID0gJ2VkZ2UnO1xuICB9IC8vIE9wZXJhIDguMCtcbiAgZWxzZSBpZiAoQm9vbGVhbih3aW5kb3cub3BlcmEpIHx8IHVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApIHtcbiAgICBicm93c2VyID0gJ29wZXJhJztcbiAgfSAvLyBGaXJlZm94IDEuMCtcbiAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5JbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBicm93c2VyID0gJ2ZpcmVmb3gnO1xuICB9IC8vIENocm9tZSAxK1xuICBlbHNlIGlmICh3aW5kb3cuY2hyb21lKSB7XG4gICAgYnJvd3NlciA9ICdjaHJvbWUnO1xuICB9IC8vIFNhZmFyaSAoYW5kIENocm9tZSBpT1MsIEZpcmVmb3ggaU9TKVxuICBlbHNlIGlmICgvKFZlcnNpb25cXC8oWzAtOS5fXSspLipTYWZhcml8Q3JpT1N8RnhpT1N8IE1vYmlsZVxcLykvLnRlc3QodXNlckFnZW50KSkge1xuICAgIGJyb3dzZXIgPSAnc2FmYXJpJztcbiAgfVxuXG4gIHJldHVybiBicm93c2VyO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRvU3RyaW5nIE9iamVjdCB0eXBlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIEdldCB0ZXh0IGZyb20gUmVhY3QgY29tcG9uZW50c1xuICpcbiAqIEBwYXJhbSB7Kn0gcm9vdFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VGV4dChyb290KSB7XG4gIHZhciBjb250ZW50ID0gW107XG5cbiAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiByZWN1cnNlKGNoaWxkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50LnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIHJlY3Vyc2UoYyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkICYmIGNoaWxkLnByb3BzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZC5wcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdXJzZShjKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN1cnNlKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmVjdXJzZShyb290KTtcbiAgcmV0dXJuIGNvbnRlbnQuam9pbignICcpLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KHZhbHVlLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KTtcbn1cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5cyh2YWx1ZSwga2V5cykge1xuICBpZiAoIWlzLnBsYWluT2JqZWN0KHZhbHVlKSB8fCAhaXMuYXJyYXkoa2V5cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmV2ZXJ5KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGtleXMuaW5kZXhPZihkKSAhPT0gLTE7XG4gIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCB0byBSR0JcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gaGV4VG9SR0IoaGV4KSB7XG4gIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gIHZhciBwcm9wZXJIZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24gKG0sIHIsIGcsIGIpIHtcbiAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICB9KTtcbiAgdmFyIHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhwcm9wZXJIZXgpO1xuICByZXR1cm4gcmVzdWx0ID8gW3BhcnNlSW50KHJlc3VsdFsxXSwgMTYpLCBwYXJzZUludChyZXN1bHRbMl0sIDE2KSwgcGFyc2VJbnQocmVzdWx0WzNdLCAxNildIDogW107XG59XG4vKipcbiAqIERlY2lkZSBpZiB0aGUgc3RlcCBzaG91bGRuJ3Qgc2tpcCB0aGUgYmVhY29uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RlcFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhpZGVCZWFjb24oc3RlcCkge1xuICByZXR1cm4gc3RlcC5kaXNhYmxlQmVhY29uIHx8IHN0ZXAucGxhY2VtZW50ID09PSAnY2VudGVyJztcbn1cbi8qKlxuICogQ29tcGFyZSBpZiB0d28gdmFyaWFibGVzIGFyZSBlcXVhbFxuICpcbiAqIEBwYXJhbSB7Kn0gbGVmdFxuICogQHBhcmFtIHsqfSByaWdodFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBoYXNSZWFjdEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQobGVmdCkgfHwgLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KHJpZ2h0KTtcbiAgdmFyIGhhc1VuZGVmaW5lZCA9IGlzLnVuZGVmaW5lZChsZWZ0KSB8fCBpcy51bmRlZmluZWQocmlnaHQpO1xuXG4gIGlmIChnZXRPYmplY3RUeXBlKGxlZnQpICE9PSBnZXRPYmplY3RUeXBlKHJpZ2h0KSB8fCBoYXNSZWFjdEVsZW1lbnQgfHwgaGFzVW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzLmRvbUVsZW1lbnQobGVmdCkpIHtcbiAgICByZXR1cm4gbGVmdC5pc1NhbWVOb2RlKHJpZ2h0KTtcbiAgfVxuXG4gIGlmIChpcy5udW1iZXIobGVmdCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cblxuICBpZiAoaXNbXCJmdW5jdGlvblwiXShsZWZ0KSkge1xuICAgIHJldHVybiBsZWZ0LnRvU3RyaW5nKCkgPT09IHJpZ2h0LnRvU3RyaW5nKCk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gbGVmdCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGhhc093blByb3BlcnR5KGxlZnQsIGtleSkpIHtcbiAgICAgIGlmICh0eXBlb2YgbGVmdFtrZXldID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcmlnaHRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gZ2V0T2JqZWN0VHlwZShsZWZ0W2tleV0pO1xuXG4gICAgICBpZiAoWydvYmplY3QnLCAnYXJyYXknXS5pbmRleE9mKHR5cGUpICE9PSAtMSAmJiBpc0VxdWFsKGxlZnRba2V5XSwgcmlnaHRba2V5XSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nICYmIGlzRXF1YWwobGVmdFtrZXldLCByaWdodFtrZXldKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnRba2V5XSAhPT0gcmlnaHRba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcCBpbiByaWdodCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGhhc093blByb3BlcnR5KHJpZ2h0LCBwKSkge1xuICAgICAgaWYgKHR5cGVvZiBsZWZ0W3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIERldGVjdCBsZWdhY3kgYnJvd3NlcnNcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0xlZ2FjeSgpIHtcbiAgcmV0dXJuICEoWydjaHJvbWUnLCAnc2FmYXJpJywgJ2ZpcmVmb3gnLCAnb3BlcmEnXS5pbmRleE9mKGdldEJyb3dzZXIoKSkgIT09IC0xKTtcbn1cbi8qKlxuICogTG9nIG1ldGhvZCBjYWxscyBpZiBkZWJ1ZyBpcyBlbmFibGVkXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICBhcmcudGl0bGUgICAgLSBUaGUgdGl0bGUgdGhlIGxvZ2dlciB3YXMgY2FsbGVkIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBbYXJnLmRhdGFdICAgLSBUaGUgZGF0YSB0byBiZSBsb2dnZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICBbYXJnLndhcm5dICAtIElmIHRydWUsIHRoZSBtZXNzYWdlIHdpbGwgYmUgYSB3YXJuaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgW2FyZy5kZWJ1Z10gLSBOb3RoaW5nIHdpbGwgYmUgbG9nZ2VkIHVubGVzcyBkZWJ1ZyBpcyB0cnVlXG4gKi9cblxuZnVuY3Rpb24gbG9nKF9yZWYpIHtcbiAgdmFyIHRpdGxlID0gX3JlZi50aXRsZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJHdhcm4gPSBfcmVmLndhcm4sXG4gICAgICB3YXJuID0gX3JlZiR3YXJuID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkd2FybixcbiAgICAgIF9yZWYkZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgZGVidWcgPSBfcmVmJGRlYnVnID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVidWc7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICB2YXIgbG9nRm4gPSB3YXJuID8gY29uc29sZS53YXJuIHx8IGNvbnNvbGUuZXJyb3IgOiBjb25zb2xlLmxvZztcblxuICBpZiAoZGVidWcpIHtcbiAgICBpZiAodGl0bGUgJiYgZGF0YSkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcIiVjcmVhY3Qtam95cmlkZTogXCIuY29uY2F0KHRpdGxlKSwgJ2NvbG9yOiAjZmYwMDQ0OyBmb250LXdlaWdodDogYm9sZDsgZm9udC1zaXplOiAxMnB4OycpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoaXMucGxhaW5PYmplY3QoZCkgJiYgZC5rZXkpIHtcbiAgICAgICAgICAgIGxvZ0ZuLmFwcGx5KGNvbnNvbGUsIFtkLmtleSwgZC52YWx1ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dGbi5hcHBseShjb25zb2xlLCBbZGF0YV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01pc3NpbmcgdGl0bGUgb3IgZGF0YSBwcm9wcycpO1xuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbn1cblxudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgYWN0aW9uOiAnJyxcbiAgY29udHJvbGxlZDogZmFsc2UsXG4gIGluZGV4OiAwLFxuICBsaWZlY3ljbGU6IExJRkVDWUNMRS5JTklULFxuICBzaXplOiAwLFxuICBzdGF0dXM6IFNUQVRVUy5JRExFXG59O1xudmFyIHZhbGlkS2V5cyA9IFsnYWN0aW9uJywgJ2luZGV4JywgJ2xpZmVjeWNsZScsICdzdGF0dXMnXTtcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHByb3BzKSB7XG4gIHZhciBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgdmFyIGRhdGEgPSBuZXcgTWFwKCk7XG5cbiAgdmFyIFN0b3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmJGNvbnRpbnVvdXMgPSBfcmVmLmNvbnRpbnVvdXMsXG4gICAgICAgICAgY29udGludW91cyA9IF9yZWYkY29udGludW91cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGNvbnRpbnVvdXMsXG4gICAgICAgICAgc3RlcEluZGV4ID0gX3JlZi5zdGVwSW5kZXgsXG4gICAgICAgICAgX3JlZiRzdGVwcyA9IF9yZWYuc3RlcHMsXG4gICAgICAgICAgX3N0ZXBzID0gX3JlZiRzdGVwcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJHN0ZXBzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmUpO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsaXN0ZW5lclwiLCB2b2lkIDApO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRTdGVwc1wiLCBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldFN0YXRlID0gX3RoaXMuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIHNpemUgPSBfdGhpcyRnZXRTdGF0ZS5zaXplLFxuICAgICAgICAgICAgc3RhdHVzID0gX3RoaXMkZ2V0U3RhdGUuc3RhdHVzO1xuXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICBzaXplOiBzdGVwcy5sZW5ndGgsXG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5zZXQoJ3N0ZXBzJywgc3RlcHMpO1xuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5XQUlUSU5HICYmICFzaXplICYmIHN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IFNUQVRVUy5SVU5OSU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZExpc3RlbmVyXCIsIGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBfdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVwZGF0ZVwiLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKCFoYXNWYWxpZEtleXMoc3RhdGUsIHZhbGlkS2V5cykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBpcyBub3QgdmFsaWQuIFZhbGlkIGtleXM6IFwiLmNvbmNhdCh2YWxpZEtleXMuam9pbignLCAnKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmdldE5leHRTdGF0ZShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMuZ2V0U3RhdGUoKSksIHN0YXRlKSwge30sIHtcbiAgICAgICAgICBhY3Rpb246IHN0YXRlLmFjdGlvbiB8fCBBQ1RJT05TLlVQREFURVxuICAgICAgICB9KSwgdHJ1ZSkpKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydFwiLCBmdW5jdGlvbiAobmV4dEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTIgPSBfdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgaW5kZXggPSBfdGhpcyRnZXRTdGF0ZTIuaW5kZXgsXG4gICAgICAgICAgICBzaXplID0gX3RoaXMkZ2V0U3RhdGUyLnNpemU7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmdldE5leHRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlNUQVJULFxuICAgICAgICAgIGluZGV4OiBpcy5udW1iZXIobmV4dEluZGV4KSA/IG5leHRJbmRleCA6IGluZGV4XG4gICAgICAgIH0sIHRydWUpKSwge30sIHtcbiAgICAgICAgICBzdGF0dXM6IHNpemUgPyBTVEFUVVMuUlVOTklORyA6IFNUQVRVUy5XQUlUSU5HXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9wXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFkdmFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTMgPSBfdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgaW5kZXggPSBfdGhpcyRnZXRTdGF0ZTMuaW5kZXgsXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTMuc3RhdHVzO1xuXG4gICAgICAgIGlmIChbU1RBVFVTLkZJTklTSEVELCBTVEFUVVMuU0tJUFBFRF0uaW5kZXhPZihzdGF0dXMpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5nZXROZXh0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogQUNUSU9OUy5TVE9QLFxuICAgICAgICAgIGluZGV4OiBpbmRleCArIChhZHZhbmNlID8gMSA6IDApXG4gICAgICAgIH0pKSwge30sIHtcbiAgICAgICAgICBzdGF0dXM6IFNUQVRVUy5QQVVTRURcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldFN0YXRlNCA9IF90aGlzLmdldFN0YXRlKCksXG4gICAgICAgICAgICBpbmRleCA9IF90aGlzJGdldFN0YXRlNC5pbmRleCxcbiAgICAgICAgICAgIHN0YXR1cyA9IF90aGlzJGdldFN0YXRlNC5zdGF0dXM7XG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHJldHVybjtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMuZ2V0TmV4dFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IEFDVElPTlMuQ0xPU0UsXG4gICAgICAgICAgaW5kZXg6IGluZGV4ICsgMVxuICAgICAgICB9KSkpO1xuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdvXCIsIGZ1bmN0aW9uIChuZXh0SW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldFN0YXRlNSA9IF90aGlzLmdldFN0YXRlKCksXG4gICAgICAgICAgICBjb250cm9sbGVkID0gX3RoaXMkZ2V0U3RhdGU1LmNvbnRyb2xsZWQsXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTUuc3RhdHVzO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVkIHx8IHN0YXR1cyAhPT0gU1RBVFVTLlJVTk5JTkcpIHJldHVybjtcblxuICAgICAgICB2YXIgc3RlcCA9IF90aGlzLmdldFN0ZXBzKClbbmV4dEluZGV4XTtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMuZ2V0TmV4dFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IEFDVElPTlMuR08sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KSksIHt9LCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGVwID8gc3RhdHVzIDogU1RBVFVTLkZJTklTSEVEXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmZvXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTYgPSBfdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgaW5kZXggPSBfdGhpcyRnZXRTdGF0ZTYuaW5kZXgsXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTYuc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuZ2V0TmV4dFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IEFDVElPTlMuTkVYVCxcbiAgICAgICAgICBpbmRleDogaW5kZXggKyAxXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldFN0YXRlNyA9IF90aGlzLmdldFN0YXRlKCksXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTcuc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmdldE5leHRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlVQREFURSxcbiAgICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5UT09MVElQXG4gICAgICAgIH0pKSk7XG4gICAgICB9KTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJldlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTggPSBfdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgaW5kZXggPSBfdGhpcyRnZXRTdGF0ZTguaW5kZXgsXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTguc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmdldE5leHRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlBSRVYsXG4gICAgICAgICAgaW5kZXg6IGluZGV4IC0gMVxuICAgICAgICB9KSkpO1xuICAgICAgfSk7XG5cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTkgPSBfdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgY29udHJvbGxlZCA9IF90aGlzJGdldFN0YXRlOS5jb250cm9sbGVkO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVkKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmdldE5leHRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBBQ1RJT05TLlJFU0VULFxuICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgIH0pKSwge30sIHtcbiAgICAgICAgICBzdGF0dXM6IHJlc3RhcnQgPyBTVEFUVVMuUlVOTklORyA6IFNUQVRVUy5SRUFEWVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2tpcFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRnZXRTdGF0ZTEwID0gX3RoaXMuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIHN0YXR1cyA9IF90aGlzJGdldFN0YXRlMTAuc3RhdHVzO1xuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IFNUQVRVUy5SVU5OSU5HKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogQUNUSU9OUy5TS0lQLFxuICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLklOSVQsXG4gICAgICAgICAgc3RhdHVzOiBTVEFUVVMuU0tJUFBFRFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBBQ1RJT05TLklOSVQsXG4gICAgICAgIGNvbnRyb2xsZWQ6IGlzLm51bWJlcihzdGVwSW5kZXgpLFxuICAgICAgICBjb250aW51b3VzOiBjb250aW51b3VzLFxuICAgICAgICBpbmRleDogaXMubnVtYmVyKHN0ZXBJbmRleCkgPyBzdGVwSW5kZXggOiAwLFxuICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5JTklULFxuICAgICAgICBzdGF0dXM6IF9zdGVwcy5sZW5ndGggPyBTVEFUVVMuUkVBRFkgOiBTVEFUVVMuSURMRVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICB0aGlzLnNldFN0ZXBzKF9zdGVwcyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFN0b3JlLCBbe1xuICAgICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICAgIHZhciBfc3RhdGUkbmV4dFN0YXRlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwgbmV4dFN0YXRlKSxcbiAgICAgICAgICAgIGFjdGlvbiA9IF9zdGF0ZSRuZXh0U3RhdGUuYWN0aW9uLFxuICAgICAgICAgICAgaW5kZXggPSBfc3RhdGUkbmV4dFN0YXRlLmluZGV4LFxuICAgICAgICAgICAgbGlmZWN5Y2xlID0gX3N0YXRlJG5leHRTdGF0ZS5saWZlY3ljbGUsXG4gICAgICAgICAgICBzaXplID0gX3N0YXRlJG5leHRTdGF0ZS5zaXplLFxuICAgICAgICAgICAgc3RhdHVzID0gX3N0YXRlJG5leHRTdGF0ZS5zdGF0dXM7XG5cbiAgICAgICAgc3RvcmUuc2V0KCdhY3Rpb24nLCBhY3Rpb24pO1xuICAgICAgICBzdG9yZS5zZXQoJ2luZGV4JywgaW5kZXgpO1xuICAgICAgICBzdG9yZS5zZXQoJ2xpZmVjeWNsZScsIGxpZmVjeWNsZSk7XG4gICAgICAgIHN0b3JlLnNldCgnc2l6ZScsIHNpemUpO1xuICAgICAgICBzdG9yZS5zZXQoJ3N0YXR1cycsIHN0YXR1cyk7XG5cbiAgICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgICBzdG9yZS5zZXQoJ2NvbnRyb2xsZWQnLCBuZXh0U3RhdGUuY29udHJvbGxlZCk7XG4gICAgICAgICAgc3RvcmUuc2V0KCdjb250aW51b3VzJywgbmV4dFN0YXRlLmNvbnRpbnVvdXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cblxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lciAmJiB0aGlzLmhhc1VwZGF0ZWRTdGF0ZShzdGF0ZSkpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygn4pa2IOKWtiDilrYgTkVXIFNUQVRFJywgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyKHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFzdG9yZS5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0U3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb246IHN0b3JlLmdldCgnYWN0aW9uJykgfHwgJycsXG4gICAgICAgICAgY29udHJvbGxlZDogc3RvcmUuZ2V0KCdjb250cm9sbGVkJykgfHwgZmFsc2UsXG4gICAgICAgICAgaW5kZXg6IHBhcnNlSW50KHN0b3JlLmdldCgnaW5kZXgnKSwgMTApLFxuICAgICAgICAgIGxpZmVjeWNsZTogc3RvcmUuZ2V0KCdsaWZlY3ljbGUnKSB8fCAnJyxcbiAgICAgICAgICBzaXplOiBzdG9yZS5nZXQoJ3NpemUnKSB8fCAwLFxuICAgICAgICAgIHN0YXR1czogc3RvcmUuZ2V0KCdzdGF0dXMnKSB8fCAnJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXROZXh0U3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZXh0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgX3RoaXMkZ2V0U3RhdGUxMSA9IHRoaXMuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIGFjdGlvbiA9IF90aGlzJGdldFN0YXRlMTEuYWN0aW9uLFxuICAgICAgICAgICAgY29udHJvbGxlZCA9IF90aGlzJGdldFN0YXRlMTEuY29udHJvbGxlZCxcbiAgICAgICAgICAgIGluZGV4ID0gX3RoaXMkZ2V0U3RhdGUxMS5pbmRleCxcbiAgICAgICAgICAgIHNpemUgPSBfdGhpcyRnZXRTdGF0ZTExLnNpemUsXG4gICAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRnZXRTdGF0ZTExLnN0YXR1cztcblxuICAgICAgICB2YXIgbmV3SW5kZXggPSBpcy5udW1iZXIoc3RhdGUuaW5kZXgpID8gc3RhdGUuaW5kZXggOiBpbmRleDtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGNvbnRyb2xsZWQgJiYgIWZvcmNlID8gaW5kZXggOiBNYXRoLm1pbihNYXRoLm1heChuZXdJbmRleCwgMCksIHNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogc3RhdGUuYWN0aW9uIHx8IGFjdGlvbixcbiAgICAgICAgICBjb250cm9sbGVkOiBjb250cm9sbGVkLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgbGlmZWN5Y2xlOiBzdGF0ZS5saWZlY3ljbGUgfHwgTElGRUNZQ0xFLklOSVQsXG4gICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBzaXplLFxuICAgICAgICAgIHN0YXR1czogbmV4dEluZGV4ID09PSBzaXplID8gU1RBVFVTLkZJTklTSEVEIDogc3RhdGUuc3RhdHVzIHx8IHN0YXR1c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNVcGRhdGVkU3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNVcGRhdGVkU3RhdGUob2xkU3RhdGUpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEpTT04uc3RyaW5naWZ5KG9sZFN0YXRlKTtcbiAgICAgICAgdmFyIGFmdGVyID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIGJlZm9yZSAhPT0gYWZ0ZXI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RlcHMoKSB7XG4gICAgICAgIHZhciBzdGVwcyA9IGRhdGEuZ2V0KCdzdGVwcycpO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdGVwcykgPyBzdGVwcyA6IFtdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRIZWxwZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVscGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjbG9zZTogdGhpcy5jbG9zZSxcbiAgICAgICAgICBnbzogdGhpcy5nbyxcbiAgICAgICAgICBpbmZvOiB0aGlzLmluZm8sXG4gICAgICAgICAgbmV4dDogdGhpcy5uZXh0LFxuICAgICAgICAgIG9wZW46IHRoaXMub3BlbixcbiAgICAgICAgICBwcmV2OiB0aGlzLnByZXYsXG4gICAgICAgICAgcmVzZXQ6IHRoaXMucmVzZXQsXG4gICAgICAgICAgc2tpcDogdGhpcy5za2lwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0b3JlO1xuICB9KCk7XG5cbiAgcmV0dXJuIG5ldyBTdG9yZShwcm9wcyk7XG59XG5cbi8qKlxuICogRmluZCB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJyb3dzZXItbm9ybWFsaXplZCBcImRvY3VtZW50IGhlaWdodFwiXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50SGVpZ2h0KCkge1xuICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsXG4gICAgICBib2R5ID0gX2RvY3VtZW50LmJvZHksXG4gICAgICBodG1sID0gX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICBpZiAoIWJvZHkgfHwgIWh0bWwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heChib2R5LnNjcm9sbEhlaWdodCwgYm9keS5vZmZzZXRIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5vZmZzZXRIZWlnaHQpO1xufVxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRhcmdldCBET00gZWxlbWVudCBiYXNlZCBvbiBhIHN0ZXAncyAndGFyZ2V0Jy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqICBHZXQgY29tcHV0ZWQgc3R5bGUgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsKSB7XG4gIGlmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG59XG4vKipcbiAqIEdldCBzY3JvbGwgcGFyZW50IHdpdGggZml4XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBza2lwRml4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JMaXN0ZW5lcl1cbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCwgc2tpcEZpeCwgZm9yTGlzdGVuZXIpIHtcbiAgdmFyIHBhcmVudCA9IHNjcm9sbFBhcmVudChlbGVtZW50KTtcblxuICBpZiAocGFyZW50LmlzU2FtZU5vZGUoc2Nyb2xsRG9jKCkpKSB7XG4gICAgaWYgKGZvckxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbERvYygpO1xuICB9XG5cbiAgdmFyIGhhc1Njcm9sbGluZyA9IHBhcmVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gIGlmICghaGFzU2Nyb2xsaW5nICYmICFza2lwRml4KSB7XG4gICAgcGFyZW50LnN0eWxlLm92ZXJmbG93ID0gJ2luaXRpYWwnO1xuICAgIHJldHVybiBzY3JvbGxEb2MoKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBlbGVtZW50IGhhcyBjdXN0b20gc2Nyb2xsIHBhcmVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcEZpeFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0N1c3RvbVNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KSB7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgpO1xuICByZXR1cm4gIXBhcmVudC5pc1NhbWVOb2RlKHNjcm9sbERvYygpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGN1c3RvbSBvZmZzZXQgcGFyZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0N1c3RvbU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudCAhPT0gZG9jdW1lbnQuYm9keTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgZml4ZWQvc3RpY2t5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fE5vZGV9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzUG9zaXRpb24oZWwpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdmaXhlZCc7XG5cbiAgaWYgKCFlbCB8fCAhKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gZWwubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwpLnBvc2l0aW9uID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gaGFzUG9zaXRpb24oZWwucGFyZW50Tm9kZSwgdHlwZSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHZpc2libGVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKHBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAocGFyZW50RWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkgYnJlYWs7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgIGlmIChwYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50RWxlbWVudCksXG4gICAgICAgICAgZGlzcGxheSA9IF9nZXRDb21wdXRlZFN0eWxlLmRpc3BsYXksXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IF9nZXRDb21wdXRlZFN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgIGlmIChkaXNwbGF5ID09PSAnbm9uZScgfHwgdmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgYmFzZWQgb24gYSBzdGVwJ3MgJ3RhcmdldCcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBGaXhcbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvZmZzZXQsIHNraXBGaXgpIHtcbiAgdmFyIGVsZW1lbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgdmFyIHBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KTtcbiAgdmFyIGhhc1Njcm9sbFBhcmVudCA9IGhhc0N1c3RvbVNjcm9sbFBhcmVudChlbGVtZW50LCBza2lwRml4KTtcbiAgdmFyIHBhcmVudFRvcCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcGFyZW50VG9wID0gcGFyZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIHZhciB0b3AgPSBlbGVtZW50UmVjdC50b3AgKyAoIWhhc1Njcm9sbFBhcmVudCAmJiAhaGFzUG9zaXRpb24oZWxlbWVudCkgPyBwYXJlbnRUb3AgOiAwKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IodG9wIC0gb2Zmc2V0KTtcbn1cbi8qKlxuICogR2V0IHRoZSBvZmZzZXRUb3Agb2YgZWFjaCBlbGVtZW50IHVwIHRvIHRoZSBib2R5XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VG9wT2Zmc2V0KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0VG9wT2Zmc2V0KGVsZW1lbnQub2Zmc2V0UGFyZW50KSArIGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFRvcDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuLyoqXG4gKiBHZXQgdGhlIHNjcm9sbFRvcCBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcEZpeFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG8oZWxlbWVudCwgb2Zmc2V0LCBza2lwRml4KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIHRvcCA9IGdldFRvcE9mZnNldChlbGVtZW50KTtcblxuICBpZiAoaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KGVsZW1lbnQsIHNraXBGaXgpICYmICFoYXNDdXN0b21PZmZzZXRQYXJlbnQoZWxlbWVudCkpIHtcbiAgICB0b3AgLT0gZ2V0VG9wT2Zmc2V0KHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcih0b3AgLSBvZmZzZXQpO1xufVxuZnVuY3Rpb24gc2Nyb2xsRG9jKCkge1xuICByZXR1cm4gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG59XG4vKipcbiAqIFNjcm9sbCB0byBwb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsRHVyYXRpb25cbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICovXG5cbmZ1bmN0aW9uIHNjcm9sbFRvKHZhbHVlKSB7XG4gIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzY3JvbGxEb2MoKTtcbiAgdmFyIHNjcm9sbER1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAzMDA7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHZhciBsaW1pdCA9IHZhbHVlID4gc2Nyb2xsVG9wID8gdmFsdWUgLSBzY3JvbGxUb3AgOiBzY3JvbGxUb3AgLSB2YWx1ZTtcbiAgICBzY3JvbGwudG9wKGVsZW1lbnQsIHZhbHVlLCB7XG4gICAgICBkdXJhdGlvbjogbGltaXQgPCAxMDAgPyA1MCA6IHNjcm9sbER1cmF0aW9uXG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSAhPT0gJ0VsZW1lbnQgYWxyZWFkeSBhdCB0YXJnZXQgc2Nyb2xsIHBvc2l0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZVNhZmUgPSBjb21wb25lbnROYW1lIHx8ICc8PGFub255bW91cz4+JztcbiAgICB2YXIgcHJvcEZ1bGxOYW1lU2FmZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiUmVxdWlyZWQgXCIuY29uY2F0KGxvY2F0aW9uLCBcIiBgXCIpLmNvbmNhdChwcm9wRnVsbE5hbWVTYWZlLCBcImAgd2FzIG5vdCBzcGVjaWZpZWQgaW4gYFwiKS5jb25jYXQoY29tcG9uZW50TmFtZVNhZmUsIFwiYC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gNiA/IF9sZW4gLSA2IDogMCksIF9rZXkgPSA2OyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSA2XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGUuYXBwbHkodm9pZCAwLCBbcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lU2FmZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZVNhZmVdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5jcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBDb21wb25lbnQgPSBwcm9wVmFsdWU7XG5cbiAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkgJiYgaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICB2YXIgb3duUHJvcHMgPSB7XG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZigpIHt9LFxuICAgICAgc3RlcDoge31cbiAgICB9O1xuICAgIENvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgb3duUHJvcHMpO1xuICB9XG5cbiAgaWYgKGlzLnN0cmluZyhwcm9wVmFsdWUpIHx8IGlzLm51bWJlcihwcm9wVmFsdWUpIHx8ICFpc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSB8fCAhKFtFbGVtZW50LCBGb3J3YXJkUmVmXS5pbmRleE9mKHR5cGVPZihDb21wb25lbnQpKSAhPT0gLTEpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgXCIuY29uY2F0KGxvY2F0aW9uLCBcIiBgXCIpLmNvbmNhdChwcm9wRnVsbE5hbWUsIFwiYCBzdXBwbGllZCB0byBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAuIEV4cGVjdGVkIGEgUmVhY3QgY2xhc3Mgb3IgZm9yd2FyZFJlZi5cIikpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0pO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFycm93Q29sb3I6ICcjZmZmJyxcbiAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gIGJlYWNvblNpemU6IDM2LFxuICBvdmVybGF5Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICBwcmltYXJ5Q29sb3I6ICcjZjA0JyxcbiAgc3BvdGxpZ2h0U2hhZG93OiAnMCAwIDE1cHggcmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgdGV4dENvbG9yOiAnIzMzMycsXG4gIHpJbmRleDogMTAwXG59O1xudmFyIGJ1dHRvbkJhc2UgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgYm9yZGVyOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGNvbG9yOiAnIzU1NScsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBmb250U2l6ZTogMTYsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIHBhZGRpbmc6IDgsXG4gIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJ1xufTtcbnZhciBzcG90bGlnaHQgPSB7XG4gIGJvcmRlclJhZGl1czogNCxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbn07XG5mdW5jdGlvbiBnZXRTdHlsZXMoKSB7XG4gIHZhciBzdGVwU3R5bGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBkZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIHN0ZXBTdHlsZXMub3B0aW9ucyB8fCB7fSk7XG4gIHZhciB3aWR0aCA9IDI5MDtcblxuICBpZiAod2luZG93LmlubmVyV2lkdGggPiA0ODApIHtcbiAgICB3aWR0aCA9IDM4MDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgb3B0aW9ucy53aWR0aCkge1xuICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIDMwO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMud2lkdGg7IC8vZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdmVybGF5ID0ge1xuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICByaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgekluZGV4OiBvcHRpb25zLnpJbmRleFxuICB9O1xuICB2YXIgZGVmYXVsdFN0eWxlcyA9IHtcbiAgICBiZWFjb246IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBidXR0b25CYXNlKSwge30sIHtcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgaGVpZ2h0OiBvcHRpb25zLmJlYWNvblNpemUsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiBvcHRpb25zLmJlYWNvblNpemUsXG4gICAgICB6SW5kZXg6IG9wdGlvbnMuekluZGV4XG4gICAgfSksXG4gICAgYmVhY29uSW5uZXI6IHtcbiAgICAgIGFuaW1hdGlvbjogJ2pveXJpZGUtYmVhY29uLWlubmVyIDEuMnMgaW5maW5pdGUgZWFzZS1pbi1vdXQnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLnByaW1hcnlDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgaGVpZ2h0OiAnNTAlJyxcbiAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgb3BhY2l0eTogMC43LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICc1MCUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJyxcbiAgICAgIHdpZHRoOiAnNTAlJ1xuICAgIH0sXG4gICAgYmVhY29uT3V0ZXI6IHtcbiAgICAgIGFuaW1hdGlvbjogJ2pveXJpZGUtYmVhY29uLW91dGVyIDEuMnMgaW5maW5pdGUgZWFzZS1pbi1vdXQnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoXCIuY29uY2F0KGhleFRvUkdCKG9wdGlvbnMucHJpbWFyeUNvbG9yKS5qb2luKCcsJyksIFwiLCAwLjIpXCIpLFxuICAgICAgYm9yZGVyOiBcIjJweCBzb2xpZCBcIi5jb25jYXQob3B0aW9ucy5wcmltYXJ5Q29sb3IpLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG9wYWNpdHk6IDAuOSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnY2VudGVyJyxcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJSYWRpdXM6IDUsXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIGNvbG9yOiBvcHRpb25zLnRleHRDb2xvcixcbiAgICAgIGZvbnRTaXplOiAxNixcbiAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICBwYWRkaW5nOiAxNSxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6IHdpZHRoXG4gICAgfSxcbiAgICB0b29sdGlwQ29udGFpbmVyOiB7XG4gICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgfSxcbiAgICB0b29sdGlwVGl0bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgdG9vbHRpcENvbnRlbnQ6IHtcbiAgICAgIHBhZGRpbmc6ICcyMHB4IDEwcHgnXG4gICAgfSxcbiAgICB0b29sdGlwRm9vdGVyOiB7XG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgbWFyZ2luVG9wOiAxNVxuICAgIH0sXG4gICAgdG9vbHRpcEZvb3RlclNwYWNlcjoge1xuICAgICAgZmxleDogMVxuICAgIH0sXG4gICAgYnV0dG9uTmV4dDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJ1dHRvbkJhc2UpLCB7fSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLnByaW1hcnlDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgIGNvbG9yOiAnI2ZmZidcbiAgICB9KSxcbiAgICBidXR0b25CYWNrOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYnV0dG9uQmFzZSksIHt9LCB7XG4gICAgICBjb2xvcjogb3B0aW9ucy5wcmltYXJ5Q29sb3IsXG4gICAgICBtYXJnaW5MZWZ0OiAnYXV0bycsXG4gICAgICBtYXJnaW5SaWdodDogNVxuICAgIH0pLFxuICAgIGJ1dHRvbkNsb3NlOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYnV0dG9uQmFzZSksIHt9LCB7XG4gICAgICBjb2xvcjogb3B0aW9ucy50ZXh0Q29sb3IsXG4gICAgICBoZWlnaHQ6IDE0LFxuICAgICAgcGFkZGluZzogMTUsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDE0XG4gICAgfSksXG4gICAgYnV0dG9uU2tpcDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJ1dHRvbkJhc2UpLCB7fSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMudGV4dENvbG9yLFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfSksXG4gICAgb3ZlcmxheTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG92ZXJsYXkpLCB7fSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLm92ZXJsYXlDb2xvcixcbiAgICAgIG1peEJsZW5kTW9kZTogJ2hhcmQtbGlnaHQnXG4gICAgfSksXG4gICAgb3ZlcmxheUxlZ2FjeTogX29iamVjdFNwcmVhZDIoe30sIG92ZXJsYXkpLFxuICAgIG92ZXJsYXlMZWdhY3lDZW50ZXI6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvdmVybGF5KSwge30sIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5vdmVybGF5Q29sb3JcbiAgICB9KSxcbiAgICBzcG90bGlnaHQ6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzcG90bGlnaHQpLCB7fSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAnZ3JheSdcbiAgICB9KSxcbiAgICBzcG90bGlnaHRMZWdhY3k6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzcG90bGlnaHQpLCB7fSwge1xuICAgICAgYm94U2hhZG93OiBcIjAgMCAwIDk5OTlweCBcIi5jb25jYXQob3B0aW9ucy5vdmVybGF5Q29sb3IsIFwiLCBcIikuY29uY2F0KG9wdGlvbnMuc3BvdGxpZ2h0U2hhZG93KVxuICAgIH0pLFxuICAgIGZsb2F0ZXJTdHlsZXM6IHtcbiAgICAgIGFycm93OiB7XG4gICAgICAgIGNvbG9yOiBvcHRpb25zLmFycm93Q29sb3JcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHpJbmRleDogb3B0aW9ucy56SW5kZXggKyAxMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIGRlZXBtZXJnZShkZWZhdWx0U3R5bGVzLCBzdGVwU3R5bGVzKTtcbn1cblxudmFyIERFRkFVTFRTID0ge1xuICBmbG9hdGVyUHJvcHM6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gICAgICB9XG4gICAgfSxcbiAgICB3cmFwcGVyT3B0aW9uczoge1xuICAgICAgb2Zmc2V0OiAtMTgsXG4gICAgICBwb3NpdGlvbjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgbG9jYWxlOiB7XG4gICAgYmFjazogJ0JhY2snLFxuICAgIGNsb3NlOiAnQ2xvc2UnLFxuICAgIGxhc3Q6ICdMYXN0JyxcbiAgICBuZXh0OiAnTmV4dCcsXG4gICAgb3BlbjogJ09wZW4gdGhlIGRpYWxvZycsXG4gICAgc2tpcDogJ1NraXAnXG4gIH0sXG4gIHN0ZXA6IHtcbiAgICBldmVudDogJ2NsaWNrJyxcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIG9mZnNldDogMTBcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VG91clByb3BzKHByb3BzKSB7XG4gIHZhciBzaGFyZWRUb3VyUHJvcHMgPSBbJ2JlYWNvbkNvbXBvbmVudCcsICdkaXNhYmxlQ2xvc2VPbkVzYycsICdkaXNhYmxlT3ZlcmxheScsICdkaXNhYmxlT3ZlcmxheUNsb3NlJywgJ2Rpc2FibGVTY3JvbGxpbmcnLCAnZGlzYWJsZVNjcm9sbFBhcmVudEZpeCcsICdmbG9hdGVyUHJvcHMnLCAnaGlkZUJhY2tCdXR0b24nLCAnaGlkZUNsb3NlQnV0dG9uJywgJ2xvY2FsZScsICdzaG93UHJvZ3Jlc3MnLCAnc2hvd1NraXBCdXR0b24nLCAnc3BvdGxpZ2h0Q2xpY2tzJywgJ3Nwb3RsaWdodFBhZGRpbmcnLCAnc3R5bGVzJywgJ3Rvb2x0aXBDb21wb25lbnQnXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gc2hhcmVkVG91clByb3BzLmluZGV4T2YoZCkgIT09IC0xO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaSkge1xuICAgIGFjY1tpXSA9IHByb3BzW2ldOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlZFN0ZXAoc3RlcCwgcHJvcHMpIHtcbiAgaWYgKCFzdGVwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG1lcmdlZFN0ZXAgPSBkZWVwbWVyZ2UuYWxsKFtnZXRUb3VyUHJvcHMocHJvcHMpLCBERUZBVUxUUy5zdGVwLCBzdGVwXSwge1xuICAgIGlzTWVyZ2VhYmxlT2JqZWN0OiBpcy5wbGFpbk9iamVjdFxuICB9KTtcbiAgdmFyIG1lcmdlZFN0eWxlcyA9IGdldFN0eWxlcyhkZWVwbWVyZ2UocHJvcHMuc3R5bGVzIHx8IHt9LCBzdGVwLnN0eWxlcyB8fCB7fSkpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KGdldEVsZW1lbnQoc3RlcC50YXJnZXQpLCBtZXJnZWRTdGVwLmRpc2FibGVTY3JvbGxQYXJlbnRGaXgpO1xuICB2YXIgZmxvYXRlclByb3BzID0gZGVlcG1lcmdlLmFsbChbcHJvcHMuZmxvYXRlclByb3BzIHx8IHt9LCBERUZBVUxUUy5mbG9hdGVyUHJvcHMsIG1lcmdlZFN0ZXAuZmxvYXRlclByb3BzIHx8IHt9XSk7IC8vIFNldCByZWFjdC1mbG9hdGVyIHByb3BzXG5cbiAgZmxvYXRlclByb3BzLm9mZnNldCA9IG1lcmdlZFN0ZXAub2Zmc2V0O1xuICBmbG9hdGVyUHJvcHMuc3R5bGVzID0gZGVlcG1lcmdlKGZsb2F0ZXJQcm9wcy5zdHlsZXMgfHwge30sIG1lcmdlZFN0eWxlcy5mbG9hdGVyU3R5bGVzIHx8IHt9KTtcbiAgZGVsZXRlIG1lcmdlZFN0eWxlcy5mbG9hdGVyU3R5bGVzO1xuICBmbG9hdGVyUHJvcHMub2Zmc2V0ICs9IHByb3BzLnNwb3RsaWdodFBhZGRpbmcgfHwgc3RlcC5zcG90bGlnaHRQYWRkaW5nIHx8IDA7XG5cbiAgaWYgKHN0ZXAucGxhY2VtZW50QmVhY29uKSB7XG4gICAgZmxvYXRlclByb3BzLndyYXBwZXJPcHRpb25zLnBsYWNlbWVudCA9IHN0ZXAucGxhY2VtZW50QmVhY29uO1xuICB9XG5cbiAgaWYgKHNjcm9sbFBhcmVudCkge1xuICAgIGZsb2F0ZXJQcm9wcy5vcHRpb25zLnByZXZlbnRPdmVyZmxvdy5ib3VuZGFyaWVzRWxlbWVudCA9ICd3aW5kb3cnO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBtZXJnZWRTdGVwKSwge30sIHtcbiAgICBsb2NhbGU6IGRlZXBtZXJnZS5hbGwoW0RFRkFVTFRTLmxvY2FsZSwgcHJvcHMubG9jYWxlIHx8IHt9LCBtZXJnZWRTdGVwLmxvY2FsZSB8fCB7fV0pLFxuICAgIGZsb2F0ZXJQcm9wczogZmxvYXRlclByb3BzLFxuICAgIHN0eWxlczogbWVyZ2VkU3R5bGVzXG4gIH0pO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBpZiBhIHN0ZXAgaXMgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RlcCAtIEEgc3RlcCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVidWdcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzdGVwIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0ZXAoc3RlcCkge1xuICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIGlmICghaXMucGxhaW5PYmplY3Qoc3RlcCkpIHtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6ICd2YWxpZGF0ZVN0ZXAnLFxuICAgICAgZGF0YTogJ3N0ZXAgbXVzdCBiZSBhbiBvYmplY3QnLFxuICAgICAgd2FybjogdHJ1ZSxcbiAgICAgIGRlYnVnOiBkZWJ1Z1xuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghc3RlcC50YXJnZXQpIHtcbiAgICBsb2coe1xuICAgICAgdGl0bGU6ICd2YWxpZGF0ZVN0ZXAnLFxuICAgICAgZGF0YTogJ3RhcmdldCBpcyBtaXNzaW5nIGZyb20gdGhlIHN0ZXAnLFxuICAgICAgd2FybjogdHJ1ZSxcbiAgICAgIGRlYnVnOiBkZWJ1Z1xuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBpZiBzdGVwcyBpcyB2YWxpZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHN0ZXBzIC0gQSBzdGVwcyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBkZWJ1Z1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHN0ZXBzIGFyZSB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVTdGVwcyhzdGVwcykge1xuICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIGlmICghaXMuYXJyYXkoc3RlcHMpKSB7XG4gICAgbG9nKHtcbiAgICAgIHRpdGxlOiAndmFsaWRhdGVTdGVwcycsXG4gICAgICBkYXRhOiAnc3RlcHMgbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICB3YXJuOiB0cnVlLFxuICAgICAgZGVidWc6IGRlYnVnXG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0ZXBzLmV2ZXJ5KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlU3RlcChkLCBkZWJ1Zyk7XG4gIH0pO1xufVxuXG52YXIgU2NvcGUgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFNjb3BlKF9lbGVtZW50KSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY29wZSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZWxlbWVudFwiLCB2b2lkIDApO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYW5CZVRhYmJlZFwiLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQudGFiSW5kZXg7XG4gICAgaWYgKHRhYkluZGV4ID09PSBudWxsIHx8IHRhYkluZGV4IDwgMCkgdGFiSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgdmFyIGlzVGFiSW5kZXhOYU4gPSBpc05hTih0YWJJbmRleCk7XG4gICAgcmV0dXJuICFpc1RhYkluZGV4TmFOICYmIF90aGlzLmNhbkhhdmVGb2N1cyhlbGVtZW50KTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FuSGF2ZUZvY3VzXCIsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHZhbGlkVGFiTm9kZXMgPSAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcmVzID0gdmFsaWRUYWJOb2Rlcy50ZXN0KG5vZGVOYW1lKSAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgbm9kZU5hbWUgPT09ICdhJyAmJiAhIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgcmV0dXJuIHJlcyAmJiBfdGhpcy5pc1Zpc2libGUoZWxlbWVudCk7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmRWYWxpZFRhYkVsZW1lbnRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChfdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSwgMCkuZmlsdGVyKF90aGlzLmNhbkJlVGFiYmVkKTtcbiAgfSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfdGhpcyRvcHRpb25zJGtleUNvZGUgPSBfdGhpcy5vcHRpb25zLmtleUNvZGUsXG4gICAgICAgIGtleUNvZGUgPSBfdGhpcyRvcHRpb25zJGtleUNvZGUgPT09IHZvaWQgMCA/IDkgOiBfdGhpcyRvcHRpb25zJGtleUNvZGU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgIGlmIChlLmtleUNvZGUgPT09IGtleUNvZGUpIHtcbiAgICAgIF90aGlzLmludGVyY2VwdFRhYihlKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVyY2VwdFRhYlwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBfdGhpcy5maW5kVmFsaWRUYWJFbGVtZW50cygpO1xuXG4gICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBzaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIHZhciB4ID0gZWxlbWVudHMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblxuICAgIGlmICh4ID09PSAtMSB8fCAhc2hpZnRLZXkgJiYgeCArIDEgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IDA7XG4gICAgfSBlbHNlIGlmIChzaGlmdEtleSAmJiB4ID09PSAwKSB7XG4gICAgICB4ID0gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBzaGlmdEtleSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBlbGVtZW50c1t4XS5mb2N1cygpO1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0hpZGRlblwiLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBub1NpemUgPSBlbGVtZW50Lm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbWVudC5vZmZzZXRIZWlnaHQgPD0gMDtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBpZiAobm9TaXplICYmICFlbGVtZW50LmlubmVySFRNTCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG5vU2l6ZSAmJiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICE9PSAndmlzaWJsZScgfHwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZSc7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVmlzaWJsZVwiLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZWxlbWVudDtcblxuICAgIHdoaWxlIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAocGFyZW50RWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgICAgICAgaWYgKF90aGlzLmlzSGlkZGVuKHBhcmVudEVsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbW92ZVNjb3BlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF90aGlzLmhhbmRsZUtleURvd24pO1xuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja0ZvY3VzXCIsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hlY2tGb2N1cyh0YXJnZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRGb2N1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gX3RoaXMub3B0aW9ucy5zZWxlY3RvcjtcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG5cbiAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNoZWNrRm9jdXModGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCEoX2VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50Jyk7XG4gIH1cblxuICB0aGlzLmVsZW1lbnQgPSBfZWxlbWVudDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgdGhpcy5zZXRGb2N1cygpO1xufSk7XG5cbnZhciBKb3lyaWRlQmVhY29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhKb3lyaWRlQmVhY29uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEpveXJpZGVCZWFjb24pO1xuXG4gIGZ1bmN0aW9uIEpveXJpZGVCZWFjb24ocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSm95cmlkZUJlYWNvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRCZWFjb25SZWZcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIF90aGlzLmJlYWNvbiA9IGM7XG4gICAgfSk7XG5cbiAgICBpZiAoIXByb3BzLmJlYWNvbkNvbXBvbmVudCkge1xuICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgdmFyIGNzcyA9IFwiXFxuICAgICAgICBAa2V5ZnJhbWVzIGpveXJpZGUtYmVhY29uLWlubmVyIHtcXG4gICAgICAgICAgMjAlIHtcXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgICA5MCUge1xcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICBAa2V5ZnJhbWVzIGpveXJpZGUtYmVhY29uLW91dGVyIHtcXG4gICAgICAgICAgMCUge1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgICA0NSUge1xcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNztcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgICAgMTAwJSB7XFxuICAgICAgICAgICAgb3BhY2l0eTogMC45O1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgc3R5bGUuaWQgPSAnam95cmlkZS1iZWFjb24tYW5pbWF0aW9uJztcblxuICAgICAgaWYgKHByb3BzLm5vbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdub25jZScsIHByb3BzLm5vbmNlKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSm95cmlkZUJlYWNvbiwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHNob3VsZEZvY3VzID0gdGhpcy5wcm9wcy5zaG91bGRGb2N1cztcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpcy5kb21FbGVtZW50KF90aGlzMi5iZWFjb24pICYmIHNob3VsZEZvY3VzKSB7XG4gICAgICAgICAgX3RoaXMyLmJlYWNvbi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnam95cmlkZS1iZWFjb24tYW5pbWF0aW9uJyk7XG5cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgYmVhY29uQ29tcG9uZW50ID0gX3RoaXMkcHJvcHMuYmVhY29uQ29tcG9uZW50LFxuICAgICAgICAgIGxvY2FsZSA9IF90aGlzJHByb3BzLmxvY2FsZSxcbiAgICAgICAgICBvbkNsaWNrT3JIb3ZlciA9IF90aGlzJHByb3BzLm9uQ2xpY2tPckhvdmVyLFxuICAgICAgICAgIHN0eWxlcyA9IF90aGlzJHByb3BzLnN0eWxlcztcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiBsb2NhbGUub3BlbixcbiAgICAgICAgb25DbGljazogb25DbGlja09ySG92ZXIsXG4gICAgICAgIG9uTW91c2VFbnRlcjogb25DbGlja09ySG92ZXIsXG4gICAgICAgIHJlZjogdGhpcy5zZXRCZWFjb25SZWYsXG4gICAgICAgIHRpdGxlOiBsb2NhbGUub3BlblxuICAgICAgfTtcbiAgICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICAgIGlmIChiZWFjb25Db21wb25lbnQpIHtcbiAgICAgICAgdmFyIEJlYWNvbkNvbXBvbmVudCA9IGJlYWNvbkNvbXBvbmVudDtcbiAgICAgICAgY29tcG9uZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQmVhY29uQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIkpveXJpZGVCZWFjb25cIixcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVhY3Qtam95cmlkZV9fYmVhY29uXCIsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlcy5iZWFjb24sXG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgICAgc3R5bGU6IHN0eWxlcy5iZWFjb25Jbm5lclxuICAgICAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgICBzdHlsZTogc3R5bGVzLmJlYWNvbk91dGVyXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSm95cmlkZUJlYWNvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gSm95cmlkZVNwb3RsaWdodChfcmVmKSB7XG4gIHZhciBzdHlsZXMgPSBfcmVmLnN0eWxlcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwiSm95cmlkZVNwb3RsaWdodFwiLFxuICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX19zcG90bGlnaHRcIixcbiAgICBzdHlsZTogc3R5bGVzXG4gIH0pO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJtaXhCbGVuZE1vZGVcIiwgXCJ6SW5kZXhcIl07XG5cbnZhciBKb3lyaWRlT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSm95cmlkZU92ZXJsYXksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSm95cmlkZU92ZXJsYXkpO1xuXG4gIGZ1bmN0aW9uIEpveXJpZGVPdmVybGF5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKb3lyaWRlT3ZlcmxheSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pc01vdW50ZWRcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIG1vdXNlT3ZlclNwb3RsaWdodDogZmFsc2UsXG4gICAgICBpc1Njcm9sbGluZzogZmFsc2UsXG4gICAgICBzaG93U3BvdGxpZ2h0OiB0cnVlXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlTW91c2VNb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgbW91c2VPdmVyU3BvdGxpZ2h0ID0gX3RoaXMuc3RhdGUubW91c2VPdmVyU3BvdGxpZ2h0O1xuICAgICAgdmFyIF90aGlzJHNwb3RsaWdodFN0eWxlcyA9IF90aGlzLnNwb3RsaWdodFN0eWxlcyxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRzcG90bGlnaHRTdHlsZXMuaGVpZ2h0LFxuICAgICAgICAgIGxlZnQgPSBfdGhpcyRzcG90bGlnaHRTdHlsZXMubGVmdCxcbiAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzJHNwb3RsaWdodFN0eWxlcy5wb3NpdGlvbixcbiAgICAgICAgICB0b3AgPSBfdGhpcyRzcG90bGlnaHRTdHlsZXMudG9wLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkc3BvdGxpZ2h0U3R5bGVzLndpZHRoO1xuICAgICAgdmFyIG9mZnNldFkgPSBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IGUuY2xpZW50WSA6IGUucGFnZVk7XG4gICAgICB2YXIgb2Zmc2V0WCA9IHBvc2l0aW9uID09PSAnZml4ZWQnID8gZS5jbGllbnRYIDogZS5wYWdlWDtcbiAgICAgIHZhciBpblNwb3RsaWdodEhlaWdodCA9IG9mZnNldFkgPj0gdG9wICYmIG9mZnNldFkgPD0gdG9wICsgaGVpZ2h0O1xuICAgICAgdmFyIGluU3BvdGxpZ2h0V2lkdGggPSBvZmZzZXRYID49IGxlZnQgJiYgb2Zmc2V0WCA8PSBsZWZ0ICsgd2lkdGg7XG4gICAgICB2YXIgaW5TcG90bGlnaHQgPSBpblNwb3RsaWdodFdpZHRoICYmIGluU3BvdGxpZ2h0SGVpZ2h0O1xuXG4gICAgICBpZiAoaW5TcG90bGlnaHQgIT09IG1vdXNlT3ZlclNwb3RsaWdodCkge1xuICAgICAgICBfdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgbW91c2VPdmVyU3BvdGxpZ2h0OiBpblNwb3RsaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhcmdldCA9IF90aGlzLnByb3BzLnRhcmdldDtcbiAgICAgIHZhciBlbGVtZW50ID0gZ2V0RWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoX3RoaXMuc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICB2YXIgaXNTY3JvbGxpbmcgPSBfdGhpcy5zdGF0ZS5pc1Njcm9sbGluZztcblxuICAgICAgICBpZiAoIWlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgX3RoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHRydWUsXG4gICAgICAgICAgICBzaG93U3BvdGxpZ2h0OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnNjcm9sbFRpbWVvdXQpO1xuICAgICAgICBfdGhpcy5zY3JvbGxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1Nwb3RsaWdodDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1Bvc2l0aW9uKGVsZW1lbnQsICdzdGlja3knKSkge1xuICAgICAgICBfdGhpcy51cGRhdGVTdGF0ZSh7fSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlUmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgIF90aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSm95cmlkZU92ZXJsYXksIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICBfdGhpcyRwcm9wcy5kZWJ1ZztcbiAgICAgICAgICBfdGhpcyRwcm9wcy5kaXNhYmxlU2Nyb2xsaW5nO1xuICAgICAgICAgIHZhciBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4ID0gX3RoaXMkcHJvcHMuZGlzYWJsZVNjcm9sbFBhcmVudEZpeCxcbiAgICAgICAgICB0YXJnZXQgPSBfdGhpcyRwcm9wcy50YXJnZXQ7XG4gICAgICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgsIHRydWUpO1xuICAgICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBsaWZlY3ljbGUgPSBfdGhpcyRwcm9wczIubGlmZWN5Y2xlLFxuICAgICAgICAgIHNwb3RsaWdodENsaWNrcyA9IF90aGlzJHByb3BzMi5zcG90bGlnaHRDbGlja3M7XG5cbiAgICAgIHZhciBfdHJlZUNoYW5nZXMgPSB0cmVlQ2hhbmdlcyhwcmV2UHJvcHMsIHRoaXMucHJvcHMpLFxuICAgICAgICAgIGNoYW5nZWQgPSBfdHJlZUNoYW5nZXMuY2hhbmdlZDtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cblxuICAgICAgaWYgKGNoYW5nZWQoJ2xpZmVjeWNsZScsIExJRkVDWUNMRS5UT09MVElQKSkge1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpc1Njcm9sbGluZyA9IF90aGlzMi5zdGF0ZS5pc1Njcm9sbGluZztcblxuICAgICAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIF90aGlzMi51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICAgIHNob3dTcG90bGlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQoJ3Nwb3RsaWdodENsaWNrcycpIHx8IGNoYW5nZWQoJ2Rpc2FibGVPdmVybGF5JykgfHwgY2hhbmdlZCgnbGlmZWN5Y2xlJykpIHtcbiAgICAgICAgaWYgKHNwb3RsaWdodENsaWNrcyAmJiBsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5UT09MVElQKSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGlmZWN5Y2xlICE9PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zY3JvbGxUaW1lb3V0KTtcbiAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BvdGxpZ2h0U3R5bGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2hvd1Nwb3RsaWdodCA9IHRoaXMuc3RhdGUuc2hvd1Nwb3RsaWdodDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRpc2FibGVTY3JvbGxQYXJlbnRGaXggPSBfdGhpcyRwcm9wczMuZGlzYWJsZVNjcm9sbFBhcmVudEZpeCxcbiAgICAgICAgICBzcG90bGlnaHRDbGlja3MgPSBfdGhpcyRwcm9wczMuc3BvdGxpZ2h0Q2xpY2tzLFxuICAgICAgICAgIHNwb3RsaWdodFBhZGRpbmcgPSBfdGhpcyRwcm9wczMuc3BvdGxpZ2h0UGFkZGluZyxcbiAgICAgICAgICBzdHlsZXMgPSBfdGhpcyRwcm9wczMuc3R5bGVzLFxuICAgICAgICAgIHRhcmdldCA9IF90aGlzJHByb3BzMy50YXJnZXQ7XG4gICAgICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgIHZhciBlbGVtZW50UmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgICB2YXIgaXNGaXhlZFRhcmdldCA9IGhhc1Bvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgdmFyIHRvcCA9IGdldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBzcG90bGlnaHRQYWRkaW5nLCBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4KTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaXNMZWdhY3koKSA/IHN0eWxlcy5zcG90bGlnaHRMZWdhY3kgOiBzdHlsZXMuc3BvdGxpZ2h0KSwge30sIHtcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGVsZW1lbnRSZWN0LmhlaWdodCArIHNwb3RsaWdodFBhZGRpbmcgKiAyKSxcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZChlbGVtZW50UmVjdC5sZWZ0IC0gc3BvdGxpZ2h0UGFkZGluZyksXG4gICAgICAgIG9wYWNpdHk6IHNob3dTcG90bGlnaHQgPyAxIDogMCxcbiAgICAgICAgcG9pbnRlckV2ZW50czogc3BvdGxpZ2h0Q2xpY2tzID8gJ25vbmUnIDogJ2F1dG8nLFxuICAgICAgICBwb3NpdGlvbjogaXNGaXhlZFRhcmdldCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycycsXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGVsZW1lbnRSZWN0LndpZHRoICsgc3BvdGxpZ2h0UGFkZGluZyAqIDIpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgIGlmICghdGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIG1vdXNlT3ZlclNwb3RsaWdodCA9IF90aGlzJHN0YXRlLm1vdXNlT3ZlclNwb3RsaWdodCxcbiAgICAgICAgICBzaG93U3BvdGxpZ2h0ID0gX3RoaXMkc3RhdGUuc2hvd1Nwb3RsaWdodDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRpc2FibGVPdmVybGF5ID0gX3RoaXMkcHJvcHM0LmRpc2FibGVPdmVybGF5LFxuICAgICAgICAgIGRpc2FibGVPdmVybGF5Q2xvc2UgPSBfdGhpcyRwcm9wczQuZGlzYWJsZU92ZXJsYXlDbG9zZSxcbiAgICAgICAgICBsaWZlY3ljbGUgPSBfdGhpcyRwcm9wczQubGlmZWN5Y2xlLFxuICAgICAgICAgIG9uQ2xpY2tPdmVybGF5ID0gX3RoaXMkcHJvcHM0Lm9uQ2xpY2tPdmVybGF5LFxuICAgICAgICAgIHBsYWNlbWVudCA9IF90aGlzJHByb3BzNC5wbGFjZW1lbnQsXG4gICAgICAgICAgc3R5bGVzID0gX3RoaXMkcHJvcHM0LnN0eWxlcztcblxuICAgICAgaWYgKGRpc2FibGVPdmVybGF5IHx8IGxpZmVjeWNsZSAhPT0gTElGRUNZQ0xFLlRPT0xUSVApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXNlU3R5bGVzID0gc3R5bGVzLm92ZXJsYXk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICBpZiAoaXNMZWdhY3koKSkge1xuICAgICAgICBiYXNlU3R5bGVzID0gcGxhY2VtZW50ID09PSAnY2VudGVyJyA/IHN0eWxlcy5vdmVybGF5TGVnYWN5Q2VudGVyIDogc3R5bGVzLm92ZXJsYXlMZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZXNPdmVybGF5ID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBjdXJzb3I6IGRpc2FibGVPdmVybGF5Q2xvc2UgPyAnZGVmYXVsdCcgOiAncG9pbnRlcicsXG4gICAgICAgIGhlaWdodDogZ2V0RG9jdW1lbnRIZWlnaHQoKSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogbW91c2VPdmVyU3BvdGxpZ2h0ID8gJ25vbmUnIDogJ2F1dG8nXG4gICAgICB9LCBiYXNlU3R5bGVzKTtcblxuICAgICAgdmFyIHNwb3RsaWdodCA9IHBsYWNlbWVudCAhPT0gJ2NlbnRlcicgJiYgc2hvd1Nwb3RsaWdodCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKb3lyaWRlU3BvdGxpZ2h0LCB7XG4gICAgICAgIHN0eWxlczogdGhpcy5zcG90bGlnaHRTdHlsZXNcbiAgICAgIH0pOyAvLyBIYWNrIGZvciBTYWZhcmkgYnVnIHdpdGggbWl4LWJsZW5kLW1vZGUgd2l0aCB6LWluZGV4XG5cbiAgICAgIGlmIChnZXRCcm93c2VyKCkgPT09ICdzYWZhcmknKSB7XG4gICAgICAgIHN0eWxlc092ZXJsYXkubWl4QmxlbmRNb2RlO1xuICAgICAgICAgICAgc3R5bGVzT3ZlcmxheS56SW5kZXg7XG4gICAgICAgICAgICB2YXIgc2FmYXJPdmVybGF5ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHN0eWxlc092ZXJsYXksIF9leGNsdWRlZCQyKTtcblxuICAgICAgICBzcG90bGlnaHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyKHt9LCBzYWZhck92ZXJsYXkpXG4gICAgICAgIH0sIHNwb3RsaWdodCk7XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNPdmVybGF5LmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVfX292ZXJsYXlcIixcbiAgICAgICAgc3R5bGU6IHN0eWxlc092ZXJsYXksXG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2tPdmVybGF5XG4gICAgICB9LCBzcG90bGlnaHQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKb3lyaWRlT3ZlcmxheTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIF9leGNsdWRlZCQxID0gW1wic3R5bGVzXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjb2xvclwiLCBcImhlaWdodFwiLCBcIndpZHRoXCJdO1xuXG5mdW5jdGlvbiBKb3lyaWRlVG9vbHRpcENsb3NlQnRuKF9yZWYpIHtcbiAgdmFyIHN0eWxlcyA9IF9yZWYuc3R5bGVzLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuXG4gIHZhciBjb2xvciA9IHN0eWxlcy5jb2xvcixcbiAgICAgIGhlaWdodCA9IHN0eWxlcy5oZWlnaHQsXG4gICAgICB3aWR0aCA9IHN0eWxlcy53aWR0aCxcbiAgICAgIHN0eWxlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHN0eWxlcywgX2V4Y2x1ZGVkMik7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogdHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyA/IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpIDogd2lkdGgsXG4gICAgaGVpZ2h0OiB0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJyA/IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSA6IGhlaWdodCxcbiAgICB2aWV3Qm94OiBcIjAgMCAxOCAxOFwiLFxuICAgIHZlcnNpb246IFwiMS4xXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcInhNaWRZTWlkXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNOC4xMzkxMTEyOSw5LjAwMjY4MTkxIEwwLjE3MTUyMTgyNywxNy4wMjU4NDY3IEMtMC4wNDk4MDI3MDQ5LDE3LjI0ODcxNSAtMC4wNDk4MDI3MDQ5LDE3LjYwOTgzOTQgMC4xNzE1MjE4MjcsMTcuODMyNzU0NSBDMC4yODIwNDM1NCwxNy45NDQzNTI2IDAuNDI3MTg4MjA2LDE3Ljk5OTg3MDYgMC41NzIwNTE3NjUsMTcuOTk5ODcwNiBDMC43MTcxNDk1OCwxNy45OTk4NzA2IDAuODYyMDEzMTM5LDE3Ljk0NDM1MjYgMC45NzI1ODE3MDMsMTcuODMyNzU0NSBMOS4wMDAwOTM3LDkuNzQ5MjQ2MTggTDE3LjAyNzYwNTcsMTcuODMyNzU0NSBDMTcuMTM4NDA4NSwxNy45NDQzNTI2IDE3LjI4MzI3MjEsMTcuOTk5ODcwNiAxNy40MjgxMzU2LDE3Ljk5OTg3MDYgQzE3LjU3Mjk5OTIsMTcuOTk5ODcwNiAxNy43MTgwOTcsMTcuOTQ0MzUyNiAxNy44Mjg2NjU2LDE3LjgzMjc1NDUgQzE4LjA0OTk5MDEsMTcuNjA5ODg2MiAxOC4wNDk5OTAxLDE3LjI0ODc2MTggMTcuODI4NjY1NiwxNy4wMjU4NDY3IEw5Ljg2MTM1NzIyLDkuMDAyNjgxOTEgTDE3LjgzNDAwNjYsMC45NzM4NDgyMjUgQzE4LjA1NTMzMTEsMC43NTA5Nzk5MzQgMTguMDU1MzMxMSwwLjM4OTg1NTUzMiAxNy44MzQwMDY2LDAuMTY2OTQwMzkgQzE3LjYxMjY4MjEsLTAuMDU1NjQ2Nzk2OCAxNy4yNTQwMzcsLTAuMDU1NjQ2Nzk2OCAxNy4wMzI5NDY3LDAuMTY2OTQwMzkgTDkuMDAwNDIxNjYsOC4yNTYxMTc2NSBMMC45NjcwMDY0MjQsMC4xNjcyNjgzNDUgQzAuNzQ1NjgxODkyLC0wLjA1NTMxODg0MjYgMC4zODczMTc5MzEsLTAuMDU1MzE4ODQyNiAwLjE2NTk5MzM5OSwwLjE2NzI2ODM0NSBDLTAuMDU1MzMxMTMzMSwwLjM5MDEzNjYzNSAtMC4wNTUzMzExMzMxLDAuNzUxMjYxMDM4IDAuMTY1OTkzMzk5LDAuOTc0MTc2MTc5IEw4LjEzOTIwNDk5LDkuMDAyNjgxOTEgTDguMTM5MTExMjksOS4wMDI2ODE5MSBaXCIsXG4gICAgZmlsbDogY29sb3JcbiAgfSkpKSk7XG59XG5cbnZhciBKb3lyaWRlVG9vbHRpcENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSm95cmlkZVRvb2x0aXBDb250YWluZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSm95cmlkZVRvb2x0aXBDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIEpveXJpZGVUb29sdGlwQ29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKb3lyaWRlVG9vbHRpcENvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSm95cmlkZVRvb2x0aXBDb250YWluZXIsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGJhY2tQcm9wcyA9IF90aGlzJHByb3BzLmJhY2tQcm9wcyxcbiAgICAgICAgICBjbG9zZVByb3BzID0gX3RoaXMkcHJvcHMuY2xvc2VQcm9wcyxcbiAgICAgICAgICBjb250aW51b3VzID0gX3RoaXMkcHJvcHMuY29udGludW91cyxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJHByb3BzLmluZGV4LFxuICAgICAgICAgIGlzTGFzdFN0ZXAgPSBfdGhpcyRwcm9wcy5pc0xhc3RTdGVwLFxuICAgICAgICAgIHByaW1hcnlQcm9wcyA9IF90aGlzJHByb3BzLnByaW1hcnlQcm9wcyxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMuc2l6ZSxcbiAgICAgICAgICBza2lwUHJvcHMgPSBfdGhpcyRwcm9wcy5za2lwUHJvcHMsXG4gICAgICAgICAgc3RlcCA9IF90aGlzJHByb3BzLnN0ZXAsXG4gICAgICAgICAgdG9vbHRpcFByb3BzID0gX3RoaXMkcHJvcHMudG9vbHRpcFByb3BzO1xuICAgICAgdmFyIGNvbnRlbnQgPSBzdGVwLmNvbnRlbnQsXG4gICAgICAgICAgaGlkZUJhY2tCdXR0b24gPSBzdGVwLmhpZGVCYWNrQnV0dG9uLFxuICAgICAgICAgIGhpZGVDbG9zZUJ1dHRvbiA9IHN0ZXAuaGlkZUNsb3NlQnV0dG9uLFxuICAgICAgICAgIGhpZGVGb290ZXIgPSBzdGVwLmhpZGVGb290ZXIsXG4gICAgICAgICAgc2hvd1Byb2dyZXNzID0gc3RlcC5zaG93UHJvZ3Jlc3MsXG4gICAgICAgICAgc2hvd1NraXBCdXR0b24gPSBzdGVwLnNob3dTa2lwQnV0dG9uLFxuICAgICAgICAgIHRpdGxlID0gc3RlcC50aXRsZSxcbiAgICAgICAgICBzdHlsZXMgPSBzdGVwLnN0eWxlcztcbiAgICAgIHZhciBfc3RlcCRsb2NhbGUgPSBzdGVwLmxvY2FsZSxcbiAgICAgICAgICBiYWNrID0gX3N0ZXAkbG9jYWxlLmJhY2ssXG4gICAgICAgICAgY2xvc2UgPSBfc3RlcCRsb2NhbGUuY2xvc2UsXG4gICAgICAgICAgbGFzdCA9IF9zdGVwJGxvY2FsZS5sYXN0LFxuICAgICAgICAgIG5leHQgPSBfc3RlcCRsb2NhbGUubmV4dCxcbiAgICAgICAgICBza2lwID0gX3N0ZXAkbG9jYWxlLnNraXA7XG4gICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICBwcmltYXJ5OiBjbG9zZVxuICAgICAgfTtcblxuICAgICAgaWYgKGNvbnRpbnVvdXMpIHtcbiAgICAgICAgb3V0cHV0LnByaW1hcnkgPSBpc0xhc3RTdGVwID8gbGFzdCA6IG5leHQ7XG5cbiAgICAgICAgaWYgKHNob3dQcm9ncmVzcykge1xuICAgICAgICAgIG91dHB1dC5wcmltYXJ5ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIG91dHB1dC5wcmltYXJ5LCBcIiAoXCIsIGluZGV4ICsgMSwgXCIvXCIsIHNpemUsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd1NraXBCdXR0b24gJiYgIWlzTGFzdFN0ZXApIHtcbiAgICAgICAgb3V0cHV0LnNraXAgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgc3R5bGU6IHN0eWxlcy5idXR0b25Ta2lwLFxuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJvZmZcIlxuICAgICAgICB9LCBza2lwUHJvcHMpLCBza2lwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoaWRlQmFja0J1dHRvbiAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgb3V0cHV0LmJhY2sgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgc3R5bGU6IHN0eWxlcy5idXR0b25CYWNrLFxuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgfSwgYmFja1Byb3BzKSwgYmFjayk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5jbG9zZSA9ICFoaWRlQ2xvc2VCdXR0b24gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSm95cmlkZVRvb2x0aXBDbG9zZUJ0biwgX2V4dGVuZHMoe1xuICAgICAgICBzdHlsZXM6IHN0eWxlcy5idXR0b25DbG9zZVxuICAgICAgfSwgY2xvc2VQcm9wcykpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiBcIkpveXJpZGVUb29sdGlwXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX190b29sdGlwXCIsXG4gICAgICAgIHN0eWxlOiBzdHlsZXMudG9vbHRpcFxuICAgICAgfSwgdG9vbHRpcFByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRvb2x0aXBDb250YWluZXJcbiAgICAgIH0sIHRpdGxlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRvb2x0aXBUaXRsZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRpdGxlXG4gICAgICB9LCB0aXRsZSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy50b29sdGlwQ29udGVudFxuICAgICAgfSwgY29udGVudCkpLCAhaGlkZUZvb3RlciAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMudG9vbHRpcEZvb3RlclxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRvb2x0aXBGb290ZXJTcGFjZXJcbiAgICAgIH0sIG91dHB1dC5za2lwKSwgb3V0cHV0LmJhY2ssIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5idXR0b25OZXh0LFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICB9LCBwcmltYXJ5UHJvcHMpLCBvdXRwdXQucHJpbWFyeSkpLCBvdXRwdXQuY2xvc2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKb3lyaWRlVG9vbHRpcENvbnRhaW5lcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIF9leGNsdWRlZCA9IFtcImJlYWNvbkNvbXBvbmVudFwiLCBcInRvb2x0aXBDb21wb25lbnRcIl07XG5cbnZhciBKb3lyaWRlVG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSm95cmlkZVRvb2x0aXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSm95cmlkZVRvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIEpveXJpZGVUb29sdGlwKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKb3lyaWRlVG9vbHRpcCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZUNsaWNrQmFja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGhlbHBlcnMgPSBfdGhpcy5wcm9wcy5oZWxwZXJzO1xuICAgICAgaGVscGVycy5wcmV2KCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2xpY2tDbG9zZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGhlbHBlcnMgPSBfdGhpcy5wcm9wcy5oZWxwZXJzO1xuICAgICAgaGVscGVycy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZUNsaWNrUHJpbWFyeVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgY29udGludW91cyA9IF90aGlzJHByb3BzLmNvbnRpbnVvdXMsXG4gICAgICAgICAgaGVscGVycyA9IF90aGlzJHByb3BzLmhlbHBlcnM7XG5cbiAgICAgIGlmICghY29udGludW91cykge1xuICAgICAgICBoZWxwZXJzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaGVscGVycy5uZXh0KCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2xpY2tTa2lwXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgaGVscGVycyA9IF90aGlzLnByb3BzLmhlbHBlcnM7XG4gICAgICBoZWxwZXJzLnNraXAoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRFbGVtZW50c1Byb3BzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb250aW51b3VzID0gX3RoaXMkcHJvcHMyLmNvbnRpbnVvdXMsXG4gICAgICAgICAgaXNMYXN0U3RlcCA9IF90aGlzJHByb3BzMi5pc0xhc3RTdGVwLFxuICAgICAgICAgIHNldFRvb2x0aXBSZWYgPSBfdGhpcyRwcm9wczIuc2V0VG9vbHRpcFJlZixcbiAgICAgICAgICBzdGVwID0gX3RoaXMkcHJvcHMyLnN0ZXA7XG4gICAgICB2YXIgYmFjayA9IGdldFRleHQoc3RlcC5sb2NhbGUuYmFjayk7XG4gICAgICB2YXIgY2xvc2UgPSBnZXRUZXh0KHN0ZXAubG9jYWxlLmNsb3NlKTtcbiAgICAgIHZhciBsYXN0ID0gZ2V0VGV4dChzdGVwLmxvY2FsZS5sYXN0KTtcbiAgICAgIHZhciBuZXh0ID0gZ2V0VGV4dChzdGVwLmxvY2FsZS5uZXh0KTtcbiAgICAgIHZhciBza2lwID0gZ2V0VGV4dChzdGVwLmxvY2FsZS5za2lwKTtcbiAgICAgIHZhciBwcmltYXJ5VGV4dCA9IGNvbnRpbnVvdXMgPyBuZXh0IDogY2xvc2U7XG5cbiAgICAgIGlmIChpc0xhc3RTdGVwKSB7XG4gICAgICAgIHByaW1hcnlUZXh0ID0gbGFzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja1Byb3BzOiB7XG4gICAgICAgICAgJ2FyaWEtbGFiZWwnOiBiYWNrLFxuICAgICAgICAgICdkYXRhLWFjdGlvbic6ICdiYWNrJyxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpcy5oYW5kbGVDbGlja0JhY2ssXG4gICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgdGl0bGU6IGJhY2tcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VQcm9wczoge1xuICAgICAgICAgICdhcmlhLWxhYmVsJzogY2xvc2UsXG4gICAgICAgICAgJ2RhdGEtYWN0aW9uJzogJ2Nsb3NlJyxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpcy5oYW5kbGVDbGlja0Nsb3NlLFxuICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgIHRpdGxlOiBjbG9zZVxuICAgICAgICB9LFxuICAgICAgICBwcmltYXJ5UHJvcHM6IHtcbiAgICAgICAgICAnYXJpYS1sYWJlbCc6IHByaW1hcnlUZXh0LFxuICAgICAgICAgICdkYXRhLWFjdGlvbic6ICdwcmltYXJ5JyxcbiAgICAgICAgICBvbkNsaWNrOiBfdGhpcy5oYW5kbGVDbGlja1ByaW1hcnksXG4gICAgICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAgICAgdGl0bGU6IHByaW1hcnlUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIHNraXBQcm9wczoge1xuICAgICAgICAgICdhcmlhLWxhYmVsJzogc2tpcCxcbiAgICAgICAgICAnZGF0YS1hY3Rpb24nOiAnc2tpcCcsXG4gICAgICAgICAgb25DbGljazogX3RoaXMuaGFuZGxlQ2xpY2tTa2lwLFxuICAgICAgICAgIHJvbGU6ICdidXR0b24nLFxuICAgICAgICAgIHRpdGxlOiBza2lwXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXBQcm9wczoge1xuICAgICAgICAgICdhcmlhLW1vZGFsJzogdHJ1ZSxcbiAgICAgICAgICByZWY6IHNldFRvb2x0aXBSZWYsXG4gICAgICAgICAgcm9sZTogJ2FsZXJ0ZGlhbG9nJ1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpveXJpZGVUb29sdGlwLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29udGludW91cyA9IF90aGlzJHByb3BzMy5jb250aW51b3VzLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkcHJvcHMzLmluZGV4LFxuICAgICAgICAgIGlzTGFzdFN0ZXAgPSBfdGhpcyRwcm9wczMuaXNMYXN0U3RlcCxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMzLnNpemUsXG4gICAgICAgICAgc3RlcCA9IF90aGlzJHByb3BzMy5zdGVwO1xuXG4gICAgICBzdGVwLmJlYWNvbkNvbXBvbmVudDtcbiAgICAgICAgICB2YXIgdG9vbHRpcENvbXBvbmVudCA9IHN0ZXAudG9vbHRpcENvbXBvbmVudCxcbiAgICAgICAgICBjbGVhblN0ZXAgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3RlcCwgX2V4Y2x1ZGVkKTtcblxuICAgICAgdmFyIGNvbXBvbmVudDtcblxuICAgICAgaWYgKHRvb2x0aXBDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHJlbmRlclByb3BzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuZ2V0RWxlbWVudHNQcm9wcygpKSwge30sIHtcbiAgICAgICAgICBjb250aW51b3VzOiBjb250aW51b3VzLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBpc0xhc3RTdGVwOiBpc0xhc3RTdGVwLFxuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgc3RlcDogY2xlYW5TdGVwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBUb29sdGlwQ29tcG9uZW50ID0gdG9vbHRpcENvbXBvbmVudDtcbiAgICAgICAgY29tcG9uZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcENvbXBvbmVudCwgcmVuZGVyUHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSm95cmlkZVRvb2x0aXBDb250YWluZXIsIF9leHRlbmRzKHt9LCB0aGlzLmdldEVsZW1lbnRzUHJvcHMoKSwge1xuICAgICAgICAgIGNvbnRpbnVvdXM6IGNvbnRpbnVvdXMsXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIGlzTGFzdFN0ZXA6IGlzTGFzdFN0ZXAsXG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSm95cmlkZVRvb2x0aXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBKb3lyaWRlUG9ydGFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhKb3lyaWRlUG9ydGFsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEpveXJpZGVQb3J0YWwpO1xuXG4gIGZ1bmN0aW9uIEpveXJpZGVQb3J0YWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpveXJpZGVQb3J0YWwpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpveXJpZGVQb3J0YWwsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKCFjYW5Vc2VET00pIHJldHVybjtcblxuICAgICAgaWYgKCFpc1JlYWN0MTYpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSZWFjdDE1KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICBpZiAoIWNhblVzZURPTSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIWlzUmVhY3QxNikge1xuICAgICAgICB0aGlzLnJlbmRlclJlYWN0MTUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAoIWNhblVzZURPTSB8fCAhdGhpcy5ub2RlKSByZXR1cm47XG5cbiAgICAgIGlmICghaXNSZWFjdDE2KSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubm9kZS5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZE5vZGUoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLnByb3BzLmlkO1xuXG4gICAgICBpZiAoIXRoaXMubm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUmVhY3QxNVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJSZWFjdDE1KCkge1xuICAgICAgaWYgKCFjYW5Vc2VET00pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmROb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIFJlYWN0RE9NLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHRoaXMsIGNoaWxkcmVuLCB0aGlzLm5vZGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclJlYWN0MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUmVhY3QxNigpIHtcbiAgICAgIGlmICghY2FuVXNlRE9NIHx8ICFpc1JlYWN0MTYpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmROb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RET00uY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB0aGlzLm5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgaWYgKCFpc1JlYWN0MTYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlYWN0MTYoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSm95cmlkZVBvcnRhbDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIEpveXJpZGVTdGVwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhKb3lyaWRlU3RlcCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihKb3lyaWRlU3RlcCk7XG5cbiAgZnVuY3Rpb24gSm95cmlkZVN0ZXAoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpveXJpZGVTdGVwKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2NvcGVcIiwge1xuICAgICAgcmVtb3ZlU2NvcGU6IGZ1bmN0aW9uIHJlbW92ZVNjb3BlKCkge31cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVDbGlja0hvdmVyQmVhY29uXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBzdGVwID0gX3RoaXMkcHJvcHMuc3RlcCxcbiAgICAgICAgICB1cGRhdGUgPSBfdGhpcyRwcm9wcy51cGRhdGU7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiBzdGVwLmV2ZW50ICE9PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuVE9PTFRJUFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2xpY2tPdmVybGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBoZWxwZXJzID0gX3RoaXMkcHJvcHMyLmhlbHBlcnMsXG4gICAgICAgICAgc3RlcCA9IF90aGlzJHByb3BzMi5zdGVwO1xuXG4gICAgICBpZiAoIXN0ZXAuZGlzYWJsZU92ZXJsYXlDbG9zZSkge1xuICAgICAgICBoZWxwZXJzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0VG9vbHRpcFJlZlwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgX3RoaXMudG9vbHRpcCA9IGM7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0UG9wcGVyXCIsIGZ1bmN0aW9uIChwb3BwZXIsIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBhY3Rpb24gPSBfdGhpcyRwcm9wczMuYWN0aW9uLFxuICAgICAgICAgIHNldFBvcHBlciA9IF90aGlzJHByb3BzMy5zZXRQb3BwZXIsXG4gICAgICAgICAgdXBkYXRlID0gX3RoaXMkcHJvcHMzLnVwZGF0ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICd3cmFwcGVyJykge1xuICAgICAgICBfdGhpcy5iZWFjb25Qb3BwZXIgPSBwb3BwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50b29sdGlwUG9wcGVyID0gcG9wcGVyO1xuICAgICAgfVxuXG4gICAgICBzZXRQb3BwZXIocG9wcGVyLCB0eXBlKTtcblxuICAgICAgaWYgKF90aGlzLmJlYWNvblBvcHBlciAmJiBfdGhpcy50b29sdGlwUG9wcGVyKSB7XG4gICAgICAgIHVwZGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24gPT09IEFDVElPTlMuQ0xPU0UgPyBBQ1RJT05TLkNMT1NFIDogYWN0aW9uLFxuICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLlJFQURZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpveXJpZGVTdGVwLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRlYnVnID0gX3RoaXMkcHJvcHM0LmRlYnVnLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkcHJvcHM0LmluZGV4O1xuICAgICAgbG9nKHtcbiAgICAgICAgdGl0bGU6IFwic3RlcDpcIi5jb25jYXQoaW5kZXgpLFxuICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgIGtleTogJ3Byb3BzJyxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5wcm9wc1xuICAgICAgICB9XSxcbiAgICAgICAgZGVidWc6IGRlYnVnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGFjdGlvbiA9IF90aGlzJHByb3BzNS5hY3Rpb24sXG4gICAgICAgICAgY2FsbGJhY2sgPSBfdGhpcyRwcm9wczUuY2FsbGJhY2ssXG4gICAgICAgICAgY29udGludW91cyA9IF90aGlzJHByb3BzNS5jb250aW51b3VzLFxuICAgICAgICAgIGNvbnRyb2xsZWQgPSBfdGhpcyRwcm9wczUuY29udHJvbGxlZCxcbiAgICAgICAgICBkZWJ1ZyA9IF90aGlzJHByb3BzNS5kZWJ1ZyxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJHByb3BzNS5pbmRleCxcbiAgICAgICAgICBsaWZlY3ljbGUgPSBfdGhpcyRwcm9wczUubGlmZWN5Y2xlLFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wczUuc2l6ZSxcbiAgICAgICAgICBzdGF0dXMgPSBfdGhpcyRwcm9wczUuc3RhdHVzLFxuICAgICAgICAgIHN0ZXAgPSBfdGhpcyRwcm9wczUuc3RlcCxcbiAgICAgICAgICB1cGRhdGUgPSBfdGhpcyRwcm9wczUudXBkYXRlO1xuXG4gICAgICB2YXIgX3RyZWVDaGFuZ2VzID0gdHJlZUNoYW5nZXMocHJldlByb3BzLCB0aGlzLnByb3BzKSxcbiAgICAgICAgICBjaGFuZ2VkID0gX3RyZWVDaGFuZ2VzLmNoYW5nZWQsXG4gICAgICAgICAgY2hhbmdlZEZyb20gPSBfdHJlZUNoYW5nZXMuY2hhbmdlZEZyb207XG5cbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGNvbnRyb2xsZWQ6IGNvbnRyb2xsZWQsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbGlmZWN5Y2xlOiBsaWZlY3ljbGUsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICB9O1xuICAgICAgdmFyIHNraXBCZWFjb24gPSBjb250aW51b3VzICYmIGFjdGlvbiAhPT0gQUNUSU9OUy5DTE9TRSAmJiAoaW5kZXggPiAwIHx8IGFjdGlvbiA9PT0gQUNUSU9OUy5QUkVWKTtcbiAgICAgIHZhciBoYXNTdG9yZUNoYW5nZWQgPSBjaGFuZ2VkKCdhY3Rpb24nKSB8fCBjaGFuZ2VkKCdpbmRleCcpIHx8IGNoYW5nZWQoJ2xpZmVjeWNsZScpIHx8IGNoYW5nZWQoJ3N0YXR1cycpO1xuICAgICAgdmFyIGhhc1N0YXJ0ZWQgPSBjaGFuZ2VkRnJvbSgnbGlmZWN5Y2xlJywgW0xJRkVDWUNMRS5UT09MVElQLCBMSUZFQ1lDTEUuSU5JVF0sIExJRkVDWUNMRS5JTklUKTtcbiAgICAgIHZhciBpc0FmdGVyQWN0aW9uID0gY2hhbmdlZCgnYWN0aW9uJywgW0FDVElPTlMuTkVYVCwgQUNUSU9OUy5QUkVWLCBBQ1RJT05TLlNLSVAsIEFDVElPTlMuQ0xPU0VdKTtcblxuICAgICAgaWYgKGlzQWZ0ZXJBY3Rpb24gJiYgKGhhc1N0YXJ0ZWQgfHwgY29udHJvbGxlZCkpIHtcbiAgICAgICAgY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgICBpbmRleDogcHJldlByb3BzLmluZGV4LFxuICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLkNPTVBMRVRFLFxuICAgICAgICAgIHN0ZXA6IHByZXZQcm9wcy5zdGVwLFxuICAgICAgICAgIHR5cGU6IEVWRU5UUy5TVEVQX0FGVEVSXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAucGxhY2VtZW50ID09PSAnY2VudGVyJyAmJiBzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HICYmIGNoYW5nZWQoJ2luZGV4JykgJiYgYWN0aW9uICE9PSBBQ1RJT05TLlNUQVJUICYmIGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLklOSVQpIHtcbiAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5SRUFEWVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gVGhlcmUncyBhIHN0ZXAgdG8gdXNlLCBidXQgdGhlcmUncyBubyB0YXJnZXQgaW4gdGhlIERPTVxuXG5cbiAgICAgIGlmIChoYXNTdG9yZUNoYW5nZWQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50KHN0ZXAudGFyZ2V0KTtcbiAgICAgICAgdmFyIGVsZW1lbnRFeGlzdHMgPSAhIWVsZW1lbnQ7XG4gICAgICAgIHZhciBoYXNSZW5kZXJlZFRhcmdldCA9IGVsZW1lbnRFeGlzdHMgJiYgaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KTtcblxuICAgICAgICBpZiAoaGFzUmVuZGVyZWRUYXJnZXQpIHtcbiAgICAgICAgICBpZiAoY2hhbmdlZEZyb20oJ3N0YXR1cycsIFNUQVRVUy5SRUFEWSwgU1RBVFVTLlJVTk5JTkcpIHx8IGNoYW5nZWRGcm9tKCdsaWZlY3ljbGUnLCBMSUZFQ1lDTEUuSU5JVCwgTElGRUNZQ0xFLlJFQURZKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICAgICAgdHlwZTogRVZFTlRTLlNURVBfQkVGT1JFXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihlbGVtZW50RXhpc3RzID8gJ1RhcmdldCBub3QgdmlzaWJsZScgOiAnVGFyZ2V0IG5vdCBtb3VudGVkJywgc3RlcCk7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgICAgICBjYWxsYmFjayhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc3RhdGUpLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogRVZFTlRTLlRBUkdFVF9OT1RfRk9VTkQsXG4gICAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKCFjb250cm9sbGVkKSB7XG4gICAgICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXggKyAoW0FDVElPTlMuUFJFVl0uaW5kZXhPZihhY3Rpb24pICE9PSAtMSA/IC0xIDogMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZEZyb20oJ2xpZmVjeWNsZScsIExJRkVDWUNMRS5JTklULCBMSUZFQ1lDTEUuUkVBRFkpKSB7XG4gICAgICAgIHVwZGF0ZSh7XG4gICAgICAgICAgbGlmZWN5Y2xlOiBoaWRlQmVhY29uKHN0ZXApIHx8IHNraXBCZWFjb24gPyBMSUZFQ1lDTEUuVE9PTFRJUCA6IExJRkVDWUNMRS5CRUFDT05cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKCdpbmRleCcpKSB7XG4gICAgICAgIGxvZyh7XG4gICAgICAgICAgdGl0bGU6IFwic3RlcDpcIi5jb25jYXQobGlmZWN5Y2xlKSxcbiAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAga2V5OiAncHJvcHMnLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucHJvcHNcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBkZWJ1ZzogZGVidWdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG5cbiAgICAgIGlmIChjaGFuZ2VkKCdsaWZlY3ljbGUnLCBMSUZFQ1lDTEUuQkVBQ09OKSkge1xuICAgICAgICBjYWxsYmFjayhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc3RhdGUpLCB7fSwge1xuICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgdHlwZTogRVZFTlRTLkJFQUNPTlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKCdsaWZlY3ljbGUnLCBMSUZFQ1lDTEUuVE9PTFRJUCkpIHtcbiAgICAgICAgY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgIHR5cGU6IEVWRU5UUy5UT09MVElQXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZSh0aGlzLnRvb2x0aXAsIHtcbiAgICAgICAgICBzZWxlY3RvcjogJ1tkYXRhLWFjdGlvbj1wcmltYXJ5XSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NvcGUuc2V0Rm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRGcm9tKCdsaWZlY3ljbGUnLCBbTElGRUNZQ0xFLlRPT0xUSVAsIExJRkVDWUNMRS5JTklUXSwgTElGRUNZQ0xFLklOSVQpKSB7XG4gICAgICAgIHRoaXMuc2NvcGUucmVtb3ZlU2NvcGUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYmVhY29uUG9wcGVyO1xuICAgICAgICBkZWxldGUgdGhpcy50b29sdGlwUG9wcGVyO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuc2NvcGUucmVtb3ZlU2NvcGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVhY29uIGNsaWNrL2hvdmVyIGV2ZW50IGxpc3RlbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcGVuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBzdGVwID0gX3RoaXMkcHJvcHM2LnN0ZXAsXG4gICAgICAgICAgbGlmZWN5Y2xlID0gX3RoaXMkcHJvcHM2LmxpZmVjeWNsZTtcbiAgICAgIHJldHVybiAhIShoaWRlQmVhY29uKHN0ZXApIHx8IGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29udGludW91cyA9IF90aGlzJHByb3BzNy5jb250aW51b3VzLFxuICAgICAgICAgIGRlYnVnID0gX3RoaXMkcHJvcHM3LmRlYnVnLFxuICAgICAgICAgIGhlbHBlcnMgPSBfdGhpcyRwcm9wczcuaGVscGVycyxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJHByb3BzNy5pbmRleCxcbiAgICAgICAgICBsaWZlY3ljbGUgPSBfdGhpcyRwcm9wczcubGlmZWN5Y2xlLFxuICAgICAgICAgIG5vbmNlID0gX3RoaXMkcHJvcHM3Lm5vbmNlLFxuICAgICAgICAgIHNob3VsZFNjcm9sbCA9IF90aGlzJHByb3BzNy5zaG91bGRTY3JvbGwsXG4gICAgICAgICAgc2l6ZSA9IF90aGlzJHByb3BzNy5zaXplLFxuICAgICAgICAgIHN0ZXAgPSBfdGhpcyRwcm9wczcuc3RlcDtcbiAgICAgIHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KHN0ZXAudGFyZ2V0KTtcblxuICAgICAgaWYgKCF2YWxpZGF0ZVN0ZXAoc3RlcCkgfHwgIWlzLmRvbUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcIkpveXJpZGVTdGVwLVwiLmNvbmNhdChpbmRleCksXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1qb3lyaWRlX19zdGVwXCJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpveXJpZGVQb3J0YWwsIHtcbiAgICAgICAgaWQ6IFwicmVhY3Qtam95cmlkZS1wb3J0YWxcIlxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSm95cmlkZU92ZXJsYXksIF9leHRlbmRzKHt9LCBzdGVwLCB7XG4gICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgbGlmZWN5Y2xlOiBsaWZlY3ljbGUsXG4gICAgICAgIG9uQ2xpY2tPdmVybGF5OiB0aGlzLmhhbmRsZUNsaWNrT3ZlcmxheVxuICAgICAgfSkpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRlciwgX2V4dGVuZHMoe1xuICAgICAgICBjb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpveXJpZGVUb29sdGlwLCB7XG4gICAgICAgICAgY29udGludW91czogY29udGludW91cyxcbiAgICAgICAgICBoZWxwZXJzOiBoZWxwZXJzLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBpc0xhc3RTdGVwOiBpbmRleCArIDEgPT09IHNpemUsXG4gICAgICAgICAgc2V0VG9vbHRpcFJlZjogdGhpcy5zZXRUb29sdGlwUmVmLFxuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgc3RlcDogc3RlcFxuICAgICAgICB9KSxcbiAgICAgICAgZGVidWc6IGRlYnVnLFxuICAgICAgICBnZXRQb3BwZXI6IHRoaXMuc2V0UG9wcGVyLFxuICAgICAgICBpZDogXCJyZWFjdC1qb3lyaWRlLXN0ZXAtXCIuY29uY2F0KGluZGV4KSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBzdGVwLmlzRml4ZWQgfHwgaGFzUG9zaXRpb24odGFyZ2V0KSxcbiAgICAgICAgb3BlbjogdGhpcy5vcGVuLFxuICAgICAgICBwbGFjZW1lbnQ6IHN0ZXAucGxhY2VtZW50LFxuICAgICAgICB0YXJnZXQ6IHN0ZXAudGFyZ2V0XG4gICAgICB9LCBzdGVwLmZsb2F0ZXJQcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpveXJpZGVCZWFjb24sIHtcbiAgICAgICAgYmVhY29uQ29tcG9uZW50OiBzdGVwLmJlYWNvbkNvbXBvbmVudCxcbiAgICAgICAgbG9jYWxlOiBzdGVwLmxvY2FsZSxcbiAgICAgICAgbm9uY2U6IG5vbmNlLFxuICAgICAgICBvbkNsaWNrT3JIb3ZlcjogdGhpcy5oYW5kbGVDbGlja0hvdmVyQmVhY29uLFxuICAgICAgICBzaG91bGRGb2N1czogc2hvdWxkU2Nyb2xsLFxuICAgICAgICBzdHlsZXM6IHN0ZXAuc3R5bGVzXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKb3lyaWRlU3RlcDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIEpveXJpZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEpveXJpZGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSm95cmlkZSk7XG5cbiAgZnVuY3Rpb24gSm95cmlkZShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKb3lyaWRlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImluaXRTdG9yZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBkZWJ1ZyA9IF90aGlzJHByb3BzLmRlYnVnLFxuICAgICAgICAgIGdldEhlbHBlcnMgPSBfdGhpcyRwcm9wcy5nZXRIZWxwZXJzLFxuICAgICAgICAgIHJ1biA9IF90aGlzJHByb3BzLnJ1bixcbiAgICAgICAgICBzdGVwSW5kZXggPSBfdGhpcyRwcm9wcy5zdGVwSW5kZXg7XG4gICAgICBfdGhpcy5zdG9yZSA9IG5ldyBjcmVhdGVTdG9yZShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMucHJvcHMpLCB7fSwge1xuICAgICAgICBjb250cm9sbGVkOiBydW4gJiYgaXMubnVtYmVyKHN0ZXBJbmRleClcbiAgICAgIH0pKTtcbiAgICAgIF90aGlzLmhlbHBlcnMgPSBfdGhpcy5zdG9yZS5nZXRIZWxwZXJzKCk7XG4gICAgICB2YXIgYWRkTGlzdGVuZXIgPSBfdGhpcy5zdG9yZS5hZGRMaXN0ZW5lcjtcbiAgICAgIGxvZyh7XG4gICAgICAgIHRpdGxlOiAnaW5pdCcsXG4gICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAga2V5OiAncHJvcHMnLFxuICAgICAgICAgIHZhbHVlOiBfdGhpcy5wcm9wc1xuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiAnc3RhdGUnLFxuICAgICAgICAgIHZhbHVlOiBfdGhpcy5zdGF0ZVxuICAgICAgICB9XSxcbiAgICAgICAgZGVidWc6IGRlYnVnXG4gICAgICB9KTsgLy8gU3luYyB0aGUgc3RvcmUgdG8gdGhpcyBjb21wb25lbnQncyBzdGF0ZS5cblxuICAgICAgYWRkTGlzdGVuZXIoX3RoaXMuc3luY1N0YXRlKTtcbiAgICAgIGdldEhlbHBlcnMoX3RoaXMuaGVscGVycyk7XG4gICAgICByZXR1cm4gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjYWxsYmFja1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX3RoaXMucHJvcHMuY2FsbGJhY2s7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICBpZiAoaXNbXCJmdW5jdGlvblwiXShjYWxsYmFjaykpIHtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlS2V5Ym9hcmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkc3RhdGUuaW5kZXgsXG4gICAgICAgICAgbGlmZWN5Y2xlID0gX3RoaXMkc3RhdGUubGlmZWN5Y2xlO1xuICAgICAgdmFyIHN0ZXBzID0gX3RoaXMucHJvcHMuc3RlcHM7XG4gICAgICB2YXIgc3RlcCA9IHN0ZXBzW2luZGV4XTtcbiAgICAgIHZhciBpbnRLZXkgPSB3aW5kb3cuRXZlbnQgPyBlLndoaWNoIDogZS5rZXlDb2RlO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlID09PSBMSUZFQ1lDTEUuVE9PTFRJUCkge1xuICAgICAgICBpZiAoaW50S2V5ID09PSAyNyAmJiBzdGVwICYmICFzdGVwLmRpc2FibGVDbG9zZU9uRXNjKSB7XG4gICAgICAgICAgX3RoaXMuc3RvcmUuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN5bmNTdGF0ZVwiLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZXRQb3BwZXJcIiwgZnVuY3Rpb24gKHBvcHBlciwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICd3cmFwcGVyJykge1xuICAgICAgICBfdGhpcy5iZWFjb25Qb3BwZXIgPSBwb3BwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50b29sdGlwUG9wcGVyID0gcG9wcGVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNob3VsZFNjcm9sbFwiLCBmdW5jdGlvbiAoZGlzYWJsZVNjcm9sbGluZywgaW5kZXgsIHNjcm9sbFRvRmlyc3RTdGVwLCBsaWZlY3ljbGUsIHN0ZXAsIHRhcmdldCwgcHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gIWRpc2FibGVTY3JvbGxpbmcgJiYgKGluZGV4ICE9PSAwIHx8IHNjcm9sbFRvRmlyc3RTdGVwIHx8IGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVApICYmIHN0ZXAucGxhY2VtZW50ICE9PSAnY2VudGVyJyAmJiAoIXN0ZXAuaXNGaXhlZCB8fCAhaGFzUG9zaXRpb24odGFyZ2V0KSkgJiYgLy8gZml4ZWQgc3RlcHMgZG9uJ3QgbmVlZCB0byBzY3JvbGxcbiAgICAgIHByZXZTdGF0ZS5saWZlY3ljbGUgIT09IGxpZmVjeWNsZSAmJiBbTElGRUNZQ0xFLkJFQUNPTiwgTElGRUNZQ0xFLlRPT0xUSVBdLmluZGV4T2YobGlmZWN5Y2xlKSAhPT0gLTE7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmluaXRTdG9yZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKb3lyaWRlLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICghY2FuVXNlRE9NKSByZXR1cm47XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkaXNhYmxlQ2xvc2VPbkVzYyA9IF90aGlzJHByb3BzMi5kaXNhYmxlQ2xvc2VPbkVzYyxcbiAgICAgICAgICBkZWJ1ZyA9IF90aGlzJHByb3BzMi5kZWJ1ZyxcbiAgICAgICAgICBydW4gPSBfdGhpcyRwcm9wczIucnVuLFxuICAgICAgICAgIHN0ZXBzID0gX3RoaXMkcHJvcHMyLnN0ZXBzO1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZS5zdGFydDtcblxuICAgICAgaWYgKHZhbGlkYXRlU3RlcHMoc3RlcHMsIGRlYnVnKSAmJiBydW4pIHtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cblxuICAgICAgaWYgKCFkaXNhYmxlQ2xvc2VPbkVzYykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWJvYXJkLCB7XG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgaWYgKCFjYW5Vc2VET00pIHJldHVybjtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGFjdGlvbiA9IF90aGlzJHN0YXRlMi5hY3Rpb24sXG4gICAgICAgICAgY29udHJvbGxlZCA9IF90aGlzJHN0YXRlMi5jb250cm9sbGVkLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkc3RhdGUyLmluZGV4LFxuICAgICAgICAgIGxpZmVjeWNsZSA9IF90aGlzJHN0YXRlMi5saWZlY3ljbGUsXG4gICAgICAgICAgc3RhdHVzID0gX3RoaXMkc3RhdGUyLnN0YXR1cztcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRlYnVnID0gX3RoaXMkcHJvcHMzLmRlYnVnLFxuICAgICAgICAgIHJ1biA9IF90aGlzJHByb3BzMy5ydW4sXG4gICAgICAgICAgc3RlcEluZGV4ID0gX3RoaXMkcHJvcHMzLnN0ZXBJbmRleCxcbiAgICAgICAgICBzdGVwcyA9IF90aGlzJHByb3BzMy5zdGVwcztcbiAgICAgIHZhciBwcmV2U3RlcHMgPSBwcmV2UHJvcHMuc3RlcHMsXG4gICAgICAgICAgcHJldlN0ZXBJbmRleCA9IHByZXZQcm9wcy5zdGVwSW5kZXg7XG4gICAgICB2YXIgX3RoaXMkc3RvcmUgPSB0aGlzLnN0b3JlLFxuICAgICAgICAgIHJlc2V0ID0gX3RoaXMkc3RvcmUucmVzZXQsXG4gICAgICAgICAgc2V0U3RlcHMgPSBfdGhpcyRzdG9yZS5zZXRTdGVwcyxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJHN0b3JlLnN0YXJ0LFxuICAgICAgICAgIHN0b3AgPSBfdGhpcyRzdG9yZS5zdG9wLFxuICAgICAgICAgIHVwZGF0ZSA9IF90aGlzJHN0b3JlLnVwZGF0ZTtcblxuICAgICAgdmFyIF90cmVlQ2hhbmdlcyA9IHRyZWVDaGFuZ2VzKHByZXZQcm9wcywgdGhpcy5wcm9wcyksXG4gICAgICAgICAgY2hhbmdlZFByb3BzID0gX3RyZWVDaGFuZ2VzLmNoYW5nZWQ7XG5cbiAgICAgIHZhciBfdHJlZUNoYW5nZXMyID0gdHJlZUNoYW5nZXMocHJldlN0YXRlLCB0aGlzLnN0YXRlKSxcbiAgICAgICAgICBjaGFuZ2VkID0gX3RyZWVDaGFuZ2VzMi5jaGFuZ2VkLFxuICAgICAgICAgIGNoYW5nZWRGcm9tID0gX3RyZWVDaGFuZ2VzMi5jaGFuZ2VkRnJvbTtcblxuICAgICAgdmFyIHN0ZXAgPSBnZXRNZXJnZWRTdGVwKHN0ZXBzW2luZGV4XSwgdGhpcy5wcm9wcyk7XG4gICAgICB2YXIgc3RlcHNDaGFuZ2VkID0gIWlzRXF1YWwocHJldlN0ZXBzLCBzdGVwcyk7XG4gICAgICB2YXIgc3RlcEluZGV4Q2hhbmdlZCA9IGlzLm51bWJlcihzdGVwSW5kZXgpICYmIGNoYW5nZWRQcm9wcygnc3RlcEluZGV4Jyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChzdGVwID09PSBudWxsIHx8IHN0ZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXAudGFyZ2V0KTtcblxuICAgICAgaWYgKHN0ZXBzQ2hhbmdlZCkge1xuICAgICAgICBpZiAodmFsaWRhdGVTdGVwcyhzdGVwcywgZGVidWcpKSB7XG4gICAgICAgICAgc2V0U3RlcHMoc3RlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU3RlcHMgYXJlIG5vdCB2YWxpZCcsIHN0ZXBzKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuXG4gICAgICBpZiAoY2hhbmdlZFByb3BzKCdydW4nKSkge1xuICAgICAgICBpZiAocnVuKSB7XG4gICAgICAgICAgc3RhcnQoc3RlcEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cblxuICAgICAgaWYgKHN0ZXBJbmRleENoYW5nZWQpIHtcbiAgICAgICAgdmFyIG5leHRBY3Rpb24gPSBwcmV2U3RlcEluZGV4IDwgc3RlcEluZGV4ID8gQUNUSU9OUy5ORVhUIDogQUNUSU9OUy5QUkVWO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09IEFDVElPTlMuU1RPUCkge1xuICAgICAgICAgIG5leHRBY3Rpb24gPSBBQ1RJT05TLlNUQVJUO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoW1NUQVRVUy5GSU5JU0hFRCwgU1RBVFVTLlNLSVBQRURdLmluZGV4T2Yoc3RhdHVzKSAhPT0gLTEpKSB7XG4gICAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uID09PSBBQ1RJT05TLkNMT1NFID8gQUNUSU9OUy5DTE9TRSA6IG5leHRBY3Rpb24sXG4gICAgICAgICAgICBpbmRleDogc3RlcEluZGV4LFxuICAgICAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuSU5JVFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIFVwZGF0ZSB0aGUgaW5kZXggaWYgdGhlIGZpcnN0IHN0ZXAgaXMgbm90IGZvdW5kXG5cblxuICAgICAgaWYgKCFjb250cm9sbGVkICYmIHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcgJiYgaW5kZXggPT09IDAgJiYgIXRhcmdldCkge1xuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgIGluZGV4OiBpbmRleCArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc3RhdGUpLCB7fSwge1xuICAgICAgICAgIHR5cGU6IEVWRU5UUy5UQVJHRVRfTk9UX0ZPVU5ELFxuICAgICAgICAgIHN0ZXA6IHN0ZXBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FsbGJhY2tEYXRhID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc3RhdGUpLCB7fSwge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHN0ZXA6IHN0ZXBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaXNBZnRlckFjdGlvbiA9IGNoYW5nZWQoJ2FjdGlvbicsIFtBQ1RJT05TLk5FWFQsIEFDVElPTlMuUFJFViwgQUNUSU9OUy5TS0lQLCBBQ1RJT05TLkNMT1NFXSk7XG5cbiAgICAgIGlmIChpc0FmdGVyQWN0aW9uICYmIGNoYW5nZWQoJ3N0YXR1cycsIFNUQVRVUy5QQVVTRUQpKSB7XG4gICAgICAgIHZhciBwcmV2U3RlcCA9IGdldE1lcmdlZFN0ZXAoc3RlcHNbcHJldlN0YXRlLmluZGV4XSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNhbGxiYWNrRGF0YSksIHt9LCB7XG4gICAgICAgICAgaW5kZXg6IHByZXZTdGF0ZS5pbmRleCxcbiAgICAgICAgICBsaWZlY3ljbGU6IExJRkVDWUNMRS5DT01QTEVURSxcbiAgICAgICAgICBzdGVwOiBwcmV2U3RlcCxcbiAgICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9BRlRFUlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKCdzdGF0dXMnLCBbU1RBVFVTLkZJTklTSEVELCBTVEFUVVMuU0tJUFBFRF0pKSB7XG4gICAgICAgIHZhciBfcHJldlN0ZXAgPSBnZXRNZXJnZWRTdGVwKHN0ZXBzW3ByZXZTdGF0ZS5pbmRleF0sIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGlmICghY29udHJvbGxlZCkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNhbGxiYWNrRGF0YSksIHt9LCB7XG4gICAgICAgICAgICBpbmRleDogcHJldlN0YXRlLmluZGV4LFxuICAgICAgICAgICAgbGlmZWN5Y2xlOiBMSUZFQ1lDTEUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdGVwOiBfcHJldlN0ZXAsXG4gICAgICAgICAgICB0eXBlOiBFVkVOVFMuU1RFUF9BRlRFUlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2soX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNhbGxiYWNrRGF0YSksIHt9LCB7XG4gICAgICAgICAgaW5kZXg6IHByZXZTdGF0ZS5pbmRleCxcbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIGxhc3Qgc3RlcCB3aGVuIHRoZSB0b3VyIGlzIGZpbmlzaGVkXG4gICAgICAgICAgc3RlcDogX3ByZXZTdGVwLFxuICAgICAgICAgIHR5cGU6IEVWRU5UUy5UT1VSX0VORFxuICAgICAgICB9KSk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZWRGcm9tKCdzdGF0dXMnLCBbU1RBVFVTLklETEUsIFNUQVRVUy5SRUFEWV0sIFNUQVRVUy5SVU5OSU5HKSkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjYWxsYmFja0RhdGEpLCB7fSwge1xuICAgICAgICAgIHR5cGU6IEVWRU5UUy5UT1VSX1NUQVJUXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlZCgnc3RhdHVzJykpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY2FsbGJhY2tEYXRhKSwge30sIHtcbiAgICAgICAgICB0eXBlOiBFVkVOVFMuVE9VUl9TVEFUVVNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2VkKCdhY3Rpb24nLCBBQ1RJT05TLlJFU0VUKSkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjYWxsYmFja0RhdGEpLCB7fSwge1xuICAgICAgICAgIHR5cGU6IEVWRU5UUy5UT1VSX1NUQVRVU1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9TdGVwKHByZXZTdGF0ZSk7XG5cbiAgICAgICAgaWYgKHN0ZXAucGxhY2VtZW50ID09PSAnY2VudGVyJyAmJiBzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HICYmIGFjdGlvbiA9PT0gQUNUSU9OUy5TVEFSVCAmJiBsaWZlY3ljbGUgPT09IExJRkVDWUNMRS5JTklUKSB7XG4gICAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICAgIGxpZmVjeWNsZTogTElGRUNZQ0xFLlJFQURZXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgZGlzYWJsZUNsb3NlT25Fc2MgPSB0aGlzLnByb3BzLmRpc2FibGVDbG9zZU9uRXNjO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgICAgaWYgKCFkaXNhYmxlQ2xvc2VPbkVzYykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWJvYXJkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsVG9TdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvU3RlcChwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGluZGV4ID0gX3RoaXMkc3RhdGUzLmluZGV4LFxuICAgICAgICAgIGxpZmVjeWNsZSA9IF90aGlzJHN0YXRlMy5saWZlY3ljbGUsXG4gICAgICAgICAgc3RhdHVzID0gX3RoaXMkc3RhdGUzLnN0YXR1cztcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRlYnVnID0gX3RoaXMkcHJvcHM0LmRlYnVnLFxuICAgICAgICAgIGRpc2FibGVTY3JvbGxpbmcgPSBfdGhpcyRwcm9wczQuZGlzYWJsZVNjcm9sbGluZyxcbiAgICAgICAgICBkaXNhYmxlU2Nyb2xsUGFyZW50Rml4ID0gX3RoaXMkcHJvcHM0LmRpc2FibGVTY3JvbGxQYXJlbnRGaXgsXG4gICAgICAgICAgc2Nyb2xsVG9GaXJzdFN0ZXAgPSBfdGhpcyRwcm9wczQuc2Nyb2xsVG9GaXJzdFN0ZXAsXG4gICAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gX3RoaXMkcHJvcHM0LnNjcm9sbE9mZnNldCxcbiAgICAgICAgICBzY3JvbGxEdXJhdGlvbiA9IF90aGlzJHByb3BzNC5zY3JvbGxEdXJhdGlvbixcbiAgICAgICAgICBzdGVwcyA9IF90aGlzJHByb3BzNC5zdGVwcztcbiAgICAgIHZhciBzdGVwID0gZ2V0TWVyZ2VkU3RlcChzdGVwc1tpbmRleF0sIHRoaXMucHJvcHMpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEVsZW1lbnQoc3RlcC50YXJnZXQpO1xuICAgICAgICB2YXIgc2hvdWxkU2Nyb2xsID0gdGhpcy5zaG91bGRTY3JvbGwoZGlzYWJsZVNjcm9sbGluZywgaW5kZXgsIHNjcm9sbFRvRmlyc3RTdGVwLCBsaWZlY3ljbGUsIHN0ZXAsIHRhcmdldCwgcHJldlN0YXRlKTtcblxuICAgICAgICBpZiAoc3RhdHVzID09PSBTVEFUVVMuUlVOTklORyAmJiBzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICB2YXIgaGFzQ3VzdG9tU2Nyb2xsID0gaGFzQ3VzdG9tU2Nyb2xsUGFyZW50KHRhcmdldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCk7XG4gICAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudCh0YXJnZXQsIGRpc2FibGVTY3JvbGxQYXJlbnRGaXgpO1xuICAgICAgICAgIHZhciBzY3JvbGxZID0gTWF0aC5mbG9vcihnZXRTY3JvbGxUbyh0YXJnZXQsIHNjcm9sbE9mZnNldCwgZGlzYWJsZVNjcm9sbFBhcmVudEZpeCkpIHx8IDA7XG4gICAgICAgICAgbG9nKHtcbiAgICAgICAgICAgIHRpdGxlOiAnc2Nyb2xsVG9TdGVwJyxcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGtleTogJ2luZGV4JyxcbiAgICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogJ2xpZmVjeWNsZScsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaWZlY3ljbGVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiAnc3RhdHVzJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YXR1c1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBkZWJ1ZzogZGVidWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICAgICAgaWYgKGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLkJFQUNPTiAmJiB0aGlzLmJlYWNvblBvcHBlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzJGJlYWNvblBvcHBlciA9IHRoaXMuYmVhY29uUG9wcGVyLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IF90aGlzJGJlYWNvblBvcHBlci5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgcG9wcGVyID0gX3RoaXMkYmVhY29uUG9wcGVyLnBvcHBlcjtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgICAgICAgICAgIGlmICghKFsnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSkgJiYgIWhhc0N1c3RvbVNjcm9sbCkge1xuICAgICAgICAgICAgICBzY3JvbGxZID0gTWF0aC5mbG9vcihwb3BwZXIudG9wIC0gc2Nyb2xsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLlRPT0xUSVAgJiYgdGhpcy50b29sdGlwUG9wcGVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkdG9vbHRpcFBvcHBlciA9IHRoaXMudG9vbHRpcFBvcHBlcixcbiAgICAgICAgICAgICAgICBmbGlwcGVkID0gX3RoaXMkdG9vbHRpcFBvcHBlci5mbGlwcGVkLFxuICAgICAgICAgICAgICAgIF9wbGFjZW1lbnQgPSBfdGhpcyR0b29sdGlwUG9wcGVyLnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBfcG9wcGVyID0gX3RoaXMkdG9vbHRpcFBvcHBlci5wb3BwZXI7XG5cbiAgICAgICAgICAgIGlmIChbJ3RvcCcsICdyaWdodCcsICdsZWZ0J10uaW5kZXhPZihfcGxhY2VtZW50KSAhPT0gLTEgJiYgIWZsaXBwZWQgJiYgIWhhc0N1c3RvbVNjcm9sbCkge1xuICAgICAgICAgICAgICBzY3JvbGxZID0gTWF0aC5mbG9vcihfcG9wcGVyLnRvcCAtIHNjcm9sbE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxZIC09IHN0ZXAuc3BvdGxpZ2h0UGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxZID0gc2Nyb2xsWSA+PSAwID8gc2Nyb2xsWSA6IDA7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5SVU5OSU5HKSB7XG4gICAgICAgICAgICBzY3JvbGxUbyhzY3JvbGxZLCBzY3JvbGxQYXJlbnQsIHNjcm9sbER1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgaWYgKCFjYW5Vc2VET00pIHJldHVybiBudWxsO1xuICAgICAgdmFyIF90aGlzJHN0YXRlNCA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgaW5kZXggPSBfdGhpcyRzdGF0ZTQuaW5kZXgsXG4gICAgICAgICAgc3RhdHVzID0gX3RoaXMkc3RhdGU0LnN0YXR1cztcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbnRpbnVvdXMgPSBfdGhpcyRwcm9wczUuY29udGludW91cyxcbiAgICAgICAgICBkZWJ1ZyA9IF90aGlzJHByb3BzNS5kZWJ1ZyxcbiAgICAgICAgICBub25jZSA9IF90aGlzJHByb3BzNS5ub25jZSxcbiAgICAgICAgICBzY3JvbGxUb0ZpcnN0U3RlcCA9IF90aGlzJHByb3BzNS5zY3JvbGxUb0ZpcnN0U3RlcCxcbiAgICAgICAgICBzdGVwcyA9IF90aGlzJHByb3BzNS5zdGVwcztcbiAgICAgIHZhciBzdGVwID0gZ2V0TWVyZ2VkU3RlcChzdGVwc1tpbmRleF0sIHRoaXMucHJvcHMpO1xuICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTLlJVTk5JTkcgJiYgc3RlcCkge1xuICAgICAgICBvdXRwdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKb3lyaWRlU3RlcCwgX2V4dGVuZHMoe30sIHRoaXMuc3RhdGUsIHtcbiAgICAgICAgICBjYWxsYmFjazogdGhpcy5jYWxsYmFjayxcbiAgICAgICAgICBjb250aW51b3VzOiBjb250aW51b3VzLFxuICAgICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgICBzZXRQb3BwZXI6IHRoaXMuc2V0UG9wcGVyLFxuICAgICAgICAgIGhlbHBlcnM6IHRoaXMuaGVscGVycyxcbiAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgc2hvdWxkU2Nyb2xsOiAhc3RlcC5kaXNhYmxlU2Nyb2xsaW5nICYmIChpbmRleCAhPT0gMCB8fCBzY3JvbGxUb0ZpcnN0U3RlcCksXG4gICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuc3RvcmUudXBkYXRlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWpveXJpZGVcIlxuICAgICAgfSwgb3V0cHV0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSm95cmlkZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KEpveXJpZGUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgY29udGludW91czogZmFsc2UsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZGlzYWJsZUNsb3NlT25Fc2M6IGZhbHNlLFxuICBkaXNhYmxlT3ZlcmxheTogZmFsc2UsXG4gIGRpc2FibGVPdmVybGF5Q2xvc2U6IGZhbHNlLFxuICBkaXNhYmxlU2Nyb2xsaW5nOiBmYWxzZSxcbiAgZGlzYWJsZVNjcm9sbFBhcmVudEZpeDogZmFsc2UsXG4gIGdldEhlbHBlcnM6IGZ1bmN0aW9uIGdldEhlbHBlcnMoKSB7fSxcbiAgaGlkZUJhY2tCdXR0b246IGZhbHNlLFxuICBydW46IHRydWUsXG4gIHNjcm9sbE9mZnNldDogMjAsXG4gIHNjcm9sbER1cmF0aW9uOiAzMDAsXG4gIHNjcm9sbFRvRmlyc3RTdGVwOiBmYWxzZSxcbiAgc2hvd1NraXBCdXR0b246IGZhbHNlLFxuICBzaG93UHJvZ3Jlc3M6IGZhbHNlLFxuICBzcG90bGlnaHRDbGlja3M6IGZhbHNlLFxuICBzcG90bGlnaHRQYWRkaW5nOiAxMCxcbiAgc3RlcHM6IFtdXG59KTtcblxuZXhwb3J0IHsgQUNUSU9OUywgRVZFTlRTLCBMSUZFQ1lDTEUsIFNUQVRVUywgSm95cmlkZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50408\n")}}]);