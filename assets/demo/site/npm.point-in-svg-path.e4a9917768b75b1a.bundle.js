(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[9615],{37365:module=>{eval("const clone = (obj) => {\n  if (typeof obj === 'function' || Object(obj) !== obj) {\n    return obj;\n  }\n\n  const res = new obj.constructor;\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      res[key] = clone(obj[key]);\n    }\n  }\n  return res;\n};\n\nfunction repush (array, item) {\n  for (var i = 0, c = array.length; i < c; i++) {\n    if (array[i] === item) {\n      return array.push(array.splice(i, 1)[0]);\n    }\n  }\n}\n\nfunction cacher (f, scope, postprocessor) {\n  function newf () {\n    var arg = Array.prototype.slice.call(arguments, 0),\n      args = arg.join('\\u2400'),\n      cache = newf.cache = newf.cache || {},\n      count = newf.count = newf.count || [];\n    if (cache.hasOwnProperty(args)) {\n      repush(count, args);\n      return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    count.length >= 1e3 && delete cache[count.shift()];\n    count.push(args);\n    cache[args] = f.apply(scope, arg);\n    return postprocessor ? postprocessor(cache[args]) : cache[args];\n  }\n\n  return newf;\n}\n\nfunction paths (ps) {\n  var p = paths.ps = paths.ps || {};\n  if (p[ps]) {\n    p[ps].sleep = 100;\n  } else {\n    p[ps] = {\n      sleep: 100,\n    };\n  }\n  setTimeout(function () {\n    for (var key in p) if (p.hasOwnProperty(key) && key != ps) {\n      p[key].sleep--;\n      !p[key].sleep && delete p[key];\n    }\n  });\n  return p[ps];\n}\n\nfunction box (x, y, width, height) {\n  if (x == null) {\n    x = y = width = height = 0;\n  }\n  if (y == null) {\n    y = x.y;\n    width = x.width;\n    height = x.height;\n    x = x.x;\n  }\n  return {\n    x: x,\n    y: y,\n    width: width,\n    w: width,\n    height: height,\n    h: height,\n    x2: x + width,\n    y2: y + height,\n    cx: x + width / 2,\n    cy: y + height / 2,\n    r1: Math.min(width, height) / 2,\n    r2: Math.max(width, height) / 2,\n    r0: Math.sqrt(width * width + height * height) / 2,\n    path: rectPath(x, y, width, height),\n    vb: [x, y, width, height].join(' '),\n  };\n}\n\nfunction pathClone (pathArray) {\n  var res = clone(pathArray);\n  //res.toString = toString;\n  return res;\n}\n\nfunction findDotsAtSegment (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n  var t1 = 1 - t,\n    t13 = Math.pow(t1, 3),\n    t12 = Math.pow(t1, 2),\n    t2 = t * t,\n    t3 = t2 * t,\n    x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n    y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n    mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n    my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n    nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n    ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n    ax = t1 * p1x + t * c1x,\n    ay = t1 * p1y + t * c1y,\n    cx = t1 * c2x + t * p2x,\n    cy = t1 * c2y + t * p2y,\n    alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;\n  // (mx > nx || my < ny) && (alpha += 180);\n  return {\n    x: x,\n    y: y,\n    m: {x: mx, y: my},\n    n: {x: nx, y: ny},\n    start: {x: ax, y: ay},\n    end: {x: cx, y: cy},\n    alpha: alpha,\n  };\n}\n\nfunction is (o, type) {\n  type = String.prototype.toLowerCase.call(type);\n  if (type == 'finite') {\n    return isFinite(o);\n  }\n  if (type == 'array' &&\n    (o instanceof Array || Array.isArray && Array.isArray(o))) {\n    return true;\n  }\n  return type == 'null' && o === null ||\n    type == typeof o && o !== null ||\n    type == 'object' && o === Object(o) ||\n    Object.prototype.toString.call(o).slice(8, -1).toLowerCase() == type;\n}\n\nfunction bezierBBox (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n  if (!is(p1x, 'array')) {\n    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n  }\n  var bbox = curveDim.apply(null, p1x);\n  return box(\n    bbox.min.x,\n    bbox.min.y,\n    bbox.max.x - bbox.min.x,\n    bbox.max.y - bbox.min.y,\n  );\n}\n\nfunction isPointInsideBBox (bbox, x, y) {\n  return x >= bbox.x &&\n    x <= bbox.x + bbox.width &&\n    y >= bbox.y &&\n    y <= bbox.y + bbox.height;\n}\n\nfunction isBBoxIntersect (bbox1, bbox2) {\n  bbox1 = box(bbox1);\n  bbox2 = box(bbox2);\n  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n    || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n    || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n    || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n    || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n    || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n      || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n    && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n      || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n}\n\nfunction base3 (t, p1, p2, p3, p4) {\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n    t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n  return t * t2 - 3 * p1 + 3 * p2;\n}\n\nfunction bezlen (x1, y1, x2, y2, x3, y3, x4, y4, z) {\n  if (z == null) {\n    z = 1;\n  }\n  z = z > 1 ? 1 : z < 0 ? 0 : z;\n  var z2 = z / 2,\n    n = 12,\n    Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],\n    Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],\n    sum = 0;\n  for (var i = 0; i < n; i++) {\n    var ct = z2 * Tvalues[i] + z2,\n      xbase = base3(ct, x1, x2, x3, x4),\n      ybase = base3(ct, y1, y2, y3, y4),\n      comb = xbase * xbase + ybase * ybase;\n    sum += Cvalues[i] * Math.sqrt(comb);\n  }\n  return z2 * sum;\n}\n\nfunction intersect (x1, y1, x2, y2, x3, y3, x4, y4) {\n  if (\n    Math.max(x1, x2) < Math.min(x3, x4) ||\n    Math.min(x1, x2) > Math.max(x3, x4) ||\n    Math.max(y1, y2) < Math.min(y3, y4) ||\n    Math.min(y1, y2) > Math.max(y3, y4)\n  ) {\n    return;\n  }\n  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n    ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n    denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  if (!denominator) {\n    return;\n  }\n  var px = nx / denominator,\n    py = ny / denominator,\n    px2 = +px.toFixed(2),\n    py2 = +py.toFixed(2);\n  if (\n    px2 < +Math.min(x1, x2).toFixed(2) ||\n    px2 > +Math.max(x1, x2).toFixed(2) ||\n    px2 < +Math.min(x3, x4).toFixed(2) ||\n    px2 > +Math.max(x3, x4).toFixed(2) ||\n    py2 < +Math.min(y1, y2).toFixed(2) ||\n    py2 > +Math.max(y1, y2).toFixed(2) ||\n    py2 < +Math.min(y3, y4).toFixed(2) ||\n    py2 > +Math.max(y3, y4).toFixed(2)\n  ) {\n    return;\n  }\n  return {x: px, y: py};\n}\n\nfunction interHelper (bez1, bez2, justCount) {\n  var bbox1 = bezierBBox(bez1),\n    bbox2 = bezierBBox(bez2);\n  if (!isBBoxIntersect(bbox1, bbox2)) {\n    return justCount ? 0 : [];\n  }\n  var l1 = bezlen.apply(0, bez1),\n    l2 = bezlen.apply(0, bez2),\n    n1 = ~~(l1 / 8),\n    n2 = ~~(l2 / 8),\n    dots1 = [],\n    dots2 = [],\n    xy = {},\n    res = justCount ? 0 : [];\n  for (var i = 0; i < n1 + 1; i++) {\n    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n    dots1.push({x: p.x, y: p.y, t: i / n1});\n  }\n  for (i = 0; i < n2 + 1; i++) {\n    p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n    dots2.push({x: p.x, y: p.y, t: i / n2});\n  }\n  for (i = 0; i < n1; i++) {\n    for (var j = 0; j < n2; j++) {\n      var di = dots1[i],\n        di1 = dots1[i + 1],\n        dj = dots2[j],\n        dj1 = dots2[j + 1],\n        ci = Math.abs(di1.x - di.x) < .001 ? 'y' : 'x',\n        cj = Math.abs(dj1.x - dj.x) < .001 ? 'y' : 'x',\n        is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n      if (is) {\n        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n          continue;\n        }\n        xy[is.x.toFixed(4)] = is.y.toFixed(4);\n        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n          t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n          if (justCount) {\n            res++;\n          } else {\n            res.push({\n              x: is.x,\n              y: is.y,\n              t1: t1,\n              t2: t2,\n            });\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\nfunction interPathHelper (path1, path2, justCount) {\n  path1 = path2curve(path1);\n  path2 = path2curve(path2);\n  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n    res = justCount ? 0 : [];\n  for (var i = 0, ii = path1.length; i < ii; i++) {\n    var pi = path1[i];\n    if (pi[0] == 'M') {\n      x1 = x1m = pi[1];\n      y1 = y1m = pi[2];\n    } else {\n      if (pi[0] == 'C') {\n        bez1 = [x1, y1].concat(pi.slice(1));\n        x1 = bez1[6];\n        y1 = bez1[7];\n      } else {\n        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n        x1 = x1m;\n        y1 = y1m;\n      }\n      for (var j = 0, jj = path2.length; j < jj; j++) {\n        var pj = path2[j];\n        if (pj[0] == 'M') {\n          x2 = x2m = pj[1];\n          y2 = y2m = pj[2];\n        } else {\n          if (pj[0] == 'C') {\n            bez2 = [x2, y2].concat(pj.slice(1));\n            x2 = bez2[6];\n            y2 = bez2[7];\n          } else {\n            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n            x2 = x2m;\n            y2 = y2m;\n          }\n          var intr = interHelper(bez1, bez2, justCount);\n          if (justCount) {\n            res += intr;\n          } else {\n            for (var k = 0, kk = intr.length; k < kk; k++) {\n              intr[k].segment1 = i;\n              intr[k].segment2 = j;\n              intr[k].bez1 = bez1;\n              intr[k].bez2 = bez2;\n            }\n            res = res.concat(intr);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\nfunction pathBBox (path) {\n  var pth = paths(path);\n\n  if (pth.bbox) {\n    return clone(pth.bbox);\n  }\n\n  if (!path) {\n    return box();\n  }\n\n  var pathLocal = path2curve(path);\n  var x = 0;\n  var y = 0;\n  var X = [];\n  var Y = [];\n  var p = [];\n\n  for (var i = 0, c = pathLocal.length; i < c; i++) {\n    p = pathLocal[i];\n    if (p[0] == 'M') {\n      x = p[1];\n      y = p[2];\n      X.push(x);\n      Y.push(y);\n      continue;\n    }\n\n    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n    X = X.concat(dim.min.x, dim.max.x);\n    Y = Y.concat(dim.min.y, dim.max.y);\n    x = p[5];\n    y = p[6];\n  }\n\n  var xmin = Math.min.apply(0, X);\n  var ymin = Math.min.apply(0, Y);\n  var xmax = Math.max.apply(0, X);\n  var ymax = Math.max.apply(0, Y);\n  var bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\n  pth.bbox = clone(bb);\n  return bb;\n}\n\nfunction rectPath (x, y, w, h, r) {\n  if (r) {\n    return [\n      ['M', +x + +r, y],\n      ['l', w - r * 2, 0],\n      ['a', r, r, 0, 0, 1, r, r],\n      ['l', 0, h - r * 2],\n      ['a', r, r, 0, 0, 1, -r, r],\n      ['l', r * 2 - w, 0],\n      ['a', r, r, 0, 0, 1, -r, -r],\n      ['l', 0, r * 2 - h],\n      ['a', r, r, 0, 0, 1, r, -r],\n      ['z'],\n    ];\n  }\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\n  //res.toString = toString;\n  return res;\n}\n\nfunction ellipsePath (x, y, rx, ry, a) {\n  if (a == null && ry == null) {\n    ry = rx;\n  }\n  x = +x;\n  y = +y;\n  rx = +rx;\n  ry = +ry;\n  if (a != null) {\n    var rad = Math.PI / 180,\n      x1 = x + rx * Math.cos(-ry * rad),\n      x2 = x + rx * Math.cos(-a * rad),\n      y1 = y + rx * Math.sin(-ry * rad),\n      y2 = y + rx * Math.sin(-a * rad),\n      res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n  } else {\n    res = [\n      ['M', x, y],\n      ['m', 0, -ry],\n      ['a', rx, ry, 0, 1, 1, 0, 2 * ry],\n      ['a', rx, ry, 0, 1, 1, 0, -2 * ry],\n      ['z'],\n    ];\n  }\n  //res.toString = toString;\n  return res;\n}\n\nconst pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig;\nconst pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/ig;\n\nfunction parsePathString (pathString) {\n  if (!pathString) {\n    return null;\n  }\n  var pth = paths(pathString);\n  if (pth.arr) {\n    return clone(pth.arr);\n  }\n\n  var paramCounts = {\n      a: 7,\n      c: 6,\n      o: 2,\n      h: 1,\n      l: 2,\n      m: 2,\n      r: 4,\n      q: 4,\n      s: 4,\n      t: 2,\n      v: 1,\n      u: 3,\n      z: 0,\n    },\n    data = [];\n  if (is(pathString, 'array') && is(pathString[0], 'array')) { // rough assumption\n    data = Snap.path.clone(pathString);\n  }\n  if (!data.length) {\n    String(pathString).replace(pathCommand, function (a, b, c) {\n      var params = [],\n        name = b.toLowerCase();\n      c.replace(pathValues, function (a, b) {\n        b && params.push(+b);\n      });\n      if (name == 'm' && params.length > 2) {\n        data.push([b].concat(params.splice(0, 2)));\n        name = 'l';\n        b = b == 'm' ? 'l' : 'L';\n      }\n      if (name == 'o' && params.length == 1) {\n        data.push([b, params[0]]);\n      }\n      if (name == 'r') {\n        data.push([b].concat(params));\n      } else while (params.length >= paramCounts[name]) {\n        data.push([b].concat(params.splice(0, paramCounts[name])));\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    });\n  }\n  //data.toString = pth.toString;\n  pth.arr = clone(data);\n  return data;\n}\n\nfunction pathToAbsolute (pathArray) {\n  var pth = paths(pathArray);\n  if (pth.abs) {\n    return pathClone(pth.abs);\n  }\n  if (!is(pathArray, 'array') || !is(pathArray && pathArray[0], 'array')) { // rough assumption\n    pathArray = parsePathString(pathArray);\n  }\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n  var res = [],\n    x = 0,\n    y = 0,\n    mx = 0,\n    my = 0,\n    start = 0,\n    pa0;\n  if (pathArray[0][0] == 'M') {\n    x = +pathArray[0][1];\n    y = +pathArray[0][2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n  var crz = pathArray.length == 3 &&\n    pathArray[0][0] == 'M' &&\n    pathArray[1][0].toUpperCase() == 'R' &&\n    pathArray[2][0].toUpperCase() == 'Z';\n  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n    res.push(r = []);\n    pa = pathArray[i];\n    pa0 = pa[0];\n    if (pa0 != pa0.toUpperCase()) {\n      r[0] = pa0.toUpperCase();\n      switch (r[0]) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n        case 'R':\n          var dots = [x, y].concat(pa.slice(1));\n          for (var j = 2, jj = dots.length; j < jj; j++) {\n            dots[j] = +dots[j] + x;\n            dots[++j] = +dots[j] + y;\n          }\n          res.pop();\n          res = res.concat(catmullRom2bezier(dots, crz));\n          break;\n        case 'O':\n          res.pop();\n          dots = ellipsePath(x, y, pa[1], pa[2]);\n          dots.push(dots[0]);\n          res = res.concat(dots);\n          break;\n        case 'U':\n          res.pop();\n          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n          r = ['U'].concat(res[res.length - 1].slice(-2));\n          break;\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n        default:\n          for (j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + (j % 2 ? x : y);\n          }\n      }\n    } else if (pa0 == 'R') {\n      dots = [x, y].concat(pa.slice(1));\n      res.pop();\n      res = res.concat(catmullRom2bezier(dots, crz));\n      r = ['R'].concat(pa.slice(-2));\n    } else if (pa0 == 'O') {\n      res.pop();\n      dots = ellipsePath(x, y, pa[1], pa[2]);\n      dots.push(dots[0]);\n      res = res.concat(dots);\n    } else if (pa0 == 'U') {\n      res.pop();\n      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n      r = ['U'].concat(res[res.length - 1].slice(-2));\n    } else {\n      for (var k = 0, kk = pa.length; k < kk; k++) {\n        r[k] = pa[k];\n      }\n    }\n    pa0 = pa0.toUpperCase();\n    if (pa0 != 'O') {\n      switch (r[0]) {\n        case 'Z':\n          x = +mx;\n          y = +my;\n          break;\n        case 'H':\n          x = r[1];\n          break;\n        case 'V':\n          y = r[1];\n          break;\n        case 'M':\n          mx = r[r.length - 2];\n          my = r[r.length - 1];\n        default:\n          x = r[r.length - 2];\n          y = r[r.length - 1];\n      }\n    }\n  }\n  //res.toString = toString;\n  pth.abs = pathClone(res);\n  return res;\n}\n\nfunction l2c (x1, y1, x2, y2) {\n  return [x1, y1, x2, y2, x2, y2];\n}\n\nfunction q2c (x1, y1, ax, ay, x2, y2) {\n  var _13 = 1 / 3,\n    _23 = 2 / 3;\n  return [\n    _13 * x1 + _23 * ax,\n    _13 * y1 + _23 * ay,\n    _13 * x2 + _23 * ax,\n    _13 * y2 + _23 * ay,\n    x2,\n    y2,\n  ];\n}\n\n// Returns bounding box of cubic bezier curve.\n// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n// Original version: NISHIO Hirokazu\n// Modifications: https://github.com/timo22345\nfunction curveDim (x0, y0, x1, y1, x2, y2, x3, y3) {\n  var tvalues = [],\n    bounds = [[], []],\n    a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n  for (var i = 0; i < 2; ++i) {\n    if (i == 0) {\n      b = 6 * x0 - 12 * x1 + 6 * x2;\n      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n      c = 3 * x1 - 3 * x0;\n    } else {\n      b = 6 * y0 - 12 * y1 + 6 * y2;\n      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n      c = 3 * y1 - 3 * y0;\n    }\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) < 1e-12) {\n        continue;\n      }\n      t = -c / b;\n      if (0 < t && t < 1) {\n        tvalues.push(t);\n      }\n      continue;\n    }\n    b2ac = b * b - 4 * c * a;\n    sqrtb2ac = Math.sqrt(b2ac);\n    if (b2ac < 0) {\n      continue;\n    }\n    t1 = (-b + sqrtb2ac) / (2 * a);\n    if (0 < t1 && t1 < 1) {\n      tvalues.push(t1);\n    }\n    t2 = (-b - sqrtb2ac) / (2 * a);\n    if (0 < t2 && t2 < 1) {\n      tvalues.push(t2);\n    }\n  }\n\n  var x, y, j = tvalues.length,\n    jlen = j,\n    mt;\n  while (j--) {\n    t = tvalues[j];\n    mt = 1 - t;\n    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n  }\n\n  bounds[0][jlen] = x0;\n  bounds[1][jlen] = y0;\n  bounds[0][jlen + 1] = x3;\n  bounds[1][jlen + 1] = y3;\n  bounds[0].length = bounds[1].length = jlen + 2;\n\n  return {\n    min: {x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1])},\n    max: {x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1])},\n  };\n}\n\nfunction a2c (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var _120 = Math.PI * 120 / 180,\n    rad = Math.PI / 180 * (+angle || 0),\n    res = [],\n    xy,\n    rotate = cacher(function (x, y, rad) {\n      var X = x * Math.cos(rad) - y * Math.sin(rad),\n        Y = x * Math.sin(rad) + y * Math.cos(rad);\n      return {x: X, y: Y};\n    });\n  if (!rx || !ry) {\n    return [x1, y1, x2, y2, x2, y2];\n  }\n  if (!recursive) {\n    xy = rotate(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotate(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n    var cos = Math.cos(Math.PI / 180 * angle),\n      sin = Math.sin(Math.PI / 180 * angle),\n      x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx,\n      ry2 = ry * ry,\n      k = (large_arc_flag == sweep_flag ? -1 : 1) *\n        Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n      cx = k * rx * y / ry + (x1 + x2) / 2,\n      cy = k * -ry * x / rx + (y1 + y2) / 2,\n      f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n      f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = 4 / 3 * rx * t,\n    hy = 4 / 3 * ry * t,\n    m1 = [x1, y1],\n    m2 = [x1 + hx * s1, y1 - hy * c1],\n    m3 = [x2 + hx * s2, y2 - hy * c2],\n    m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [m2, m3, m4].concat(res);\n  } else {\n    res = [m2, m3, m4].concat(res).join().split(',');\n    var newres = [];\n    for (var i = 0, ii = res.length; i < ii; i++) {\n      newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n    }\n    return newres;\n  }\n}\n\nfunction path2curve (path, path2) {\n  var pth = !path2 && paths(path);\n\n  if (!path2 && pth.curve) {\n    return pathClone(pth.curve);\n  }\n\n  var p = pathToAbsolute(path);\n  var p2 = path2 && pathToAbsolute(path2);\n  var attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null};\n  var attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null};\n\n  var processPath = function (path, d, pcom) {\n    var nx, ny;\n    if (!path) {\n      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n    }\n    !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n    switch (path[0]) {\n      case 'M':\n        d.X = path[1];\n        d.Y = path[2];\n        break;\n      case 'A':\n        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n        break;\n      case 'S':\n        if (pcom == 'C' || pcom == 'S') { // In \"S\" case we have to take into account, if the previous command is C/S.\n          nx = d.x * 2 - d.bx;          // And reflect the previous\n          ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n        } else {                            // or some else or nothing\n          nx = d.x;\n          ny = d.y;\n        }\n        path = ['C', nx, ny].concat(path.slice(1));\n        break;\n      case 'T':\n        if (pcom == 'Q' || pcom == 'T') { // In \"T\" case we have to take into account, if the previous command is Q/T.\n          d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n          d.qy = d.y * 2 - d.qy;        // to case \"S\".\n        } else {                            // or something else or nothing\n          d.qx = d.x;\n          d.qy = d.y;\n        }\n        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n        break;\n      case 'Q':\n        d.qx = path[1];\n        d.qy = path[2];\n        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n        break;\n      case 'L':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\n        break;\n      case 'H':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\n        break;\n      case 'V':\n        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\n        break;\n      case 'Z':\n        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\n        break;\n    }\n    return path;\n  };\n\n  var fixArc = function (pp, i) {\n    if (pp[i].length > 7) {\n      pp[i].shift();\n      var pi = pp[i];\n      while (pi.length) {\n        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\n        p2 && (pcoms2[i] = 'A'); // the same as above\n        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n      }\n      pp.splice(i, 1);\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  var fixM = function (path1, path2, a1, a2, i) {\n    if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {\n      path2.splice(i, 0, ['M', a2.x, a2.y]);\n      a1.bx = 0;\n      a1.by = 0;\n      a1.x = path1[i][1];\n      a1.y = path1[i][2];\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  var pcoms1 = []; // path commands of original path p\n  var pcoms2 = []; // path commands of original path p2\n  var pfirst = ''; // temporary holder for original path command\n  var pcom = ''; // holder for previous path command of original path\n\n  for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {\n    p[i] && (pfirst = p[i][0]); // save current path command\n\n    if (pfirst != 'C') { // C is not saved yet, because it may be result of conversion\n      pcoms1[i] = pfirst; // Save current path command\n      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n    }\n    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n    if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C'; // A is the only command\n    // which may produce multiple C:s\n    // so we have to make sure that C is also C in original path\n\n    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n    if (p2) { // the same procedures is done to p2\n      p2[i] && (pfirst = p2[i][0]);\n      if (pfirst != 'C') {\n        pcoms2[i] = pfirst;\n        i && (pcom = pcoms2[i - 1]);\n      }\n      p2[i] = processPath(p2[i], attrs2, pcom);\n\n      if (pcoms2[i] != 'A' && pfirst == 'C') {\n        pcoms2[i] = 'C';\n      }\n\n      fixArc(p2, i);\n    }\n\n    fixM(p, p2, attrs, attrs2, i);\n    fixM(p2, p, attrs2, attrs, i);\n\n    var seg = p[i];\n    var seg2 = p2 && p2[i];\n    var seglen = seg.length;\n    var seg2len = p2 && seg2.length;\n\n    attrs.x = seg[seglen - 2];\n    attrs.y = seg[seglen - 1];\n    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n    attrs2.x = p2 && seg2[seg2len - 2];\n    attrs2.y = p2 && seg2[seg2len - 1];\n  }\n\n  if (!p2) {\n    pth.curve = pathClone(p);\n  }\n  return p2 ? [p, p2] : p;\n}\n\n// http://schepers.cc/getting-to-the-point\nfunction catmullRom2bezier (crp, z) {\n  var d = [];\n\n  for (var i = 0, c = crp.length; c - 2 * !z > i; i += 2) {\n    var p = [\n      {x: +crp[i - 2], y: +crp[i - 1]},\n      {x: +crp[i], y: +crp[i + 1]},\n      {x: +crp[i + 2], y: +crp[i + 3]},\n      {x: +crp[i + 4], y: +crp[i + 5]},\n    ];\n\n    if (z) {\n      if (!i) {\n        p[0] = {x: +crp[c - 2], y: +crp[c - 1]};\n      } else if (c - 4 == i) {\n        p[3] = {x: +crp[0], y: +crp[1]};\n      } else if (c - 2 == i) {\n        p[2] = {x: +crp[0], y: +crp[1]};\n        p[3] = {x: +crp[2], y: +crp[3]};\n      }\n    } else {\n      if (c - 4 == i) {\n        p[3] = p[2];\n      } else if (!i) {\n        p[0] = {x: +crp[i], y: +crp[i + 1]};\n      }\n    }\n\n    d.push(['C',\n      (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n      (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n      (p[1].x + 6 * p[2].x - p[3].x) / 6,\n      (p[1].y + 6 * p[2].y - p[3].y) / 6,\n      p[2].x,\n      p[2].y,\n    ]);\n  }\n\n  return d;\n}\n\nconst pointInSvgPath = (path, x, y) => {\n  const bbox = pathBBox(path);\n\n  if (!isPointInsideBBox(bbox, x, y)) {\n    return false;\n  }\n\n  if (interPathHelper(path, [['M', x, y], ['H', bbox.x2 + 10]], 1) % 2 !== 1) {\n    return false;\n  }\n\n  return true;\n};\n\nconst getPointsAndIntersectingPaths = (paths, points) => {\n  const pathBBoxes = paths.map(({id, data}) => ({id, data, bbox: pathBBox(data)}))\n\n  return points.map(({id: pointId, x, y}) => {\n    const intersectingPathIds = pathBBoxes.filter(({data, bbox}) => {\n      if (!isPointInsideBBox(bbox, x, y)) {\n        return false;\n      }\n\n      if (interPathHelper(data, [['M', x, y], ['H', bbox.x2 + 10]], 1) % 2 !== 1) {\n        return false;\n      }\n\n      return true\n    })\n      .map(({id}) => id)\n    return {pointId, x, y, intersectingPathIds}\n  })\n};\n\nmodule.exports = {\n  pointInSvgPath,\n  getPointsAndIntersectingPaths,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzczNjUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQixRQUFRLGFBQWE7QUFDckIsWUFBWSxhQUFhO0FBQ3pCLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsaUVBQWlFO0FBQzNFLFVBQVUsaUVBQWlFO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGlCQUFpQjs7QUFFakIsaUVBQWlFLFFBQVE7QUFDekUsZ0NBQWdDOztBQUVoQyx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLG1DQUFtQztBQUNuQztBQUNBLDJDQUEyQzs7QUFFM0MsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQSxPQUFPLCtCQUErQjtBQUN0QyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLCtCQUErQjtBQUN0QyxPQUFPLCtCQUErQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFFBQVE7QUFDUixnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxTQUFTLE9BQU8sK0JBQStCOztBQUVoRixzQkFBc0Isa0JBQWtCO0FBQ3hDLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsYUFBYSxHQUFHO0FBQ2hCLFlBQVk7QUFDWixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvcG9pbnQtaW4tc3ZnLXBhdGgvaW5kZXguanM/M2Y3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjbG9uZSA9IChvYmopID0+IHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjb25zdCByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHJlcHVzaCAoYXJyYXksIGl0ZW0pIHtcbiAgZm9yICh2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBhcnJheS5wdXNoKGFycmF5LnNwbGljZShpLCAxKVswXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlciAoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgZnVuY3Rpb24gbmV3ZiAoKSB7XG4gICAgdmFyIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICBhcmdzID0gYXJnLmpvaW4oJ1xcdTI0MDAnKSxcbiAgICAgIGNhY2hlID0gbmV3Zi5jYWNoZSA9IG5ld2YuY2FjaGUgfHwge30sXG4gICAgICBjb3VudCA9IG5ld2YuY291bnQgPSBuZXdmLmNvdW50IHx8IFtdO1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShhcmdzKSkge1xuICAgICAgcmVwdXNoKGNvdW50LCBhcmdzKTtcbiAgICAgIHJldHVybiBwb3N0cHJvY2Vzc29yID8gcG9zdHByb2Nlc3NvcihjYWNoZVthcmdzXSkgOiBjYWNoZVthcmdzXTtcbiAgICB9XG4gICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgY291bnQucHVzaChhcmdzKTtcbiAgICBjYWNoZVthcmdzXSA9IGYuYXBwbHkoc2NvcGUsIGFyZyk7XG4gICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICB9XG5cbiAgcmV0dXJuIG5ld2Y7XG59XG5cbmZ1bmN0aW9uIHBhdGhzIChwcykge1xuICB2YXIgcCA9IHBhdGhzLnBzID0gcGF0aHMucHMgfHwge307XG4gIGlmIChwW3BzXSkge1xuICAgIHBbcHNdLnNsZWVwID0gMTAwO1xuICB9IGVsc2Uge1xuICAgIHBbcHNdID0ge1xuICAgICAgc2xlZXA6IDEwMCxcbiAgICB9O1xuICB9XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiBwKSBpZiAocC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgcFtrZXldLnNsZWVwLS07XG4gICAgICAhcFtrZXldLnNsZWVwICYmIGRlbGV0ZSBwW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBbcHNdO1xufVxuXG5mdW5jdGlvbiBib3ggKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSB5ID0gd2lkdGggPSBoZWlnaHQgPSAwO1xuICB9XG4gIGlmICh5ID09IG51bGwpIHtcbiAgICB5ID0geC55O1xuICAgIHdpZHRoID0geC53aWR0aDtcbiAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICB4ID0geC54O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICB3OiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBoOiBoZWlnaHQsXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodCxcbiAgICBjeDogeCArIHdpZHRoIC8gMixcbiAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgcjE6IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICByMjogTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgLyAyLFxuICAgIHIwOiBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgIHBhdGg6IHJlY3RQYXRoKHgsIHksIHdpZHRoLCBoZWlnaHQpLFxuICAgIHZiOiBbeCwgeSwgd2lkdGgsIGhlaWdodF0uam9pbignICcpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXRoQ2xvbmUgKHBhdGhBcnJheSkge1xuICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgLy9yZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQgKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gIHZhciB0MSA9IDEgLSB0LFxuICAgIHQxMyA9IE1hdGgucG93KHQxLCAzKSxcbiAgICB0MTIgPSBNYXRoLnBvdyh0MSwgMiksXG4gICAgdDIgPSB0ICogdCxcbiAgICB0MyA9IHQyICogdCxcbiAgICB4ID0gdDEzICogcDF4ICsgdDEyICogMyAqIHQgKiBjMXggKyB0MSAqIDMgKiB0ICogdCAqIGMyeCArIHQzICogcDJ4LFxuICAgIHkgPSB0MTMgKiBwMXkgKyB0MTIgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgdDMgKiBwMnksXG4gICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgbXkgPSBwMXkgKyAyICogdCAqIChjMXkgLSBwMXkpICsgdDIgKiAoYzJ5IC0gMiAqIGMxeSArIHAxeSksXG4gICAgbnggPSBjMXggKyAyICogdCAqIChjMnggLSBjMXgpICsgdDIgKiAocDJ4IC0gMiAqIGMyeCArIGMxeCksXG4gICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgYXggPSB0MSAqIHAxeCArIHQgKiBjMXgsXG4gICAgYXkgPSB0MSAqIHAxeSArIHQgKiBjMXksXG4gICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgY3kgPSB0MSAqIGMyeSArIHQgKiBwMnksXG4gICAgYWxwaGEgPSA5MCAtIE1hdGguYXRhbjIobXggLSBueCwgbXkgLSBueSkgKiAxODAgLyBNYXRoLlBJO1xuICAvLyAobXggPiBueCB8fCBteSA8IG55KSAmJiAoYWxwaGEgKz0gMTgwKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgbToge3g6IG14LCB5OiBteX0sXG4gICAgbjoge3g6IG54LCB5OiBueX0sXG4gICAgc3RhcnQ6IHt4OiBheCwgeTogYXl9LFxuICAgIGVuZDoge3g6IGN4LCB5OiBjeX0sXG4gICAgYWxwaGE6IGFscGhhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBpcyAobywgdHlwZSkge1xuICB0eXBlID0gU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZS5jYWxsKHR5cGUpO1xuICBpZiAodHlwZSA9PSAnZmluaXRlJykge1xuICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgfVxuICBpZiAodHlwZSA9PSAnYXJyYXknICYmXG4gICAgKG8gaW5zdGFuY2VvZiBBcnJheSB8fCBBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkobykpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT0gJ251bGwnICYmIG8gPT09IG51bGwgfHxcbiAgICB0eXBlID09IHR5cGVvZiBvICYmIG8gIT09IG51bGwgfHxcbiAgICB0eXBlID09ICdvYmplY3QnICYmIG8gPT09IE9iamVjdChvKSB8fFxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuXG5mdW5jdGlvbiBiZXppZXJCQm94IChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSkge1xuICBpZiAoIWlzKHAxeCwgJ2FycmF5JykpIHtcbiAgICBwMXggPSBbcDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnldO1xuICB9XG4gIHZhciBiYm94ID0gY3VydmVEaW0uYXBwbHkobnVsbCwgcDF4KTtcbiAgcmV0dXJuIGJveChcbiAgICBiYm94Lm1pbi54LFxuICAgIGJib3gubWluLnksXG4gICAgYmJveC5tYXgueCAtIGJib3gubWluLngsXG4gICAgYmJveC5tYXgueSAtIGJib3gubWluLnksXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94IChiYm94LCB4LCB5KSB7XG4gIHJldHVybiB4ID49IGJib3gueCAmJlxuICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgIHkgPj0gYmJveC55ICYmXG4gICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0IChiYm94MSwgYmJveDIpIHtcbiAgYmJveDEgPSBib3goYmJveDEpO1xuICBiYm94MiA9IGJveChiYm94Mik7XG4gIHJldHVybiBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueSlcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54MiwgYmJveDEueTIpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkpXG4gICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55MilcbiAgICB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkyKVxuICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgIHx8IGJib3gyLnggPCBiYm94MS54MiAmJiBiYm94Mi54ID4gYmJveDEueClcbiAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICB8fCBiYm94Mi55IDwgYmJveDEueTIgJiYgYmJveDIueSA+IGJib3gxLnkpO1xufVxuXG5mdW5jdGlvbiBiYXNlMyAodCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICB0MiA9IHQgKiB0MSArIDYgKiBwMSAtIDEyICogcDIgKyA2ICogcDM7XG4gIHJldHVybiB0ICogdDIgLSAzICogcDEgKyAzICogcDI7XG59XG5cbmZ1bmN0aW9uIGJlemxlbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG4gIGlmICh6ID09IG51bGwpIHtcbiAgICB6ID0gMTtcbiAgfVxuICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgdmFyIHoyID0geiAvIDIsXG4gICAgbiA9IDEyLFxuICAgIFR2YWx1ZXMgPSBbLS4xMjUyLCAuMTI1MiwgLS4zNjc4LCAuMzY3OCwgLS41ODczLCAuNTg3MywgLS43Njk5LCAuNzY5OSwgLS45MDQxLCAuOTA0MSwgLS45ODE2LCAuOTgxNl0sXG4gICAgQ3ZhbHVlcyA9IFswLjI0OTEsIDAuMjQ5MSwgMC4yMzM1LCAwLjIzMzUsIDAuMjAzMiwgMC4yMDMyLCAwLjE2MDEsIDAuMTYwMSwgMC4xMDY5LCAwLjEwNjksIDAuMDQ3MiwgMC4wNDcyXSxcbiAgICBzdW0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpLFxuICAgICAgeWJhc2UgPSBiYXNlMyhjdCwgeTEsIHkyLCB5MywgeTQpLFxuICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgIHN1bSArPSBDdmFsdWVzW2ldICogTWF0aC5zcXJ0KGNvbWIpO1xuICB9XG4gIHJldHVybiB6MiAqIHN1bTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0ICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcbiAgaWYgKFxuICAgIE1hdGgubWF4KHgxLCB4MikgPCBNYXRoLm1pbih4MywgeDQpIHx8XG4gICAgTWF0aC5taW4oeDEsIHgyKSA+IE1hdGgubWF4KHgzLCB4NCkgfHxcbiAgICBNYXRoLm1heCh5MSwgeTIpIDwgTWF0aC5taW4oeTMsIHk0KSB8fFxuICAgIE1hdGgubWluKHkxLCB5MikgPiBNYXRoLm1heCh5MywgeTQpXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICBueSA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpLFxuICAgIGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuXG4gIGlmICghZGVub21pbmF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICBweSA9IG55IC8gZGVub21pbmF0b3IsXG4gICAgcHgyID0gK3B4LnRvRml4ZWQoMiksXG4gICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gIGlmIChcbiAgICBweDIgPCArTWF0aC5taW4oeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgcHgyID4gK01hdGgubWF4KHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgIHB4MiA8ICtNYXRoLm1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICBweDIgPiArTWF0aC5tYXgoeDMsIHg0KS50b0ZpeGVkKDIpIHx8XG4gICAgcHkyIDwgK01hdGgubWluKHkxLCB5MikudG9GaXhlZCgyKSB8fFxuICAgIHB5MiA+ICtNYXRoLm1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICBweTIgPCArTWF0aC5taW4oeTMsIHk0KS50b0ZpeGVkKDIpIHx8XG4gICAgcHkyID4gK01hdGgubWF4KHkzLCB5NCkudG9GaXhlZCgyKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHt4OiBweCwgeTogcHl9O1xufVxuXG5mdW5jdGlvbiBpbnRlckhlbHBlciAoYmV6MSwgYmV6MiwganVzdENvdW50KSB7XG4gIHZhciBiYm94MSA9IGJlemllckJCb3goYmV6MSksXG4gICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgcmV0dXJuIGp1c3RDb3VudCA/IDAgOiBbXTtcbiAgfVxuICB2YXIgbDEgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MSksXG4gICAgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6MiksXG4gICAgbjEgPSB+fihsMSAvIDgpLFxuICAgIG4yID0gfn4obDIgLyA4KSxcbiAgICBkb3RzMSA9IFtdLFxuICAgIGRvdHMyID0gW10sXG4gICAgeHkgPSB7fSxcbiAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjEgKyAxOyBpKyspIHtcbiAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgIGRvdHMxLnB1c2goe3g6IHAueCwgeTogcC55LCB0OiBpIC8gbjF9KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbjIgKyAxOyBpKyspIHtcbiAgICBwID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6Mi5jb25jYXQoaSAvIG4yKSk7XG4gICAgZG90czIucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMn0pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuMjsgaisrKSB7XG4gICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgIGNpID0gTWF0aC5hYnMoZGkxLnggLSBkaS54KSA8IC4wMDEgPyAneScgOiAneCcsXG4gICAgICAgIGNqID0gTWF0aC5hYnMoZGoxLnggLSBkai54KSA8IC4wMDEgPyAneScgOiAneCcsXG4gICAgICAgIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcbiAgICAgIGlmIChpcykge1xuICAgICAgICBpZiAoeHlbaXMueC50b0ZpeGVkKDQpXSA9PSBpcy55LnRvRml4ZWQoNCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB4eVtpcy54LnRvRml4ZWQoNCldID0gaXMueS50b0ZpeGVkKDQpO1xuICAgICAgICB2YXIgdDEgPSBkaS50ICsgTWF0aC5hYnMoKGlzW2NpXSAtIGRpW2NpXSkgLyAoZGkxW2NpXSAtIGRpW2NpXSkpICogKGRpMS50IC0gZGkudCksXG4gICAgICAgICAgdDIgPSBkai50ICsgTWF0aC5hYnMoKGlzW2NqXSAtIGRqW2NqXSkgLyAoZGoxW2NqXSAtIGRqW2NqXSkpICogKGRqMS50IC0gZGoudCk7XG4gICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEgJiYgdDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgcmVzKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgeDogaXMueCxcbiAgICAgICAgICAgICAgeTogaXMueSxcbiAgICAgICAgICAgICAgdDE6IHQxLFxuICAgICAgICAgICAgICB0MjogdDIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaW50ZXJQYXRoSGVscGVyIChwYXRoMSwgcGF0aDIsIGp1c3RDb3VudCkge1xuICBwYXRoMSA9IHBhdGgyY3VydmUocGF0aDEpO1xuICBwYXRoMiA9IHBhdGgyY3VydmUocGF0aDIpO1xuICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgxbSwgeTFtLCB4Mm0sIHkybSwgYmV6MSwgYmV6MixcbiAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgcGkgPSBwYXRoMVtpXTtcbiAgICBpZiAocGlbMF0gPT0gJ00nKSB7XG4gICAgICB4MSA9IHgxbSA9IHBpWzFdO1xuICAgICAgeTEgPSB5MW0gPSBwaVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpWzBdID09ICdDJykge1xuICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXoxID0gW3gxLCB5MSwgeDEsIHkxLCB4MW0sIHkxbSwgeDFtLCB5MW1dO1xuICAgICAgICB4MSA9IHgxbTtcbiAgICAgICAgeTEgPSB5MW07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwYXRoMi5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIHZhciBwaiA9IHBhdGgyW2pdO1xuICAgICAgICBpZiAocGpbMF0gPT0gJ00nKSB7XG4gICAgICAgICAgeDIgPSB4Mm0gPSBwalsxXTtcbiAgICAgICAgICB5MiA9IHkybSA9IHBqWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwalswXSA9PSAnQycpIHtcbiAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgeTIgPSBiZXoyWzddO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXoyID0gW3gyLCB5MiwgeDIsIHkyLCB4Mm0sIHkybSwgeDJtLCB5Mm1dO1xuICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGludHIgPSBpbnRlckhlbHBlcihiZXoxLCBiZXoyLCBqdXN0Q291bnQpO1xuICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgIHJlcyArPSBpbnRyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBpbnRyLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MSA9IGk7XG4gICAgICAgICAgICAgIGludHJba10uc2VnbWVudDIgPSBqO1xuICAgICAgICAgICAgICBpbnRyW2tdLmJlejEgPSBiZXoxO1xuICAgICAgICAgICAgICBpbnRyW2tdLmJlejIgPSBiZXoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcGF0aEJCb3ggKHBhdGgpIHtcbiAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuXG4gIGlmIChwdGguYmJveCkge1xuICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gIH1cblxuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm4gYm94KCk7XG4gIH1cblxuICB2YXIgcGF0aExvY2FsID0gcGF0aDJjdXJ2ZShwYXRoKTtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBYID0gW107XG4gIHZhciBZID0gW107XG4gIHZhciBwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGMgPSBwYXRoTG9jYWwubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gICAgcCA9IHBhdGhMb2NhbFtpXTtcbiAgICBpZiAocFswXSA9PSAnTScpIHtcbiAgICAgIHggPSBwWzFdO1xuICAgICAgeSA9IHBbMl07XG4gICAgICBYLnB1c2goeCk7XG4gICAgICBZLnB1c2goeSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZGltID0gY3VydmVEaW0oeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSk7XG4gICAgWCA9IFguY29uY2F0KGRpbS5taW4ueCwgZGltLm1heC54KTtcbiAgICBZID0gWS5jb25jYXQoZGltLm1pbi55LCBkaW0ubWF4LnkpO1xuICAgIHggPSBwWzVdO1xuICAgIHkgPSBwWzZdO1xuICB9XG5cbiAgdmFyIHhtaW4gPSBNYXRoLm1pbi5hcHBseSgwLCBYKTtcbiAgdmFyIHltaW4gPSBNYXRoLm1pbi5hcHBseSgwLCBZKTtcbiAgdmFyIHhtYXggPSBNYXRoLm1heC5hcHBseSgwLCBYKTtcbiAgdmFyIHltYXggPSBNYXRoLm1heC5hcHBseSgwLCBZKTtcbiAgdmFyIGJiID0gYm94KHhtaW4sIHltaW4sIHhtYXggLSB4bWluLCB5bWF4IC0geW1pbik7XG5cbiAgcHRoLmJib3ggPSBjbG9uZShiYik7XG4gIHJldHVybiBiYjtcbn1cblxuZnVuY3Rpb24gcmVjdFBhdGggKHgsIHksIHcsIGgsIHIpIHtcbiAgaWYgKHIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgWydNJywgK3ggKyArciwgeV0sXG4gICAgICBbJ2wnLCB3IC0gciAqIDIsIDBdLFxuICAgICAgWydhJywgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICBbJ2wnLCAwLCBoIC0gciAqIDJdLFxuICAgICAgWydhJywgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgWydsJywgciAqIDIgLSB3LCAwXSxcbiAgICAgIFsnYScsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICBbJ2wnLCAwLCByICogMiAtIGhdLFxuICAgICAgWydhJywgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgWyd6J10sXG4gICAgXTtcbiAgfVxuICB2YXIgcmVzID0gW1snTScsIHgsIHldLCBbJ2wnLCB3LCAwXSwgWydsJywgMCwgaF0sIFsnbCcsIC13LCAwXSwgWyd6J11dO1xuICAvL3Jlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBlbGxpcHNlUGF0aCAoeCwgeSwgcngsIHJ5LCBhKSB7XG4gIGlmIChhID09IG51bGwgJiYgcnkgPT0gbnVsbCkge1xuICAgIHJ5ID0gcng7XG4gIH1cbiAgeCA9ICt4O1xuICB5ID0gK3k7XG4gIHJ4ID0gK3J4O1xuICByeSA9ICtyeTtcbiAgaWYgKGEgIT0gbnVsbCkge1xuICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgeDEgPSB4ICsgcnggKiBNYXRoLmNvcygtcnkgKiByYWQpLFxuICAgICAgeDIgPSB4ICsgcnggKiBNYXRoLmNvcygtYSAqIHJhZCksXG4gICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICB5MiA9IHkgKyByeCAqIE1hdGguc2luKC1hICogcmFkKSxcbiAgICAgIHJlcyA9IFtbJ00nLCB4MSwgeTFdLCBbJ0EnLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gIH0gZWxzZSB7XG4gICAgcmVzID0gW1xuICAgICAgWydNJywgeCwgeV0sXG4gICAgICBbJ20nLCAwLCAtcnldLFxuICAgICAgWydhJywgcngsIHJ5LCAwLCAxLCAxLCAwLCAyICogcnldLFxuICAgICAgWydhJywgcngsIHJ5LCAwLCAxLCAxLCAwLCAtMiAqIHJ5XSxcbiAgICAgIFsneiddLFxuICAgIF07XG4gIH1cbiAgLy9yZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgcGF0aENvbW1hbmQgPSAvKFthLXpdKVtcXHMsXSooKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT9bXFxzXSosP1tcXHNdKikrKS9pZztcbmNvbnN0IHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pW1xcc10qLD9bXFxzXSovaWc7XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyAocGF0aFN0cmluZykge1xuICBpZiAoIXBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHRoID0gcGF0aHMocGF0aFN0cmluZyk7XG4gIGlmIChwdGguYXJyKSB7XG4gICAgcmV0dXJuIGNsb25lKHB0aC5hcnIpO1xuICB9XG5cbiAgdmFyIHBhcmFtQ291bnRzID0ge1xuICAgICAgYTogNyxcbiAgICAgIGM6IDYsXG4gICAgICBvOiAyLFxuICAgICAgaDogMSxcbiAgICAgIGw6IDIsXG4gICAgICBtOiAyLFxuICAgICAgcjogNCxcbiAgICAgIHE6IDQsXG4gICAgICBzOiA0LFxuICAgICAgdDogMixcbiAgICAgIHY6IDEsXG4gICAgICB1OiAzLFxuICAgICAgejogMCxcbiAgICB9LFxuICAgIGRhdGEgPSBbXTtcbiAgaWYgKGlzKHBhdGhTdHJpbmcsICdhcnJheScpICYmIGlzKHBhdGhTdHJpbmdbMF0sICdhcnJheScpKSB7IC8vIHJvdWdoIGFzc3VtcHRpb25cbiAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKHBhdGhTdHJpbmcpO1xuICB9XG4gIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICBTdHJpbmcocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXSxcbiAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5hbWUgPT0gJ20nICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgMikpKTtcbiAgICAgICAgbmFtZSA9ICdsJztcbiAgICAgICAgYiA9IGIgPT0gJ20nID8gJ2wnIDogJ0wnO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT0gJ28nICYmIHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICBkYXRhLnB1c2goW2IsIHBhcmFtc1swXV0pO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT0gJ3InKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgfSBlbHNlIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vZGF0YS50b1N0cmluZyA9IHB0aC50b1N0cmluZztcbiAgcHRoLmFyciA9IGNsb25lKGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGF0aFRvQWJzb2x1dGUgKHBhdGhBcnJheSkge1xuICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcbiAgaWYgKHB0aC5hYnMpIHtcbiAgICByZXR1cm4gcGF0aENsb25lKHB0aC5hYnMpO1xuICB9XG4gIGlmICghaXMocGF0aEFycmF5LCAnYXJyYXknKSB8fCAhaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgJ2FycmF5JykpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgIHBhdGhBcnJheSA9IHBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICB9XG4gIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtbJ00nLCAwLCAwXV07XG4gIH1cbiAgdmFyIHJlcyA9IFtdLFxuICAgIHggPSAwLFxuICAgIHkgPSAwLFxuICAgIG14ID0gMCxcbiAgICBteSA9IDAsXG4gICAgc3RhcnQgPSAwLFxuICAgIHBhMDtcbiAgaWYgKHBhdGhBcnJheVswXVswXSA9PSAnTScpIHtcbiAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICB5ID0gK3BhdGhBcnJheVswXVsyXTtcbiAgICBteCA9IHg7XG4gICAgbXkgPSB5O1xuICAgIHN0YXJ0Kys7XG4gICAgcmVzWzBdID0gWydNJywgeCwgeV07XG4gIH1cbiAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT0gMyAmJlxuICAgIHBhdGhBcnJheVswXVswXSA9PSAnTScgJiZcbiAgICBwYXRoQXJyYXlbMV1bMF0udG9VcHBlckNhc2UoKSA9PSAnUicgJiZcbiAgICBwYXRoQXJyYXlbMl1bMF0udG9VcHBlckNhc2UoKSA9PSAnWic7XG4gIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICByZXMucHVzaChyID0gW10pO1xuICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgIHBhMCA9IHBhWzBdO1xuICAgIGlmIChwYTAgIT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgIHJbN10gPSArcGFbN10gKyB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICByWzFdID0gK3BhWzFdICsgeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgclsxXSA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgIHZhciBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDIsIGpqID0gZG90cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICBkb3RzW2pdID0gK2RvdHNbal0gKyB4O1xuICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTyc6XG4gICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIGRvdHMgPSBlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0pO1xuICAgICAgICAgIGRvdHMucHVzaChkb3RzWzBdKTtcbiAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGRvdHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICAgICAgciA9IFsnVSddLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICBteSA9ICtwYVsyXSArIHk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm9yIChqID0gMSwgamogPSBwYS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICByW2pdID0gK3BhW2pdICsgKGogJSAyID8geCA6IHkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhMCA9PSAnUicpIHtcbiAgICAgIGRvdHMgPSBbeCwgeV0uY29uY2F0KHBhLnNsaWNlKDEpKTtcbiAgICAgIHJlcy5wb3AoKTtcbiAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICByID0gWydSJ10uY29uY2F0KHBhLnNsaWNlKC0yKSk7XG4gICAgfSBlbHNlIGlmIChwYTAgPT0gJ08nKSB7XG4gICAgICByZXMucG9wKCk7XG4gICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgIGRvdHMucHVzaChkb3RzWzBdKTtcbiAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgfSBlbHNlIGlmIChwYTAgPT0gJ1UnKSB7XG4gICAgICByZXMucG9wKCk7XG4gICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgIHIgPSBbJ1UnXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGEwID0gcGEwLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKHBhMCAhPSAnTycpIHtcbiAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICB4ID0gK214O1xuICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL3Jlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICBwdGguYWJzID0gcGF0aENsb25lKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGwyYyAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbn1cblxuZnVuY3Rpb24gcTJjICh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG4gIHZhciBfMTMgPSAxIC8gMyxcbiAgICBfMjMgPSAyIC8gMztcbiAgcmV0dXJuIFtcbiAgICBfMTMgKiB4MSArIF8yMyAqIGF4LFxuICAgIF8xMyAqIHkxICsgXzIzICogYXksXG4gICAgXzEzICogeDIgKyBfMjMgKiBheCxcbiAgICBfMTMgKiB5MiArIF8yMyAqIGF5LFxuICAgIHgyLFxuICAgIHkyLFxuICBdO1xufVxuXG4vLyBSZXR1cm5zIGJvdW5kaW5nIGJveCBvZiBjdWJpYyBiZXppZXIgY3VydmUuXG4vLyBTb3VyY2U6IGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4vLyBNb2RpZmljYXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vdGltbzIyMzQ1XG5mdW5jdGlvbiBjdXJ2ZURpbSAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB0dmFsdWVzID0gW10sXG4gICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSAtYyAvIGI7XG4gICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgfVxuICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgIGpsZW4gPSBqLFxuICAgIG10O1xuICB3aGlsZSAoai0tKSB7XG4gICAgdCA9IHR2YWx1ZXNbal07XG4gICAgbXQgPSAxIC0gdDtcbiAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MCArIDMgKiBtdCAqIG10ICogdCAqIHgxICsgMyAqIG10ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkwICsgMyAqIG10ICogbXQgKiB0ICogeTEgKyAzICogbXQgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gIH1cblxuICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuXG4gIHJldHVybiB7XG4gICAgbWluOiB7eDogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzFdKX0sXG4gICAgbWF4OiB7eDogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzFdKX0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGEyYyAoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcbiAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gIHZhciBfMTIwID0gTWF0aC5QSSAqIDEyMCAvIDE4MCxcbiAgICByYWQgPSBNYXRoLlBJIC8gMTgwICogKCthbmdsZSB8fCAwKSxcbiAgICByZXMgPSBbXSxcbiAgICB4eSxcbiAgICByb3RhdGUgPSBjYWNoZXIoZnVuY3Rpb24gKHgsIHksIHJhZCkge1xuICAgICAgdmFyIFggPSB4ICogTWF0aC5jb3MocmFkKSAtIHkgKiBNYXRoLnNpbihyYWQpLFxuICAgICAgICBZID0geCAqIE1hdGguc2luKHJhZCkgKyB5ICogTWF0aC5jb3MocmFkKTtcbiAgICAgIHJldHVybiB7eDogWCwgeTogWX07XG4gICAgfSk7XG4gIGlmICghcnggfHwgIXJ5KSB7XG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgfVxuICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgeDEgPSB4eS54O1xuICAgIHkxID0geHkueTtcbiAgICB4eSA9IHJvdGF0ZSh4MiwgeTIsIC1yYWQpO1xuICAgIHgyID0geHkueDtcbiAgICB5MiA9IHh5Lnk7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihNYXRoLlBJIC8gMTgwICogYW5nbGUpLFxuICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICB2YXIgaCA9IHggKiB4IC8gKHJ4ICogcngpICsgeSAqIHkgLyAocnkgKiByeSk7XG4gICAgaWYgKGggPiAxKSB7XG4gICAgICBoID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgcnggPSBoICogcng7XG4gICAgICByeSA9IGggKiByeTtcbiAgICB9XG4gICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICByeTIgPSByeSAqIHJ5LFxuICAgICAgayA9IChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnID8gLTEgOiAxKSAqXG4gICAgICAgIE1hdGguc3FydChNYXRoLmFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgIGN4ID0gayAqIHJ4ICogeSAvIHJ5ICsgKHgxICsgeDIpIC8gMixcbiAgICAgIGN5ID0gayAqIC1yeSAqIHggLyByeCArICh5MSArIHkyKSAvIDIsXG4gICAgICBmMSA9IE1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgZjIgPSBNYXRoLmFzaW4oKCh5MiAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcblxuICAgIGYxID0geDEgPCBjeCA/IE1hdGguUEkgLSBmMSA6IGYxO1xuICAgIGYyID0geDIgPCBjeCA/IE1hdGguUEkgLSBmMiA6IGYyO1xuICAgIGYxIDwgMCAmJiAoZjEgPSBNYXRoLlBJICogMiArIGYxKTtcbiAgICBmMiA8IDAgJiYgKGYyID0gTWF0aC5QSSAqIDIgKyBmMik7XG4gICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgZjEgPSBmMSAtIE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgZjIgPSBmMiAtIE1hdGguUEkgKiAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICBmMiA9IHJlY3Vyc2l2ZVsxXTtcbiAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgfVxuICB2YXIgZGYgPSBmMiAtIGYxO1xuICBpZiAoTWF0aC5hYnMoZGYpID4gXzEyMCkge1xuICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgeDJvbGQgPSB4MixcbiAgICAgIHkyb2xkID0geTI7XG4gICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICB4MiA9IGN4ICsgcnggKiBNYXRoLmNvcyhmMik7XG4gICAgeTIgPSBjeSArIHJ5ICogTWF0aC5zaW4oZjIpO1xuICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gIH1cbiAgZGYgPSBmMiAtIGYxO1xuICB2YXIgYzEgPSBNYXRoLmNvcyhmMSksXG4gICAgczEgPSBNYXRoLnNpbihmMSksXG4gICAgYzIgPSBNYXRoLmNvcyhmMiksXG4gICAgczIgPSBNYXRoLnNpbihmMiksXG4gICAgdCA9IE1hdGgudGFuKGRmIC8gNCksXG4gICAgaHggPSA0IC8gMyAqIHJ4ICogdCxcbiAgICBoeSA9IDQgLyAzICogcnkgKiB0LFxuICAgIG0xID0gW3gxLCB5MV0sXG4gICAgbTIgPSBbeDEgKyBoeCAqIHMxLCB5MSAtIGh5ICogYzFdLFxuICAgIG0zID0gW3gyICsgaHggKiBzMiwgeTIgLSBoeSAqIGMyXSxcbiAgICBtNCA9IFt4MiwgeTJdO1xuICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICBpZiAocmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXMgPSBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcykuam9pbigpLnNwbGl0KCcsJyk7XG4gICAgdmFyIG5ld3JlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld3JlcztcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoMmN1cnZlIChwYXRoLCBwYXRoMikge1xuICB2YXIgcHRoID0gIXBhdGgyICYmIHBhdGhzKHBhdGgpO1xuXG4gIGlmICghcGF0aDIgJiYgcHRoLmN1cnZlKSB7XG4gICAgcmV0dXJuIHBhdGhDbG9uZShwdGguY3VydmUpO1xuICB9XG5cbiAgdmFyIHAgPSBwYXRoVG9BYnNvbHV0ZShwYXRoKTtcbiAgdmFyIHAyID0gcGF0aDIgJiYgcGF0aFRvQWJzb2x1dGUocGF0aDIpO1xuICB2YXIgYXR0cnMgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9O1xuICB2YXIgYXR0cnMyID0ge3g6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsfTtcblxuICB2YXIgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgIHZhciBueCwgbnk7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gWydDJywgZC54LCBkLnksIGQueCwgZC55LCBkLngsIGQueV07XG4gICAgfVxuICAgICEocGF0aFswXSBpbiB7VDogMSwgUTogMX0pICYmIChkLnF4ID0gZC5xeSA9IG51bGwpO1xuICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIGlmIChwY29tID09ICdDJyB8fCBwY29tID09ICdTJykgeyAvLyBJbiBcIlNcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIEMvUy5cbiAgICAgICAgICBueCA9IGQueCAqIDIgLSBkLmJ4OyAgICAgICAgICAvLyBBbmQgcmVmbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICBueSA9IGQueSAqIDIgLSBkLmJ5OyAgICAgICAgICAvLyBjb21tYW5kJ3MgY29udHJvbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cbiAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gWydDJywgbngsIG55XS5jb25jYXQocGF0aC5zbGljZSgxKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIGlmIChwY29tID09ICdRJyB8fCBwY29tID09ICdUJykgeyAvLyBJbiBcIlRcIiBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICBkLnF4ID0gZC54ICogMiAtIGQucXg7ICAgICAgICAvLyBBbmQgbWFrZSBhIHJlZmxlY3Rpb24gc2ltaWxhclxuICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgICAgICAgIC8vIHRvIGNhc2UgXCJTXCIuXG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHNvbWV0aGluZyBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICBkLnF4ID0gZC54O1xuICAgICAgICAgIGQucXkgPSBkLnk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgZC55KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVic6XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsMmMoZC54LCBkLnksIGQuWCwgZC5ZKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICB2YXIgZml4QXJjID0gZnVuY3Rpb24gKHBwLCBpKSB7XG4gICAgaWYgKHBwW2ldLmxlbmd0aCA+IDcpIHtcbiAgICAgIHBwW2ldLnNoaWZ0KCk7XG4gICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgIHdoaWxlIChwaS5sZW5ndGgpIHtcbiAgICAgICAgcGNvbXMxW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgIHAyICYmIChwY29tczJbaV0gPSAnQScpOyAvLyB0aGUgc2FtZSBhcyBhYm92ZVxuICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbJ0MnXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICB9XG4gICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09ICdNJyAmJiBwYXRoMltpXVswXSAhPSAnTScpIHtcbiAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbJ00nLCBhMi54LCBhMi55XSk7XG4gICAgICBhMS5ieCA9IDA7XG4gICAgICBhMS5ieSA9IDA7XG4gICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICBhMS55ID0gcGF0aDFbaV1bMl07XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwY29tczEgPSBbXTsgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHBcbiAgdmFyIHBjb21zMiA9IFtdOyAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcDJcbiAgdmFyIHBmaXJzdCA9ICcnOyAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgdmFyIHBjb20gPSAnJzsgLy8gaG9sZGVyIGZvciBwcmV2aW91cyBwYXRoIGNvbW1hbmQgb2Ygb3JpZ2luYWwgcGF0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7IGkgPCBpaTsgaSsrKSB7XG4gICAgcFtpXSAmJiAocGZpcnN0ID0gcFtpXVswXSk7IC8vIHNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgIGlmIChwZmlyc3QgIT0gJ0MnKSB7IC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgIHBjb21zMVtpXSA9IHBmaXJzdDsgLy8gU2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuICAgICAgaSAmJiAocGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICB9XG4gICAgcFtpXSA9IHByb2Nlc3NQYXRoKHBbaV0sIGF0dHJzLCBwY29tKTsgLy8gUHJldmlvdXMgcGF0aCBjb21tYW5kIGlzIGlucHV0dGVkIHRvIHByb2Nlc3NQYXRoXG5cbiAgICBpZiAocGNvbXMxW2ldICE9ICdBJyAmJiBwZmlyc3QgPT0gJ0MnKSBwY29tczFbaV0gPSAnQyc7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgIC8vIHdoaWNoIG1heSBwcm9kdWNlIG11bHRpcGxlIEM6c1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgQyBpcyBhbHNvIEMgaW4gb3JpZ2luYWwgcGF0aFxuXG4gICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgaWYgKHAyKSB7IC8vIHRoZSBzYW1lIHByb2NlZHVyZXMgaXMgZG9uZSB0byBwMlxuICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgIGlmIChwZmlyc3QgIT0gJ0MnKSB7XG4gICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpIC0gMV0pO1xuICAgICAgfVxuICAgICAgcDJbaV0gPSBwcm9jZXNzUGF0aChwMltpXSwgYXR0cnMyLCBwY29tKTtcblxuICAgICAgaWYgKHBjb21zMltpXSAhPSAnQScgJiYgcGZpcnN0ID09ICdDJykge1xuICAgICAgICBwY29tczJbaV0gPSAnQyc7XG4gICAgICB9XG5cbiAgICAgIGZpeEFyYyhwMiwgaSk7XG4gICAgfVxuXG4gICAgZml4TShwLCBwMiwgYXR0cnMsIGF0dHJzMiwgaSk7XG4gICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG5cbiAgICB2YXIgc2VnID0gcFtpXTtcbiAgICB2YXIgc2VnMiA9IHAyICYmIHAyW2ldO1xuICAgIHZhciBzZWdsZW4gPSBzZWcubGVuZ3RoO1xuICAgIHZhciBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG5cbiAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG4gICAgYXR0cnMuYnggPSBwYXJzZUZsb2F0KHNlZ1tzZWdsZW4gLSA0XSkgfHwgYXR0cnMueDtcbiAgICBhdHRycy5ieSA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgIGF0dHJzMi5ieCA9IHAyICYmIChwYXJzZUZsb2F0KHNlZzJbc2VnMmxlbiAtIDRdKSB8fCBhdHRyczIueCk7XG4gICAgYXR0cnMyLmJ5ID0gcDIgJiYgKHBhcnNlRmxvYXQoc2VnMltzZWcybGVuIC0gM10pIHx8IGF0dHJzMi55KTtcbiAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgIGF0dHJzMi55ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMV07XG4gIH1cblxuICBpZiAoIXAyKSB7XG4gICAgcHRoLmN1cnZlID0gcGF0aENsb25lKHApO1xuICB9XG4gIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xufVxuXG4vLyBodHRwOi8vc2NoZXBlcnMuY2MvZ2V0dGluZy10by10aGUtcG9pbnRcbmZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyIChjcnAsIHopIHtcbiAgdmFyIGQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgYyA9IGNycC5sZW5ndGg7IGMgLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICB2YXIgcCA9IFtcbiAgICAgIHt4OiArY3JwW2kgLSAyXSwgeTogK2NycFtpIC0gMV19LFxuICAgICAge3g6ICtjcnBbaV0sIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX0sXG4gICAgXTtcblxuICAgIGlmICh6KSB7XG4gICAgICBpZiAoIWkpIHtcbiAgICAgICAgcFswXSA9IHt4OiArY3JwW2MgLSAyXSwgeTogK2NycFtjIC0gMV19O1xuICAgICAgfSBlbHNlIGlmIChjIC0gNCA9PSBpKSB7XG4gICAgICAgIHBbM10gPSB7eDogK2NycFswXSwgeTogK2NycFsxXX07XG4gICAgICB9IGVsc2UgaWYgKGMgLSAyID09IGkpIHtcbiAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMgLSA0ID09IGkpIHtcbiAgICAgICAgcFszXSA9IHBbMl07XG4gICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgIHBbMF0gPSB7eDogK2NycFtpXSwgeTogK2NycFtpICsgMV19O1xuICAgICAgfVxuICAgIH1cblxuICAgIGQucHVzaChbJ0MnLFxuICAgICAgKC1wWzBdLnggKyA2ICogcFsxXS54ICsgcFsyXS54KSAvIDYsXG4gICAgICAoLXBbMF0ueSArIDYgKiBwWzFdLnkgKyBwWzJdLnkpIC8gNixcbiAgICAgIChwWzFdLnggKyA2ICogcFsyXS54IC0gcFszXS54KSAvIDYsXG4gICAgICAocFsxXS55ICsgNiAqIHBbMl0ueSAtIHBbM10ueSkgLyA2LFxuICAgICAgcFsyXS54LFxuICAgICAgcFsyXS55LFxuICAgIF0pO1xuICB9XG5cbiAgcmV0dXJuIGQ7XG59XG5cbmNvbnN0IHBvaW50SW5TdmdQYXRoID0gKHBhdGgsIHgsIHkpID0+IHtcbiAgY29uc3QgYmJveCA9IHBhdGhCQm94KHBhdGgpO1xuXG4gIGlmICghaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaW50ZXJQYXRoSGVscGVyKHBhdGgsIFtbJ00nLCB4LCB5XSwgWydIJywgYmJveC54MiArIDEwXV0sIDEpICUgMiAhPT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZ2V0UG9pbnRzQW5kSW50ZXJzZWN0aW5nUGF0aHMgPSAocGF0aHMsIHBvaW50cykgPT4ge1xuICBjb25zdCBwYXRoQkJveGVzID0gcGF0aHMubWFwKCh7aWQsIGRhdGF9KSA9PiAoe2lkLCBkYXRhLCBiYm94OiBwYXRoQkJveChkYXRhKX0pKVxuXG4gIHJldHVybiBwb2ludHMubWFwKCh7aWQ6IHBvaW50SWQsIHgsIHl9KSA9PiB7XG4gICAgY29uc3QgaW50ZXJzZWN0aW5nUGF0aElkcyA9IHBhdGhCQm94ZXMuZmlsdGVyKCh7ZGF0YSwgYmJveH0pID0+IHtcbiAgICAgIGlmICghaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW50ZXJQYXRoSGVscGVyKGRhdGEsIFtbJ00nLCB4LCB5XSwgWydIJywgYmJveC54MiArIDEwXV0sIDEpICUgMiAhPT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgICAgIC5tYXAoKHtpZH0pID0+IGlkKVxuICAgIHJldHVybiB7cG9pbnRJZCwgeCwgeSwgaW50ZXJzZWN0aW5nUGF0aElkc31cbiAgfSlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwb2ludEluU3ZnUGF0aCxcbiAgZ2V0UG9pbnRzQW5kSW50ZXJzZWN0aW5nUGF0aHMsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37365\n")}}]);