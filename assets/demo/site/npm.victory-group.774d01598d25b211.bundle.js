"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[7763],{54878:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "G": () => (/* binding */ VictoryGroup)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__(41609);\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/hooks/use-animation-state.js\nvar use_animation_state = __webpack_require__(16178);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/user-props.js\nvar user_props = __webpack_require__(80450);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/wrapper.js\nvar wrapper = __webpack_require__(82191);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/hooks/use-previous-props.js\nvar use_previous_props = __webpack_require__(40066);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/common-props.js\nvar common_props = __webpack_require__(5734);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-shared-events/es/victory-shared-events.js\nvar victory_shared_events = __webpack_require__(22755);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/scale.js\nvar victory_util_scale = __webpack_require__(74765);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/data.js + 1 modules\nvar data = __webpack_require__(26063);\n// EXTERNAL MODULE: ./node_modules/react-fast-compare/index.js\nvar react_fast_compare = __webpack_require__(69590);\nvar react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);\n;// CONCATENATED MODULE: ./node_modules/victory-group/es/helper-methods.js\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50,\n  offset: 0\n}; // eslint-disable-next-line max-statements\n\nfunction getCalculatedProps(props, childComponents) {\n  var role = "group";\n  props = helpers/* modifyProps */.TY(props, fallbackProps, role);\n  var style = wrapper/* getStyle */.C2(props.theme, props.style, role);\n  var _props = props,\n      offset = _props.offset,\n      colorScale = _props.colorScale,\n      color = _props.color,\n      polar = _props.polar,\n      horizontal = _props.horizontal;\n  var categories = props.categories || wrapper/* getCategories */.CP(props, childComponents, null);\n  var datasets = props.datasets || wrapper/* getDataFromChildren */.D8(props, null);\n  var domain = {\n    x: wrapper/* getDomain */.ge(assign_default()({}, props, {\n      categories: categories\n    }), "x", childComponents),\n    y: wrapper/* getDomain */.ge(assign_default()({}, props, {\n      categories: categories\n    }), "y", childComponents)\n  };\n  var range = props.range || {\n    x: helpers/* getRange */.rx(props, "x"),\n    y: helpers/* getRange */.rx(props, "y")\n  };\n  var baseScale = {\n    x: victory_util_scale/* getScaleFromProps */.j$(props, "x") || wrapper/* getScale */.yZ(props, "x"),\n    y: victory_util_scale/* getScaleFromProps */.j$(props, "y") || wrapper/* getScale */.yZ(props, "y")\n  };\n  var scale = {\n    x: baseScale.x.domain(domain.x).range(props.horizontal ? range.y : range.x),\n    y: baseScale.y.domain(domain.y).range(props.horizontal ? range.x : range.y)\n  };\n  var origin = polar ? props.origin : helpers/* getPolarOrigin */.IW(props);\n  var padding = helpers/* getPadding */.tQ(props);\n  return {\n    datasets: datasets,\n    categories: categories,\n    range: range,\n    domain: domain,\n    horizontal: horizontal,\n    scale: scale,\n    style: style,\n    colorScale: colorScale,\n    color: color,\n    offset: offset,\n    origin: origin,\n    padding: padding\n  };\n} // We need to remove sharedEvents in order to memoize the calculated data\n// With shared events, the props change on every event, and every value is re-calculated\n\nvar withoutSharedEvents = function (props) {\n  var children = props.children;\n  var modifiedChildren = react.Children.toArray(children).map(function (child) {\n    return _objectSpread(_objectSpread({}, child), {}, {\n      props: helpers/* omit */.CE(child.props, ["sharedEvents"])\n    });\n  });\n  props.children = modifiedChildren;\n  return props;\n};\n\nfunction useMemoizedProps(initialProps) {\n  var modifiedProps = withoutSharedEvents(initialProps);\n\n  var _React$useState = react.useState(modifiedProps),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      props = _React$useState2[0],\n      setProps = _React$useState2[1]; // React.memo uses shallow equality to compare objects. This way props\n  // will only be re-calculated when they change.\n\n\n  react.useEffect(function () {\n    if (!react_fast_compare_default()(modifiedProps, props)) {\n      setProps(modifiedProps);\n    }\n  }, [props, setProps, modifiedProps]);\n  return react.useMemo(function () {\n    return getCalculatedProps(props, props.children);\n  }, [props]);\n}\n\nfunction pixelsToValue(props, axis, calculatedProps) {\n  if (!props.offset) {\n    return 0;\n  }\n\n  var currentAxis = helpers/* getCurrentAxis */.Uk(axis, props.horizontal);\n  var domain = calculatedProps.domain[axis];\n  var range = calculatedProps.range[currentAxis];\n  var domainExtent = Math.max.apply(Math, _toConsumableArray(domain)) - Math.min.apply(Math, _toConsumableArray(domain));\n  var rangeExtent = Math.max.apply(Math, _toConsumableArray(range)) - Math.min.apply(Math, _toConsumableArray(range));\n  return domainExtent / rangeExtent * props.offset;\n} // eslint-disable-next-line max-params\n\n\nfunction getX0(props, calculatedProps, index, role) {\n  var groupLength = role === "stack" ? calculatedProps.datasets[0].length : calculatedProps.datasets.length;\n  var center = (groupLength - 1) / 2;\n  var totalWidth = pixelsToValue(props, "x", calculatedProps);\n  return (index - center) * totalWidth;\n} // eslint-disable-next-line max-params\n\n\nfunction getPolarX0(props, calculatedProps, index, role) {\n  var groupLength = role === "stack" ? calculatedProps.datasets[0].length : calculatedProps.datasets.length;\n  var center = (groupLength - 1) / 2;\n  var width = getAngularWidth(props, calculatedProps);\n  return (index - center) * width;\n}\n\nfunction getAngularWidth(props, calculatedProps) {\n  var range = calculatedProps.range;\n  var angularRange = Math.abs(range.x[1] - range.x[0]);\n  var r = Math.max.apply(Math, _toConsumableArray(range.y));\n  return props.offset / (2 * Math.PI * r) * angularRange;\n}\n\nfunction getLabels(props, datasets, index) {\n  if (!props.labels) {\n    return undefined;\n  }\n\n  return Math.floor(datasets.length / 2) === index ? props.labels : undefined;\n}\n\nfunction getChildProps(props, calculatedProps) {\n  var categories = calculatedProps.categories,\n      domain = calculatedProps.domain,\n      range = calculatedProps.range,\n      scale = calculatedProps.scale,\n      horizontal = calculatedProps.horizontal,\n      origin = calculatedProps.origin,\n      padding = calculatedProps.padding;\n  var width = props.width,\n      height = props.height,\n      theme = props.theme,\n      polar = props.polar;\n  return {\n    height: height,\n    width: width,\n    theme: theme,\n    polar: polar,\n    origin: origin,\n    categories: categories,\n    domain: domain,\n    range: range,\n    scale: scale,\n    horizontal: horizontal,\n    padding: padding,\n    standalone: false\n  };\n}\n\nfunction getColorScale(props, child) {\n  var role = child.type && child.type.role;\n  var colorScaleOptions = child.props.colorScale || props.colorScale;\n\n  if (role !== "group" && role !== "stack") {\n    return undefined;\n  }\n\n  return props.theme && props.theme.group ? colorScaleOptions || props.theme.group.colorScale : colorScaleOptions;\n}\n\nfunction getDataWithOffset(props) {\n  var defaultDataset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var offset = arguments.length > 2 ? arguments[2] : undefined;\n  var dataset = props.data || props.y ? data/* getData */.Yu(props) : defaultDataset;\n  var xOffset = offset || 0;\n  return dataset.map(function (datum) {\n    var _x1 = datum._x instanceof Date ? new Date(datum._x.getTime() + xOffset) : datum._x + xOffset;\n\n    return assign_default()({}, datum, {\n      _x1: _x1\n    });\n  });\n}\n\nfunction getChildren(props, childComponents, calculatedProps) {\n  props = helpers/* modifyProps */.TY(props, fallbackProps, "stack");\n  childComponents = childComponents || react.Children.toArray(props.children);\n  calculatedProps = calculatedProps || getCalculatedProps(props, childComponents);\n  var _calculatedProps = calculatedProps,\n      datasets = _calculatedProps.datasets;\n  var _props2 = props,\n      labelComponent = _props2.labelComponent,\n      polar = _props2.polar;\n  var childProps = getChildProps(props, calculatedProps);\n  var parentName = props.name || "group";\n  return childComponents.map(function (child, index) {\n    var role = child.type && child.type.role;\n    var xOffset = polar ? getPolarX0(props, calculatedProps, index, role) : getX0(props, calculatedProps, index, role);\n    var style = role === "voronoi" || role === "tooltip" || role === "label" ? child.props.style : wrapper/* getChildStyle */.ny(child, index, calculatedProps);\n    var labels = props.labels ? getLabels(props, datasets, index) : child.props.labels;\n    var name = child.props.name || "".concat(parentName, "-").concat(role, "-").concat(index);\n    return /*#__PURE__*/react.cloneElement(child, assign_default()({\n      labels: labels,\n      style: style,\n      key: "".concat(name, "-key-").concat(index),\n      name: name,\n      data: getDataWithOffset(props, datasets[index], xOffset),\n      colorScale: getColorScale(props, child),\n      labelComponent: labelComponent || child.props.labelComponent,\n      xOffset: xOffset\n    }, childProps));\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/victory-group/es/victory-group.js\n\n\n\n\nfunction victory_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction victory_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? victory_group_ownKeys(Object(source), !0).forEach(function (key) { victory_group_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : victory_group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction victory_group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\nvar victory_group_fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50,\n  offset: 0\n};\n\nvar VictoryGroupBase = function (initialProps) {\n  // eslint-disable-next-line no-use-before-define\n  var role = VictoryGroup === null || VictoryGroup === void 0 ? void 0 : VictoryGroup.role;\n\n  var _Hooks$useAnimationSt = use_animation_state/* useAnimationState */.h(),\n      getAnimationProps = _Hooks$useAnimationSt.getAnimationProps,\n      setAnimationState = _Hooks$useAnimationSt.setAnimationState,\n      getProps = _Hooks$useAnimationSt.getProps;\n\n  var props = getProps(initialProps);\n  var modifiedProps = helpers/* modifyProps */.TY(props, victory_group_fallbackProps, role);\n  var eventKey = modifiedProps.eventKey,\n      containerComponent = modifiedProps.containerComponent,\n      standalone = modifiedProps.standalone,\n      groupComponent = modifiedProps.groupComponent,\n      externalEventMutations = modifiedProps.externalEventMutations,\n      width = modifiedProps.width,\n      height = modifiedProps.height,\n      theme = modifiedProps.theme,\n      polar = modifiedProps.polar,\n      horizontal = modifiedProps.horizontal,\n      name = modifiedProps.name;\n  var childComponents = react.Children.toArray(modifiedProps.children);\n  var calculatedProps = useMemoizedProps(modifiedProps);\n  var domain = calculatedProps.domain,\n      scale = calculatedProps.scale,\n      style = calculatedProps.style,\n      origin = calculatedProps.origin;\n  var newChildren = react.useMemo(function () {\n    var children = getChildren(props, childComponents, calculatedProps);\n    return children.map(function (child, index) {\n      var childProps = assign_default()({\n        animate: getAnimationProps(props, child, index)\n      }, child.props);\n\n      return /*#__PURE__*/react.cloneElement(child, childProps);\n    });\n  }, [props, childComponents, calculatedProps, getAnimationProps]);\n  var containerProps = react.useMemo(function () {\n    if (standalone) {\n      return {\n        domain: domain,\n        scale: scale,\n        width: width,\n        height: height,\n        standalone: standalone,\n        theme: theme,\n        style: style.parent,\n        horizontal: horizontal,\n        polar: polar,\n        origin: origin,\n        name: name\n      };\n    }\n\n    return {};\n  }, [standalone, domain, scale, width, height, theme, style, horizontal, polar, origin, name]);\n  var userProps = react.useMemo(function () {\n    return user_props/* getSafeUserProps */.I(initialProps);\n  }, [initialProps]);\n  var container = react.useMemo(function () {\n    if (standalone) {\n      var defaultContainerProps = defaults_default()({}, containerComponent.props, containerProps, userProps);\n\n      return /*#__PURE__*/react.cloneElement(containerComponent, defaultContainerProps);\n    }\n\n    return /*#__PURE__*/react.cloneElement(groupComponent, userProps);\n  }, [groupComponent, standalone, containerComponent, containerProps, userProps]);\n  var events = react.useMemo(function () {\n    return wrapper/* getAllEvents */.IP(props);\n  }, [props]);\n  var previousProps = use_previous_props/* usePreviousProps */.Y(initialProps);\n  react.useEffect(function () {\n    // This is called before dismount to keep state in sync\n    return function () {\n      if (initialProps.animate) {\n        setAnimationState(previousProps, props);\n      }\n    };\n  }, [setAnimationState, previousProps, initialProps, props]);\n\n  if (!isEmpty_default()(events)) {\n    return /*#__PURE__*/react.createElement(victory_shared_events/* default */.Z, {\n      container: container,\n      eventKey: eventKey,\n      events: events,\n      externalEventMutations: externalEventMutations\n    }, newChildren);\n  }\n\n  return /*#__PURE__*/react.cloneElement(container, container.props, newChildren);\n};\n\nVictoryGroupBase.propTypes = victory_group_objectSpread(victory_group_objectSpread(victory_group_objectSpread({}, common_props/* CommonProps.baseProps */.l.baseProps), common_props/* CommonProps.dataProps */.l.dataProps), {}, {\n  children: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).node), (prop_types_default()).node]),\n  horizontal: (prop_types_default()).bool,\n  offset: (prop_types_default()).number\n});\nVictoryGroupBase.defaultProps = {\n  containerComponent: /*#__PURE__*/react.createElement(victory_container/* VictoryContainer */._, null),\n  groupComponent: /*#__PURE__*/react.createElement("g", null),\n  samples: 50,\n  sortOrder: "ascending",\n  standalone: true,\n  theme: victory_theme/* VictoryTheme.grayscale */.J.grayscale\n};\nvar componentConfig = {\n  role: "group",\n  expectedComponents: ["groupComponent", "containerComponent", "labelComponent"],\n  getChildren: getChildren\n};\nvar VictoryGroup = Object.assign( /*#__PURE__*/react.memo(VictoryGroupBase, (react_fast_compare_default())), componentConfig);\nVictoryGroup.displayName = "VictoryGroup";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ4NzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQzs7QUFFcEMsbUNBQW1DOztBQUVuQyxnQ0FBZ0M7O0FBRWhDLGtDQUFrQzs7QUFFbEMsbUNBQW1DOztBQUVuQyxrQ0FBa0M7O0FBRWxDLDhCQUE4Qjs7QUFFOUIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHlDQUF5QywwR0FBMEcsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRW5mLGdDQUFnQzs7QUFFaEMsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSzs7QUFFMWUsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRTFLO0FBQ21DO0FBQ3BCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVJO0FBQ1A7QUFDQSxVQUFVLDJCQUFtQjtBQUM3QixjQUFjLHdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkJBQXFCO0FBQzVELG1DQUFtQyxtQ0FBMkI7QUFDOUQ7QUFDQSxPQUFPLHlCQUFpQixDQUFDLGdCQUFPLEdBQUc7QUFDbkM7QUFDQSxLQUFLO0FBQ0wsT0FBTyx5QkFBaUIsQ0FBQyxnQkFBTyxHQUFHO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPLHdCQUFnQjtBQUN2QixPQUFPLHdCQUFnQjtBQUN2QjtBQUNBO0FBQ0EsT0FBTyw0Q0FBdUIsZ0JBQWdCLHdCQUFnQjtBQUM5RCxPQUFPLDRDQUF1QixnQkFBZ0Isd0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQXNCO0FBQzVELGdCQUFnQiwwQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQyx5Q0FBeUMsWUFBWTtBQUNyRCxhQUFhLG9CQUFZO0FBQ3pCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7O0FBR0EsRUFBRSxlQUFlO0FBQ2pCLFNBQVMsNEJBQU87QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLGFBQWE7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDhCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBWTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBTyxHQUFHO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFTztBQUNQLFVBQVUsMkJBQW1CO0FBQzdCLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyw2QkFBcUI7QUFDeEg7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0IsUUFBUSxnQkFBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDOztBQ3JQc0M7QUFDRTtBQUNKOztBQUVwQyxTQUFTLHFCQUFPLDJCQUEyQixnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQzs7QUFFdlUsU0FBUywwQkFBYSxXQUFXLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsUUFBUSxxQkFBTyw4Q0FBOEMsNEJBQWUsNkJBQTZCLG1IQUFtSCxxQkFBTywwQ0FBMEMsbUZBQW1GLEtBQUs7O0FBRTFlLFNBQVMsNEJBQWUsb0JBQW9CLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRWpLO0FBQ1Q7QUFDcUY7QUFDbkQ7QUFDSztBQUN4QjtBQUN6QyxJQUFJLDJCQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw0Q0FBdUI7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDJCQUFtQixRQUFRLDJCQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxtQkFBbUIsV0FBVztBQUM5QjtBQUNBLHVCQUF1QixnQkFBTztBQUM5QjtBQUNBLE9BQU87O0FBRVAsMEJBQTBCLGtCQUFrQjtBQUM1QyxLQUFLO0FBQ0wsR0FBRztBQUNILHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsYUFBYTtBQUMvQixXQUFXLGtDQUEwQjtBQUNyQyxHQUFHO0FBQ0gsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQSxrQ0FBa0Msa0JBQVMsR0FBRzs7QUFFOUMsMEJBQTBCLGtCQUFrQjtBQUM1Qzs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDLEdBQUc7QUFDSCxlQUFlLGFBQWE7QUFDNUIsV0FBVyw0QkFBb0I7QUFDL0IsR0FBRztBQUNILHNCQUFzQiwwQ0FBc0I7QUFDNUMsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsT0FBTyxpQkFBUTtBQUNmLHdCQUF3QixtQkFBbUIsQ0FBQyxvQ0FBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4Qzs7QUFFQSw2QkFBNkIsMEJBQWEsQ0FBQywwQkFBYSxDQUFDLDBCQUFhLEdBQUcsRUFBRSxtREFBcUIsR0FBRyxtREFBcUIsS0FBSztBQUM3SCxZQUFZLDhCQUFtQixFQUFFLDRCQUFpQixDQUFDLDJCQUFjLEdBQUcsMkJBQWM7QUFDbEYsY0FBYywyQkFBYztBQUM1QixVQUFVLDZCQUFnQjtBQUMxQixDQUFDO0FBQ0Q7QUFDQSxtQ0FBbUMsbUJBQW1CLENBQUMseUNBQWdCO0FBQ3ZFLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDTywrQ0FBK0MsVUFBVSxtQkFBbUIsOEJBQU87QUFDMUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1ncm91cC9lcy9oZWxwZXItbWV0aG9kcy5qcz9mNTU5Iiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LWdyb3VwL2VzL3ZpY3RvcnktZ3JvdXAuanM/M2Y4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2Fzc2lnbiBmcm9tIFwibG9kYXNoL2Fzc2lnblwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERhdGEsIEhlbHBlcnMsIFNjYWxlLCBXcmFwcGVyIH0gZnJvbSBcInZpY3RvcnktY29yZVwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcInJlYWN0LWZhc3QtY29tcGFyZVwiO1xudmFyIGZhbGxiYWNrUHJvcHMgPSB7XG4gIHdpZHRoOiA0NTAsXG4gIGhlaWdodDogMzAwLFxuICBwYWRkaW5nOiA1MCxcbiAgb2Zmc2V0OiAwXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWRQcm9wcyhwcm9wcywgY2hpbGRDb21wb25lbnRzKSB7XG4gIHZhciByb2xlID0gXCJncm91cFwiO1xuICBwcm9wcyA9IEhlbHBlcnMubW9kaWZ5UHJvcHMocHJvcHMsIGZhbGxiYWNrUHJvcHMsIHJvbGUpO1xuICB2YXIgc3R5bGUgPSBXcmFwcGVyLmdldFN0eWxlKHByb3BzLnRoZW1lLCBwcm9wcy5zdHlsZSwgcm9sZSk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIG9mZnNldCA9IF9wcm9wcy5vZmZzZXQsXG4gICAgICBjb2xvclNjYWxlID0gX3Byb3BzLmNvbG9yU2NhbGUsXG4gICAgICBjb2xvciA9IF9wcm9wcy5jb2xvcixcbiAgICAgIHBvbGFyID0gX3Byb3BzLnBvbGFyLFxuICAgICAgaG9yaXpvbnRhbCA9IF9wcm9wcy5ob3Jpem9udGFsO1xuICB2YXIgY2F0ZWdvcmllcyA9IHByb3BzLmNhdGVnb3JpZXMgfHwgV3JhcHBlci5nZXRDYXRlZ29yaWVzKHByb3BzLCBjaGlsZENvbXBvbmVudHMsIG51bGwpO1xuICB2YXIgZGF0YXNldHMgPSBwcm9wcy5kYXRhc2V0cyB8fCBXcmFwcGVyLmdldERhdGFGcm9tQ2hpbGRyZW4ocHJvcHMsIG51bGwpO1xuICB2YXIgZG9tYWluID0ge1xuICAgIHg6IFdyYXBwZXIuZ2V0RG9tYWluKF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgfSksIFwieFwiLCBjaGlsZENvbXBvbmVudHMpLFxuICAgIHk6IFdyYXBwZXIuZ2V0RG9tYWluKF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgfSksIFwieVwiLCBjaGlsZENvbXBvbmVudHMpXG4gIH07XG4gIHZhciByYW5nZSA9IHByb3BzLnJhbmdlIHx8IHtcbiAgICB4OiBIZWxwZXJzLmdldFJhbmdlKHByb3BzLCBcInhcIiksXG4gICAgeTogSGVscGVycy5nZXRSYW5nZShwcm9wcywgXCJ5XCIpXG4gIH07XG4gIHZhciBiYXNlU2NhbGUgPSB7XG4gICAgeDogU2NhbGUuZ2V0U2NhbGVGcm9tUHJvcHMocHJvcHMsIFwieFwiKSB8fCBXcmFwcGVyLmdldFNjYWxlKHByb3BzLCBcInhcIiksXG4gICAgeTogU2NhbGUuZ2V0U2NhbGVGcm9tUHJvcHMocHJvcHMsIFwieVwiKSB8fCBXcmFwcGVyLmdldFNjYWxlKHByb3BzLCBcInlcIilcbiAgfTtcbiAgdmFyIHNjYWxlID0ge1xuICAgIHg6IGJhc2VTY2FsZS54LmRvbWFpbihkb21haW4ueCkucmFuZ2UocHJvcHMuaG9yaXpvbnRhbCA/IHJhbmdlLnkgOiByYW5nZS54KSxcbiAgICB5OiBiYXNlU2NhbGUueS5kb21haW4oZG9tYWluLnkpLnJhbmdlKHByb3BzLmhvcml6b250YWwgPyByYW5nZS54IDogcmFuZ2UueSlcbiAgfTtcbiAgdmFyIG9yaWdpbiA9IHBvbGFyID8gcHJvcHMub3JpZ2luIDogSGVscGVycy5nZXRQb2xhck9yaWdpbihwcm9wcyk7XG4gIHZhciBwYWRkaW5nID0gSGVscGVycy5nZXRQYWRkaW5nKHByb3BzKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhc2V0czogZGF0YXNldHMsXG4gICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgZG9tYWluOiBkb21haW4sXG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGNvbG9yU2NhbGU6IGNvbG9yU2NhbGUsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIG9yaWdpbjogb3JpZ2luLFxuICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgfTtcbn0gLy8gV2UgbmVlZCB0byByZW1vdmUgc2hhcmVkRXZlbnRzIGluIG9yZGVyIHRvIG1lbW9pemUgdGhlIGNhbGN1bGF0ZWQgZGF0YVxuLy8gV2l0aCBzaGFyZWQgZXZlbnRzLCB0aGUgcHJvcHMgY2hhbmdlIG9uIGV2ZXJ5IGV2ZW50LCBhbmQgZXZlcnkgdmFsdWUgaXMgcmUtY2FsY3VsYXRlZFxuXG52YXIgd2l0aG91dFNoYXJlZEV2ZW50cyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIG1vZGlmaWVkQ2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQpLCB7fSwge1xuICAgICAgcHJvcHM6IEhlbHBlcnMub21pdChjaGlsZC5wcm9wcywgW1wic2hhcmVkRXZlbnRzXCJdKVxuICAgIH0pO1xuICB9KTtcbiAgcHJvcHMuY2hpbGRyZW4gPSBtb2RpZmllZENoaWxkcmVuO1xuICByZXR1cm4gcHJvcHM7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVtb2l6ZWRQcm9wcyhpbml0aWFsUHJvcHMpIHtcbiAgdmFyIG1vZGlmaWVkUHJvcHMgPSB3aXRob3V0U2hhcmVkRXZlbnRzKGluaXRpYWxQcm9wcyk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG1vZGlmaWVkUHJvcHMpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBwcm9wcyA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQcm9wcyA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07IC8vIFJlYWN0Lm1lbW8gdXNlcyBzaGFsbG93IGVxdWFsaXR5IHRvIGNvbXBhcmUgb2JqZWN0cy4gVGhpcyB3YXkgcHJvcHNcbiAgLy8gd2lsbCBvbmx5IGJlIHJlLWNhbGN1bGF0ZWQgd2hlbiB0aGV5IGNoYW5nZS5cblxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0VxdWFsKG1vZGlmaWVkUHJvcHMsIHByb3BzKSkge1xuICAgICAgc2V0UHJvcHMobW9kaWZpZWRQcm9wcyk7XG4gICAgfVxuICB9LCBbcHJvcHMsIHNldFByb3BzLCBtb2RpZmllZFByb3BzXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Q2FsY3VsYXRlZFByb3BzKHByb3BzLCBwcm9wcy5jaGlsZHJlbik7XG4gIH0sIFtwcm9wc10pO1xufVxuXG5mdW5jdGlvbiBwaXhlbHNUb1ZhbHVlKHByb3BzLCBheGlzLCBjYWxjdWxhdGVkUHJvcHMpIHtcbiAgaWYgKCFwcm9wcy5vZmZzZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBjdXJyZW50QXhpcyA9IEhlbHBlcnMuZ2V0Q3VycmVudEF4aXMoYXhpcywgcHJvcHMuaG9yaXpvbnRhbCk7XG4gIHZhciBkb21haW4gPSBjYWxjdWxhdGVkUHJvcHMuZG9tYWluW2F4aXNdO1xuICB2YXIgcmFuZ2UgPSBjYWxjdWxhdGVkUHJvcHMucmFuZ2VbY3VycmVudEF4aXNdO1xuICB2YXIgZG9tYWluRXh0ZW50ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGRvbWFpbikpIC0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGRvbWFpbikpO1xuICB2YXIgcmFuZ2VFeHRlbnQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkocmFuZ2UpKSAtIE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShyYW5nZSkpO1xuICByZXR1cm4gZG9tYWluRXh0ZW50IC8gcmFuZ2VFeHRlbnQgKiBwcm9wcy5vZmZzZXQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cblxuZnVuY3Rpb24gZ2V0WDAocHJvcHMsIGNhbGN1bGF0ZWRQcm9wcywgaW5kZXgsIHJvbGUpIHtcbiAgdmFyIGdyb3VwTGVuZ3RoID0gcm9sZSA9PT0gXCJzdGFja1wiID8gY2FsY3VsYXRlZFByb3BzLmRhdGFzZXRzWzBdLmxlbmd0aCA6IGNhbGN1bGF0ZWRQcm9wcy5kYXRhc2V0cy5sZW5ndGg7XG4gIHZhciBjZW50ZXIgPSAoZ3JvdXBMZW5ndGggLSAxKSAvIDI7XG4gIHZhciB0b3RhbFdpZHRoID0gcGl4ZWxzVG9WYWx1ZShwcm9wcywgXCJ4XCIsIGNhbGN1bGF0ZWRQcm9wcyk7XG4gIHJldHVybiAoaW5kZXggLSBjZW50ZXIpICogdG90YWxXaWR0aDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblxuXG5mdW5jdGlvbiBnZXRQb2xhclgwKHByb3BzLCBjYWxjdWxhdGVkUHJvcHMsIGluZGV4LCByb2xlKSB7XG4gIHZhciBncm91cExlbmd0aCA9IHJvbGUgPT09IFwic3RhY2tcIiA/IGNhbGN1bGF0ZWRQcm9wcy5kYXRhc2V0c1swXS5sZW5ndGggOiBjYWxjdWxhdGVkUHJvcHMuZGF0YXNldHMubGVuZ3RoO1xuICB2YXIgY2VudGVyID0gKGdyb3VwTGVuZ3RoIC0gMSkgLyAyO1xuICB2YXIgd2lkdGggPSBnZXRBbmd1bGFyV2lkdGgocHJvcHMsIGNhbGN1bGF0ZWRQcm9wcyk7XG4gIHJldHVybiAoaW5kZXggLSBjZW50ZXIpICogd2lkdGg7XG59XG5cbmZ1bmN0aW9uIGdldEFuZ3VsYXJXaWR0aChwcm9wcywgY2FsY3VsYXRlZFByb3BzKSB7XG4gIHZhciByYW5nZSA9IGNhbGN1bGF0ZWRQcm9wcy5yYW5nZTtcbiAgdmFyIGFuZ3VsYXJSYW5nZSA9IE1hdGguYWJzKHJhbmdlLnhbMV0gLSByYW5nZS54WzBdKTtcbiAgdmFyIHIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkocmFuZ2UueSkpO1xuICByZXR1cm4gcHJvcHMub2Zmc2V0IC8gKDIgKiBNYXRoLlBJICogcikgKiBhbmd1bGFyUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIGdldExhYmVscyhwcm9wcywgZGF0YXNldHMsIGluZGV4KSB7XG4gIGlmICghcHJvcHMubGFiZWxzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGFzZXRzLmxlbmd0aCAvIDIpID09PSBpbmRleCA/IHByb3BzLmxhYmVscyA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFByb3BzKSB7XG4gIHZhciBjYXRlZ29yaWVzID0gY2FsY3VsYXRlZFByb3BzLmNhdGVnb3JpZXMsXG4gICAgICBkb21haW4gPSBjYWxjdWxhdGVkUHJvcHMuZG9tYWluLFxuICAgICAgcmFuZ2UgPSBjYWxjdWxhdGVkUHJvcHMucmFuZ2UsXG4gICAgICBzY2FsZSA9IGNhbGN1bGF0ZWRQcm9wcy5zY2FsZSxcbiAgICAgIGhvcml6b250YWwgPSBjYWxjdWxhdGVkUHJvcHMuaG9yaXpvbnRhbCxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRQcm9wcy5vcmlnaW4sXG4gICAgICBwYWRkaW5nID0gY2FsY3VsYXRlZFByb3BzLnBhZGRpbmc7XG4gIHZhciB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgdGhlbWUgPSBwcm9wcy50aGVtZSxcbiAgICAgIHBvbGFyID0gcHJvcHMucG9sYXI7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIHRoZW1lOiB0aGVtZSxcbiAgICBwb2xhcjogcG9sYXIsXG4gICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcbiAgICBkb21haW46IGRvbWFpbixcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBzdGFuZGFsb25lOiBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb2xvclNjYWxlKHByb3BzLCBjaGlsZCkge1xuICB2YXIgcm9sZSA9IGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5yb2xlO1xuICB2YXIgY29sb3JTY2FsZU9wdGlvbnMgPSBjaGlsZC5wcm9wcy5jb2xvclNjYWxlIHx8IHByb3BzLmNvbG9yU2NhbGU7XG5cbiAgaWYgKHJvbGUgIT09IFwiZ3JvdXBcIiAmJiByb2xlICE9PSBcInN0YWNrXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzLnRoZW1lICYmIHByb3BzLnRoZW1lLmdyb3VwID8gY29sb3JTY2FsZU9wdGlvbnMgfHwgcHJvcHMudGhlbWUuZ3JvdXAuY29sb3JTY2FsZSA6IGNvbG9yU2NhbGVPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhV2l0aE9mZnNldChwcm9wcykge1xuICB2YXIgZGVmYXVsdERhdGFzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBkYXRhc2V0ID0gcHJvcHMuZGF0YSB8fCBwcm9wcy55ID8gRGF0YS5nZXREYXRhKHByb3BzKSA6IGRlZmF1bHREYXRhc2V0O1xuICB2YXIgeE9mZnNldCA9IG9mZnNldCB8fCAwO1xuICByZXR1cm4gZGF0YXNldC5tYXAoZnVuY3Rpb24gKGRhdHVtKSB7XG4gICAgdmFyIF94MSA9IGRhdHVtLl94IGluc3RhbmNlb2YgRGF0ZSA/IG5ldyBEYXRlKGRhdHVtLl94LmdldFRpbWUoKSArIHhPZmZzZXQpIDogZGF0dW0uX3ggKyB4T2Zmc2V0O1xuXG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIGRhdHVtLCB7XG4gICAgICBfeDE6IF94MVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKHByb3BzLCBjaGlsZENvbXBvbmVudHMsIGNhbGN1bGF0ZWRQcm9wcykge1xuICBwcm9wcyA9IEhlbHBlcnMubW9kaWZ5UHJvcHMocHJvcHMsIGZhbGxiYWNrUHJvcHMsIFwic3RhY2tcIik7XG4gIGNoaWxkQ29tcG9uZW50cyA9IGNoaWxkQ29tcG9uZW50cyB8fCBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgY2FsY3VsYXRlZFByb3BzID0gY2FsY3VsYXRlZFByb3BzIHx8IGdldENhbGN1bGF0ZWRQcm9wcyhwcm9wcywgY2hpbGRDb21wb25lbnRzKTtcbiAgdmFyIF9jYWxjdWxhdGVkUHJvcHMgPSBjYWxjdWxhdGVkUHJvcHMsXG4gICAgICBkYXRhc2V0cyA9IF9jYWxjdWxhdGVkUHJvcHMuZGF0YXNldHM7XG4gIHZhciBfcHJvcHMyID0gcHJvcHMsXG4gICAgICBsYWJlbENvbXBvbmVudCA9IF9wcm9wczIubGFiZWxDb21wb25lbnQsXG4gICAgICBwb2xhciA9IF9wcm9wczIucG9sYXI7XG4gIHZhciBjaGlsZFByb3BzID0gZ2V0Q2hpbGRQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWUgPSBwcm9wcy5uYW1lIHx8IFwiZ3JvdXBcIjtcbiAgcmV0dXJuIGNoaWxkQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIHZhciByb2xlID0gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLnJvbGU7XG4gICAgdmFyIHhPZmZzZXQgPSBwb2xhciA/IGdldFBvbGFyWDAocHJvcHMsIGNhbGN1bGF0ZWRQcm9wcywgaW5kZXgsIHJvbGUpIDogZ2V0WDAocHJvcHMsIGNhbGN1bGF0ZWRQcm9wcywgaW5kZXgsIHJvbGUpO1xuICAgIHZhciBzdHlsZSA9IHJvbGUgPT09IFwidm9yb25vaVwiIHx8IHJvbGUgPT09IFwidG9vbHRpcFwiIHx8IHJvbGUgPT09IFwibGFiZWxcIiA/IGNoaWxkLnByb3BzLnN0eWxlIDogV3JhcHBlci5nZXRDaGlsZFN0eWxlKGNoaWxkLCBpbmRleCwgY2FsY3VsYXRlZFByb3BzKTtcbiAgICB2YXIgbGFiZWxzID0gcHJvcHMubGFiZWxzID8gZ2V0TGFiZWxzKHByb3BzLCBkYXRhc2V0cywgaW5kZXgpIDogY2hpbGQucHJvcHMubGFiZWxzO1xuICAgIHZhciBuYW1lID0gY2hpbGQucHJvcHMubmFtZSB8fCBcIlwiLmNvbmNhdChwYXJlbnROYW1lLCBcIi1cIikuY29uY2F0KHJvbGUsIFwiLVwiKS5jb25jYXQoaW5kZXgpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBfYXNzaWduKHtcbiAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChuYW1lLCBcIi1rZXktXCIpLmNvbmNhdChpbmRleCksXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGF0YTogZ2V0RGF0YVdpdGhPZmZzZXQocHJvcHMsIGRhdGFzZXRzW2luZGV4XSwgeE9mZnNldCksXG4gICAgICBjb2xvclNjYWxlOiBnZXRDb2xvclNjYWxlKHByb3BzLCBjaGlsZCksXG4gICAgICBsYWJlbENvbXBvbmVudDogbGFiZWxDb21wb25lbnQgfHwgY2hpbGQucHJvcHMubGFiZWxDb21wb25lbnQsXG4gICAgICB4T2Zmc2V0OiB4T2Zmc2V0XG4gICAgfSwgY2hpbGRQcm9wcykpO1xuICB9KTtcbn0iLCJpbXBvcnQgX2lzRW1wdHkgZnJvbSBcImxvZGFzaC9pc0VtcHR5XCI7XG5pbXBvcnQgX2RlZmF1bHRzIGZyb20gXCJsb2Rhc2gvZGVmYXVsdHNcIjtcbmltcG9ydCBfYXNzaWduIGZyb20gXCJsb2Rhc2gvYXNzaWduXCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENvbW1vblByb3BzLCBIZWxwZXJzLCBIb29rcywgVXNlclByb3BzLCBWaWN0b3J5Q29udGFpbmVyLCBWaWN0b3J5VGhlbWUsIFdyYXBwZXIgfSBmcm9tIFwidmljdG9yeS1jb3JlXCI7XG5pbXBvcnQgeyBWaWN0b3J5U2hhcmVkRXZlbnRzIH0gZnJvbSBcInZpY3Rvcnktc2hhcmVkLWV2ZW50c1wiO1xuaW1wb3J0IHsgZ2V0Q2hpbGRyZW4sIHVzZU1lbW9pemVkUHJvcHMgfSBmcm9tIFwiLi9oZWxwZXItbWV0aG9kc1wiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcInJlYWN0LWZhc3QtY29tcGFyZVwiO1xudmFyIGZhbGxiYWNrUHJvcHMgPSB7XG4gIHdpZHRoOiA0NTAsXG4gIGhlaWdodDogMzAwLFxuICBwYWRkaW5nOiA1MCxcbiAgb2Zmc2V0OiAwXG59O1xuXG52YXIgVmljdG9yeUdyb3VwQmFzZSA9IGZ1bmN0aW9uIChpbml0aWFsUHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHZhciByb2xlID0gVmljdG9yeUdyb3VwID09PSBudWxsIHx8IFZpY3RvcnlHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogVmljdG9yeUdyb3VwLnJvbGU7XG5cbiAgdmFyIF9Ib29rcyR1c2VBbmltYXRpb25TdCA9IEhvb2tzLnVzZUFuaW1hdGlvblN0YXRlKCksXG4gICAgICBnZXRBbmltYXRpb25Qcm9wcyA9IF9Ib29rcyR1c2VBbmltYXRpb25TdC5nZXRBbmltYXRpb25Qcm9wcyxcbiAgICAgIHNldEFuaW1hdGlvblN0YXRlID0gX0hvb2tzJHVzZUFuaW1hdGlvblN0LnNldEFuaW1hdGlvblN0YXRlLFxuICAgICAgZ2V0UHJvcHMgPSBfSG9va3MkdXNlQW5pbWF0aW9uU3QuZ2V0UHJvcHM7XG5cbiAgdmFyIHByb3BzID0gZ2V0UHJvcHMoaW5pdGlhbFByb3BzKTtcbiAgdmFyIG1vZGlmaWVkUHJvcHMgPSBIZWxwZXJzLm1vZGlmeVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzLCByb2xlKTtcbiAgdmFyIGV2ZW50S2V5ID0gbW9kaWZpZWRQcm9wcy5ldmVudEtleSxcbiAgICAgIGNvbnRhaW5lckNvbXBvbmVudCA9IG1vZGlmaWVkUHJvcHMuY29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgc3RhbmRhbG9uZSA9IG1vZGlmaWVkUHJvcHMuc3RhbmRhbG9uZSxcbiAgICAgIGdyb3VwQ29tcG9uZW50ID0gbW9kaWZpZWRQcm9wcy5ncm91cENvbXBvbmVudCxcbiAgICAgIGV4dGVybmFsRXZlbnRNdXRhdGlvbnMgPSBtb2RpZmllZFByb3BzLmV4dGVybmFsRXZlbnRNdXRhdGlvbnMsXG4gICAgICB3aWR0aCA9IG1vZGlmaWVkUHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBtb2RpZmllZFByb3BzLmhlaWdodCxcbiAgICAgIHRoZW1lID0gbW9kaWZpZWRQcm9wcy50aGVtZSxcbiAgICAgIHBvbGFyID0gbW9kaWZpZWRQcm9wcy5wb2xhcixcbiAgICAgIGhvcml6b250YWwgPSBtb2RpZmllZFByb3BzLmhvcml6b250YWwsXG4gICAgICBuYW1lID0gbW9kaWZpZWRQcm9wcy5uYW1lO1xuICB2YXIgY2hpbGRDb21wb25lbnRzID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShtb2RpZmllZFByb3BzLmNoaWxkcmVuKTtcbiAgdmFyIGNhbGN1bGF0ZWRQcm9wcyA9IHVzZU1lbW9pemVkUHJvcHMobW9kaWZpZWRQcm9wcyk7XG4gIHZhciBkb21haW4gPSBjYWxjdWxhdGVkUHJvcHMuZG9tYWluLFxuICAgICAgc2NhbGUgPSBjYWxjdWxhdGVkUHJvcHMuc2NhbGUsXG4gICAgICBzdHlsZSA9IGNhbGN1bGF0ZWRQcm9wcy5zdHlsZSxcbiAgICAgIG9yaWdpbiA9IGNhbGN1bGF0ZWRQcm9wcy5vcmlnaW47XG4gIHZhciBuZXdDaGlsZHJlbiA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGdldENoaWxkcmVuKHByb3BzLCBjaGlsZENvbXBvbmVudHMsIGNhbGN1bGF0ZWRQcm9wcyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGRQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICBhbmltYXRlOiBnZXRBbmltYXRpb25Qcm9wcyhwcm9wcywgY2hpbGQsIGluZGV4KVxuICAgICAgfSwgY2hpbGQucHJvcHMpO1xuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gICAgfSk7XG4gIH0sIFtwcm9wcywgY2hpbGRDb21wb25lbnRzLCBjYWxjdWxhdGVkUHJvcHMsIGdldEFuaW1hdGlvblByb3BzXSk7XG4gIHZhciBjb250YWluZXJQcm9wcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBzdGFuZGFsb25lOiBzdGFuZGFsb25lLFxuICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZS5wYXJlbnQsXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgICAgIHBvbGFyOiBwb2xhcixcbiAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9LCBbc3RhbmRhbG9uZSwgZG9tYWluLCBzY2FsZSwgd2lkdGgsIGhlaWdodCwgdGhlbWUsIHN0eWxlLCBob3Jpem9udGFsLCBwb2xhciwgb3JpZ2luLCBuYW1lXSk7XG4gIHZhciB1c2VyUHJvcHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVXNlclByb3BzLmdldFNhZmVVc2VyUHJvcHMoaW5pdGlhbFByb3BzKTtcbiAgfSwgW2luaXRpYWxQcm9wc10pO1xuICB2YXIgY29udGFpbmVyID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBkZWZhdWx0Q29udGFpbmVyUHJvcHMgPSBfZGVmYXVsdHMoe30sIGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcywgY29udGFpbmVyUHJvcHMsIHVzZXJQcm9wcyk7XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNvbnRhaW5lckNvbXBvbmVudCwgZGVmYXVsdENvbnRhaW5lclByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChncm91cENvbXBvbmVudCwgdXNlclByb3BzKTtcbiAgfSwgW2dyb3VwQ29tcG9uZW50LCBzdGFuZGFsb25lLCBjb250YWluZXJDb21wb25lbnQsIGNvbnRhaW5lclByb3BzLCB1c2VyUHJvcHNdKTtcbiAgdmFyIGV2ZW50cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBXcmFwcGVyLmdldEFsbEV2ZW50cyhwcm9wcyk7XG4gIH0sIFtwcm9wc10pO1xuICB2YXIgcHJldmlvdXNQcm9wcyA9IEhvb2tzLnVzZVByZXZpb3VzUHJvcHMoaW5pdGlhbFByb3BzKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgZGlzbW91bnQgdG8ga2VlcCBzdGF0ZSBpbiBzeW5jXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbml0aWFsUHJvcHMuYW5pbWF0ZSkge1xuICAgICAgICBzZXRBbmltYXRpb25TdGF0ZShwcmV2aW91c1Byb3BzLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3NldEFuaW1hdGlvblN0YXRlLCBwcmV2aW91c1Byb3BzLCBpbml0aWFsUHJvcHMsIHByb3BzXSk7XG5cbiAgaWYgKCFfaXNFbXB0eShldmVudHMpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlTaGFyZWRFdmVudHMsIHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgZXZlbnRLZXk6IGV2ZW50S2V5LFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBleHRlcm5hbEV2ZW50TXV0YXRpb25zOiBleHRlcm5hbEV2ZW50TXV0YXRpb25zXG4gICAgfSwgbmV3Q2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY29udGFpbmVyLCBjb250YWluZXIucHJvcHMsIG5ld0NoaWxkcmVuKTtcbn07XG5cblZpY3RvcnlHcm91cEJhc2UucHJvcFR5cGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIENvbW1vblByb3BzLmJhc2VQcm9wcyksIENvbW1vblByb3BzLmRhdGFQcm9wcyksIHt9LCB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksIFByb3BUeXBlcy5ub2RlXSksXG4gIGhvcml6b250YWw6IFByb3BUeXBlcy5ib29sLFxuICBvZmZzZXQ6IFByb3BUeXBlcy5udW1iZXJcbn0pO1xuVmljdG9yeUdyb3VwQmFzZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRhaW5lckNvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUNvbnRhaW5lciwgbnVsbCksXG4gIGdyb3VwQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCksXG4gIHNhbXBsZXM6IDUwLFxuICBzb3J0T3JkZXI6IFwiYXNjZW5kaW5nXCIsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIHRoZW1lOiBWaWN0b3J5VGhlbWUuZ3JheXNjYWxlXG59O1xudmFyIGNvbXBvbmVudENvbmZpZyA9IHtcbiAgcm9sZTogXCJncm91cFwiLFxuICBleHBlY3RlZENvbXBvbmVudHM6IFtcImdyb3VwQ29tcG9uZW50XCIsIFwiY29udGFpbmVyQ29tcG9uZW50XCIsIFwibGFiZWxDb21wb25lbnRcIl0sXG4gIGdldENoaWxkcmVuOiBnZXRDaGlsZHJlblxufTtcbmV4cG9ydCB2YXIgVmljdG9yeUdyb3VwID0gT2JqZWN0LmFzc2lnbiggLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oVmljdG9yeUdyb3VwQmFzZSwgaXNFcXVhbCksIGNvbXBvbmVudENvbmZpZyk7XG5WaWN0b3J5R3JvdXAuZGlzcGxheU5hbWUgPSBcIlZpY3RvcnlHcm91cFwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54878\n')}}]);