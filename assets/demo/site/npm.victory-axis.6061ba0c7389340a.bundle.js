"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[8095],{73091:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "E": () => (/* binding */ VictoryAxis)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__(41609);\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/axis.js\nvar victory_util_axis = __webpack_require__(92555);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/textsize.js\nvar textsize = __webpack_require__(82254);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/user-props.js\nvar user_props = __webpack_require__(80450);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/common-props.js\nvar common_props = __webpack_require__(5734);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/line-segment.js + 1 modules\nvar line_segment = __webpack_require__(85287);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-label/victory-label.js + 2 modules\nvar victory_label = __webpack_require__(41248);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/add-events.js + 3 modules\nvar add_events = __webpack_require__(73247);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/scale.js\nvar victory_util_scale = __webpack_require__(74765);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n;// CONCATENATED MODULE: ./node_modules/victory-axis/es/helper-methods.js\n\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar orientationSign = {\n  top: -1,\n  left: -1,\n  right: 1,\n  bottom: 1\n};\n\nvar exists = function (val) {\n  return val !== null && val !== undefined;\n};\n\nvar getCurrentAxis = function (props, axis) {\n  var orientation = props.orientation,\n      horizontal = props.horizontal;\n\n  if (orientation) {\n    var dimensions = {\n      top: "x",\n      bottom: "x",\n      left: "y",\n      right: "y"\n    };\n    return dimensions[orientation];\n  }\n\n  var otherAxis = axis === "x" ? "y" : "x";\n  return horizontal ? otherAxis : axis;\n};\n\nvar getScale = function (props) {\n  var axis = victory_util_axis/* getAxis */.dd(props);\n  var currentAxis = getCurrentAxis(props, axis);\n  var scale = victory_util_scale/* getBaseScale */.q8(props, axis);\n  var propsDomain = props.domain && props.domain[axis];\n  var domain = propsDomain || victory_util_axis/* getDomain */.ge(props) || scale.domain();\n  scale.range(helpers/* getRange */.rx(props, currentAxis));\n  scale.domain(domain);\n  return scale;\n};\n\nvar getStyleObject = function (props) {\n  var theme = props.theme,\n      dependentAxis = props.dependentAxis;\n  var generalAxisStyle = theme && theme.axis && theme.axis.style;\n  var axisType = dependentAxis ? "dependentAxis" : "independentAxis";\n  var specificAxisStyle = theme && theme[axisType] && theme[axisType].style;\n\n  var mergeStyles = function () {\n    var styleNamespaces = ["axis", "axisLabel", "grid", "parent", "tickLabels", "ticks"];\n    return styleNamespaces.reduce(function (memo, curr) {\n      memo[curr] = defaults_default()({}, specificAxisStyle[curr], generalAxisStyle[curr]);\n      return memo;\n    }, {});\n  };\n\n  return generalAxisStyle && specificAxisStyle ? mergeStyles() : specificAxisStyle || generalAxisStyle;\n};\n\nvar getStyles = function (props, styleObject) {\n  var style = props.style || {};\n  styleObject = styleObject || {};\n  var parentStyleProps = {\n    height: "100%",\n    width: "100%"\n  };\n  return {\n    parent: defaults_default()(style.parent, styleObject.parent, parentStyleProps),\n    axis: defaults_default()({}, style.axis, styleObject.axis),\n    axisLabel: defaults_default()({}, style.axisLabel, styleObject.axisLabel),\n    grid: defaults_default()({}, style.grid, styleObject.grid),\n    ticks: defaults_default()({}, style.ticks, styleObject.ticks),\n    tickLabels: defaults_default()({}, style.tickLabels, styleObject.tickLabels)\n  };\n};\n\nvar getTickProps = function (layout, style, datum) {\n  var position = layout.position,\n      transform = layout.transform;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: transform.x + position.x2,\n    y2: transform.y + position.y2,\n    style: style,\n    datum: datum\n  };\n}; // eslint-disable-next-line max-params\n\n\nvar getTickLabelProps = function (layout, style, anchors, datum, text) {\n  var position = layout.position,\n      transform = layout.transform;\n  return {\n    style: style,\n    x: transform.x + position.x,\n    y: transform.y + position.y,\n    verticalAnchor: anchors.verticalAnchor,\n    textAnchor: anchors.textAnchor,\n    angle: style.angle,\n    text: text,\n    datum: datum\n  };\n};\n\nvar getGridProps = function (layout, style, datum) {\n  var edge = layout.edge,\n      transform = layout.transform;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: edge.x + transform.x,\n    y2: edge.y + transform.y,\n    style: style,\n    datum: datum\n  };\n};\n\nvar getAxisProps = function (modifiedProps, calculatedValues, globalTransform) {\n  var style = calculatedValues.style,\n      padding = calculatedValues.padding,\n      isVertical = calculatedValues.isVertical;\n  var width = modifiedProps.width,\n      height = modifiedProps.height;\n  return {\n    style: style.axis,\n    x1: isVertical ? globalTransform.x : padding.left + globalTransform.x,\n    x2: isVertical ? globalTransform.x : width - padding.right + globalTransform.x,\n    y1: isVertical ? padding.top + globalTransform.y : globalTransform.y,\n    y2: isVertical ? height - padding.bottom + globalTransform.y : globalTransform.y\n  };\n};\n\nvar getEvaluatedStyles = function (style, props) {\n  return {\n    tickStyle: helpers/* evaluateStyle */.F3(style.ticks, props),\n    labelStyle: helpers/* evaluateStyle */.F3(style.tickLabels, props),\n    gridStyle: helpers/* evaluateStyle */.F3(style.grid, props)\n  };\n};\n\nvar getAxisLabelProps = function (props, calculatedValues, globalTransform) {\n  var style = calculatedValues.style,\n      orientation = calculatedValues.orientation,\n      padding = calculatedValues.padding,\n      labelPadding = calculatedValues.labelPadding,\n      isVertical = calculatedValues.isVertical;\n  var sign = orientationSign[orientation];\n  var hPadding = padding.left + padding.right;\n  var vPadding = padding.top + padding.bottom;\n  var verticalAnchor = sign < 0 ? "end" : "start";\n  var labelStyle = style.axisLabel;\n  var angle = isVertical ? -90 : 0; // eslint-disable-line no-magic-numbers\n\n  var x = isVertical ? globalTransform.x + sign * labelPadding : (props.width - hPadding) / 2 + padding.left + globalTransform.x;\n  var y = isVertical ? (props.height - vPadding) / 2 + padding.top + globalTransform.y : sign * labelPadding + globalTransform.y;\n  return {\n    x: x,\n    y: y,\n    verticalAnchor: labelStyle.verticalAnchor || verticalAnchor,\n    textAnchor: labelStyle.textAnchor || "middle",\n    angle: labelStyle.angle === undefined ? angle : labelStyle.angle,\n    style: labelStyle,\n    text: props.label\n  };\n};\n\nvar getAnchors = function (orientation, isVertical) {\n  var anchorOrientation = {\n    top: "end",\n    left: "end",\n    right: "start",\n    bottom: "start"\n  };\n  var anchor = anchorOrientation[orientation];\n  return {\n    textAnchor: isVertical ? anchor : "middle",\n    verticalAnchor: isVertical ? "middle" : anchor\n  };\n};\n\nvar getLabelPadding = function (props, style) {\n  var labelStyle = style.axisLabel || {};\n\n  if (labelStyle.padding !== undefined && labelStyle.padding !== null) {\n    return labelStyle.padding;\n  }\n\n  var isVertical = victory_util_axis/* isVertical */.cp(props); // TODO: magic numbers\n\n  /* eslint-disable no-magic-numbers*/\n\n  var fontSize = labelStyle.fontSize || 14;\n  return props.label ? fontSize * (isVertical ? 2.3 : 1.6) : 0;\n  /* eslint-enable no-magic-numbers*/\n};\n\nvar getDefaultOrientations = function (axis, originSign, horizontal) {\n  var sign = originSign || "positive";\n  var orientations = {\n    positive: {\n      x: "bottom",\n      y: "left"\n    },\n    negative: {\n      x: "top",\n      y: "right"\n    }\n  };\n  var horizontalOrientations = {\n    positive: {\n      x: "left",\n      y: "bottom"\n    },\n    negative: {\n      x: "right",\n      y: "top"\n    }\n  };\n  return horizontal ? horizontalOrientations[sign][axis] : orientations[sign][axis];\n};\n\nvar getStandaloneOffset = function (props, calculatedValues) {\n  var style = calculatedValues.style,\n      scale = calculatedValues.scale,\n      orientation = calculatedValues.orientation,\n      padding = calculatedValues.padding,\n      axis = calculatedValues.axis,\n      ticks = calculatedValues.ticks,\n      stringTicks = calculatedValues.stringTicks,\n      isVertical = calculatedValues.isVertical,\n      labelPadding = calculatedValues.labelPadding;\n  var polar = props.polar,\n      horizontal = props.horizontal;\n  var sharedProps = {\n    scale: _defineProperty({}, axis, scale),\n    polar: polar,\n    horizontal: horizontal,\n    ticks: ticks,\n    stringTicks: stringTicks\n  };\n  var xPadding = orientation === "right" ? padding.right : padding.left;\n  var yPadding = orientation === "top" ? padding.top : padding.bottom;\n  var offsetX = props.offsetX !== null && props.offsetX !== undefined ? props.offsetX : xPadding;\n  var offsetY = props.offsetY !== null && props.offsetY !== undefined ? props.offsetY : yPadding;\n  var fontSize = style.axisLabel.fontSize || 14; // eslint-disable-line no-magic-numbers\n\n  var tickSizes = ticks.map(function (data, index) {\n    var tick = stringTicks ? props.tickValues[data - 1] : data;\n    var tickStyle = helpers/* evaluateStyle */.F3(style.ticks, assign_default()({}, sharedProps, {\n      tick: tick,\n      index: index\n    }));\n    return tickStyle.size || 0;\n  });\n  var totalPadding = fontSize + 2 * Math.max.apply(Math, _toConsumableArray(tickSizes)) + labelPadding;\n  var minimumPadding = 1.2 * fontSize; // eslint-disable-line no-magic-numbers\n\n  var x = isVertical ? totalPadding : minimumPadding;\n  var y = isVertical ? minimumPadding : totalPadding;\n  return {\n    x: offsetX !== null && offsetX !== undefined ? offsetX : x,\n    y: offsetY !== null && offsetY !== undefined ? offsetY : y\n  };\n}; // eslint-disable-next-line complexity\n\n\nvar getOffset = function (props, calculatedValues) {\n  var scale = calculatedValues.scale,\n      origin = calculatedValues.origin,\n      orientation = calculatedValues.orientation,\n      orientations = calculatedValues.orientations,\n      domain = calculatedValues.domain,\n      padding = calculatedValues.padding;\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  var calculatedOrientation = {\n    x: orientation === "bottom" || orientation === "top" ? orientation : orientations.x,\n    y: orientation === "left" || orientation === "right" ? orientation : orientations.y\n  }; // make the axes line up, and cross when appropriate\n\n  var orientationOffset = {\n    x: calculatedOrientation.y === "left" ? left : right,\n    y: calculatedOrientation.x === "bottom" ? bottom : top\n  };\n  var originOffset = {\n    x: calculatedOrientation.y === "left" ? 0 : props.width,\n    y: calculatedOrientation.x === "bottom" ? props.height : 0\n  };\n  var originPosition = {\n    x: origin.x === domain.x[0] || origin.x === domain.x[1] ? 0 : scale.x(origin.x),\n    y: origin.y === domain.y[0] || origin.y === domain.y[1] ? 0 : scale.y(origin.y)\n  };\n  var x = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  var y = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  var offsetX = exists(props.offsetX) ? props.offsetX : x;\n  var offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}; // eslint-disable-next-line complexity\n\n\nvar getHorizontalOffset = function (props, calculatedValues) {\n  var scale = calculatedValues.scale,\n      origin = calculatedValues.origin,\n      orientation = calculatedValues.orientation,\n      orientations = calculatedValues.orientations,\n      domain = calculatedValues.domain,\n      padding = calculatedValues.padding;\n  var top = padding.top,\n      bottom = padding.bottom,\n      left = padding.left,\n      right = padding.right;\n  var calculatedOrientation = {\n    y: orientation === "bottom" || orientation === "top" ? orientation : orientations.x,\n    x: orientation === "left" || orientation === "right" ? orientation : orientations.y\n  }; // make the axes line up, and cross when appropriate\n\n  var orientationOffset = {\n    x: calculatedOrientation.y === "bottom" ? bottom : top,\n    y: calculatedOrientation.x === "left" ? left : right\n  };\n  var originOffset = {\n    y: calculatedOrientation.x === "left" ? 0 : props.width,\n    x: calculatedOrientation.y === "bottom" ? props.height : 0\n  };\n  var originPosition = {\n    x: origin.x === domain.x[0] || origin.x === domain.x[1] ? 0 : scale.x(origin.x),\n    y: origin.y === domain.y[0] || origin.y === domain.y[1] ? 0 : scale.y(origin.y)\n  };\n  var y = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  var x = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  var offsetX = exists(props.offsetX) ? props.offsetX : x;\n  var offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n};\n\nvar getTransform = function (props, calculatedValues, offset) {\n  var orientation = calculatedValues.orientation,\n      axis = calculatedValues.axis;\n  var axisValue = victory_util_axis/* getAxisValue */.w5(props, axis);\n  return {\n    top: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : offset.y\n    },\n    bottom: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : props.height - offset.y\n    },\n    left: {\n      x: axisValue !== undefined ? axisValue : offset.x,\n      y: 0\n    },\n    right: {\n      x: axisValue !== undefined ? axisValue : props.width - offset.x,\n      y: 0\n    }\n  }[orientation];\n};\n\nvar getTickPosition = function (style, orientation, isVertical) {\n  var tickStyle = style.tickStyle,\n      labelStyle = style.labelStyle;\n  var size = tickStyle.size || 0;\n  var tickPadding = tickStyle.padding || 0;\n  var labelPadding = labelStyle.padding || 0;\n  var tickSpacing = size + tickPadding + labelPadding;\n  var sign = orientationSign[orientation];\n  return {\n    x: isVertical ? sign * tickSpacing : 0,\n    x2: isVertical ? sign * size : 0,\n    y: isVertical ? 0 : sign * tickSpacing,\n    y2: isVertical ? 0 : sign * size\n  };\n};\n\nvar getTickTransform = function (tick, globalTransform, isVertical) {\n  return {\n    x: isVertical ? globalTransform.x : tick + globalTransform.x,\n    y: isVertical ? tick + globalTransform.y : globalTransform.y\n  };\n};\n\nvar getGridEdge = function (props, calculatedValues) {\n  var orientation = calculatedValues.orientation,\n      padding = calculatedValues.padding,\n      isVertical = calculatedValues.isVertical;\n  var sign = -orientationSign[orientation];\n  var x = isVertical ? sign * (props.width - (padding.left + padding.right)) : 0;\n  var y = isVertical ? 0 : sign * (props.height - (padding.top + padding.bottom));\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar getGridOffset = function (calculatedValues, offset) {\n  var padding = calculatedValues.padding,\n      orientation = calculatedValues.orientation,\n      crossAxis = calculatedValues.crossAxis;\n  var xPadding = orientation === "right" ? padding.right : padding.left;\n  var yPadding = orientation === "top" ? padding.top : padding.bottom;\n  return {\n    x: crossAxis ? offset.x - xPadding : 0,\n    y: crossAxis ? offset.y - yPadding : 0\n  };\n};\n\nvar getLayoutProps = function (modifiedProps, calculatedValues) {\n  var offset;\n\n  if (calculatedValues.domain.x && calculatedValues.domain.y) {\n    offset = modifiedProps.horizontal ? getHorizontalOffset(modifiedProps, calculatedValues) : getOffset(modifiedProps, calculatedValues);\n  } else {\n    offset = getStandaloneOffset(modifiedProps, calculatedValues);\n  }\n\n  return {\n    globalTransform: getTransform(modifiedProps, calculatedValues, offset),\n    gridOffset: getGridOffset(calculatedValues, offset),\n    gridEdge: getGridEdge(modifiedProps, calculatedValues)\n  };\n};\n\nvar getOrientation = function (props) {\n  if (props.orientation) {\n    return props.orientation;\n  }\n\n  var defaultOrientations = {\n    dependent: props.horizontal ? "bottom" : "left",\n    independent: props.horizontal ? "left" : "bottom"\n  };\n  return props.dependentAxis ? defaultOrientations.dependent : defaultOrientations.independent;\n}; // eslint-disable-next-line complexity\n\n\nvar getCalculatedValues = function (props) {\n  var defaultStyles = getStyleObject(props);\n  var style = getStyles(props, defaultStyles);\n  var padding = helpers/* getPadding */.tQ(props);\n  var labelPadding = getLabelPadding(props, style);\n  var stringTicks = victory_util_axis/* stringTicks */.kM(props) ? props.tickValues : undefined;\n  var axis = victory_util_axis/* getAxis */.dd(props);\n  var axisDomain = victory_util_axis/* getDomain */.ge(props);\n  var axisScale = getScale(props);\n  var xAxisDomain = axis === "x" ? axisDomain : undefined;\n  var yAxisDomain = axis === "y" ? axisDomain : undefined;\n  var xAxisScale = axis === "x" ? axisScale : undefined;\n  var yAxisScale = axis === "y" ? axisScale : undefined;\n  var crossAxis = !(props.crossAxis === false || props.standalone === true);\n  var ticks = victory_util_axis/* getTicks */.fj(props, axisScale, crossAxis);\n  var tickFormat = victory_util_axis/* getTickFormat */.Js(props, axisScale);\n  var range = {\n    x: helpers/* getRange */.rx(props, "x"),\n    y: helpers/* getRange */.rx(props, "y")\n  }; // use full domain if passed in from parent,\n  // otherwise use the just the one axis available\n\n  var domain = {\n    x: props.domain && props.domain.x ? props.domain.x : xAxisDomain,\n    y: props.domain && props.domain.y ? props.domain.y : yAxisDomain\n  }; // use full scale if passed in from parent,\n  // otherwise use the just the one axis available\n\n  var scale = {\n    x: props.domain && props.domain.x ? victory_util_scale/* getBaseScale */.q8(props, "x").domain(props.domain.x).range(props.horizontal ? range.y : range.x) : xAxisScale,\n    y: props.domain && props.domain.y ? victory_util_scale/* getBaseScale */.q8(props, "y").domain(props.domain.y).range(props.horizontal ? range.x : range.y) : yAxisScale\n  };\n  var origin = domain.x && domain.y ? victory_util_axis/* getOrigin */.P$(domain) : undefined;\n  var originSign = origin ? {\n    x: victory_util_axis/* getOriginSign */.eE(origin.x, domain.x),\n    y: victory_util_axis/* getOriginSign */.eE(origin.y, domain.y)\n  } : undefined;\n  var orientations = originSign ? {\n    x: getDefaultOrientations("x", originSign.y, props.horizontal),\n    y: getDefaultOrientations("y", originSign.x, props.horizontal)\n  } : undefined;\n  var orientation = orientations ? props.orientation || orientations[axis] : getOrientation(props);\n  var isVertical = victory_util_axis/* isVertical */.cp(Object.assign({}, props, {\n    orientation: orientation\n  }));\n  var anchors = getAnchors(orientation, isVertical);\n  return {\n    anchors: anchors,\n    axis: axis,\n    crossAxis: crossAxis,\n    domain: domain,\n    isVertical: isVertical,\n    labelPadding: labelPadding,\n    orientation: orientation,\n    orientations: orientations,\n    origin: origin,\n    padding: padding,\n    scale: scale,\n    stringTicks: stringTicks,\n    style: style,\n    tickFormat: tickFormat,\n    ticks: ticks\n  };\n};\n\nvar getBaseProps = function (props, fallbackProps) {\n  props = victory_util_axis/* modifyProps */.TY(props, fallbackProps);\n  var calculatedValues = getCalculatedValues(props);\n  var axis = calculatedValues.axis,\n      style = calculatedValues.style,\n      orientation = calculatedValues.orientation,\n      isVertical = calculatedValues.isVertical,\n      scale = calculatedValues.scale,\n      ticks = calculatedValues.ticks,\n      tickFormat = calculatedValues.tickFormat,\n      anchors = calculatedValues.anchors,\n      domain = calculatedValues.domain,\n      stringTicks = calculatedValues.stringTicks;\n  var otherAxis = axis === "x" ? "y" : "x";\n  var _props = props,\n      width = _props.width,\n      height = _props.height,\n      standalone = _props.standalone,\n      theme = _props.theme,\n      polar = _props.polar,\n      padding = _props.padding,\n      horizontal = _props.horizontal;\n\n  var _getLayoutProps = getLayoutProps(props, calculatedValues),\n      globalTransform = _getLayoutProps.globalTransform,\n      gridOffset = _getLayoutProps.gridOffset,\n      gridEdge = _getLayoutProps.gridEdge;\n\n  var sharedProps = {\n    scale: _defineProperty({}, axis, scale[axis]),\n    polar: polar,\n    horizontal: horizontal,\n    ticks: ticks,\n    stringTicks: stringTicks\n  };\n  var axisProps = getAxisProps(props, calculatedValues, globalTransform);\n  var axisLabelProps = getAxisLabelProps(props, calculatedValues, globalTransform);\n  var initialChildProps = {\n    parent: assign_default()({\n      style: style.parent,\n      ticks: ticks,\n      standalone: standalone,\n      theme: theme,\n      width: width,\n      height: height,\n      padding: padding,\n      domain: domain\n    }, sharedProps)\n  };\n  var gridProps = {\n    dimension: otherAxis,\n    range: _defineProperty({}, otherAxis, helpers/* getRange */.rx(props, otherAxis)),\n    scale: props.scale && props.scale[otherAxis] ? _defineProperty({}, otherAxis, props.scale[otherAxis]) : undefined\n  };\n  return ticks.reduce(function (childProps, tickValue, index) {\n    var _scale$axis, _scale$axis2, _scale$axis3;\n\n    var tick = stringTicks ? stringTicks[index] : tickValue;\n    var text = tickFormat(tickValue, index, ticks);\n    var styles = getEvaluatedStyles(style, assign_default()({}, sharedProps, {\n      tick: tick,\n      tickValue: tickValue,\n      index: index,\n      text: text\n    }));\n    var tickLayout = {\n      position: getTickPosition(styles, orientation, isVertical),\n      transform: getTickTransform((_scale$axis = scale[axis]) === null || _scale$axis === void 0 ? void 0 : _scale$axis.call(scale, tickValue), globalTransform, isVertical)\n    };\n    var gridLayout = {\n      edge: gridEdge,\n      transform: {\n        x: isVertical ? -gridOffset.x + globalTransform.x : ((_scale$axis2 = scale[axis]) === null || _scale$axis2 === void 0 ? void 0 : _scale$axis2.call(scale, tickValue)) + globalTransform.x,\n        y: isVertical ? ((_scale$axis3 = scale[axis]) === null || _scale$axis3 === void 0 ? void 0 : _scale$axis3.call(scale, tickValue)) + globalTransform.y : gridOffset.y + globalTransform.y\n      }\n    };\n    childProps[index] = {\n      axis: assign_default()({\n        dimension: axis\n      }, sharedProps, axisProps),\n      axisLabel: assign_default()({}, sharedProps, axisLabelProps),\n      ticks: assign_default()({}, sharedProps, getTickProps(tickLayout, styles.tickStyle, tickValue)),\n      tickLabels: assign_default()({}, sharedProps, getTickLabelProps(tickLayout, styles.labelStyle, anchors, tickValue, text)),\n      grid: assign_default()({}, sharedProps, gridProps, getGridProps(gridLayout, styles.gridStyle, tickValue))\n    };\n    return childProps;\n  }, initialChildProps);\n};\n;// CONCATENATED MODULE: ./node_modules/victory-axis/es/victory-axis.js\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { victory_axis_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction victory_axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction victory_axis_toConsumableArray(arr) { return victory_axis_arrayWithoutHoles(arr) || victory_axis_iterableToArray(arr) || victory_axis_unsupportedIterableToArray(arr) || victory_axis_nonIterableSpread(); }\n\nfunction victory_axis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction victory_axis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return victory_axis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return victory_axis_arrayLikeToArray(o, minLen); }\n\nfunction victory_axis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction victory_axis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return victory_axis_arrayLikeToArray(arr); }\n\nfunction victory_axis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\nvar options = {\n  components: [{\n    name: "axis",\n    index: 0\n  }, {\n    name: "axisLabel",\n    index: 0\n  }, {\n    name: "grid"\n  }, {\n    name: "parent",\n    index: "parent"\n  }, {\n    name: "ticks"\n  }, {\n    name: "tickLabels"\n  }]\n};\n\nvar VictoryAxisBase = /*#__PURE__*/function (_React$Component) {\n  _inherits(VictoryAxisBase, _React$Component);\n\n  var _super = _createSuper(VictoryAxisBase);\n\n  function VictoryAxisBase() {\n    _classCallCheck(this, VictoryAxisBase);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VictoryAxisBase, [{\n    key: "renderLine",\n    value: function renderLine(props) {\n      var axisComponent = props.axisComponent;\n      var axisProps = this.getComponentProps(axisComponent, "axis", 0);\n      return /*#__PURE__*/react.cloneElement(axisComponent, axisProps);\n    }\n  }, {\n    key: "renderLabel",\n    value: function renderLabel(props) {\n      var axisLabelComponent = props.axisLabelComponent,\n          label = props.label;\n\n      if (!label) {\n        return null;\n      }\n\n      var axisLabelProps = this.getComponentProps(axisLabelComponent, "axisLabel", 0);\n      return /*#__PURE__*/react.cloneElement(axisLabelComponent, axisLabelProps);\n    }\n  }, {\n    key: "renderGridAndTicks",\n    value: function renderGridAndTicks(props) {\n      var _this = this;\n\n      var tickComponent = props.tickComponent,\n          tickLabelComponent = props.tickLabelComponent,\n          gridComponent = props.gridComponent,\n          name = props.name;\n\n      var shouldRender = function (componentProps) {\n        var _componentProps$style = componentProps.style,\n            style = _componentProps$style === void 0 ? {} : _componentProps$style,\n            _componentProps$event = componentProps.events,\n            events = _componentProps$event === void 0 ? {} : _componentProps$event;\n        var visible = style.stroke !== "transparent" && style.stroke !== "none" && style.strokeWidth !== 0;\n        return visible || !isEmpty_default()(events);\n      };\n\n      return this.dataKeys.map(function (key, index) {\n        var tickProps = _this.getComponentProps(tickComponent, "ticks", index);\n\n        var BaseTickComponent = /*#__PURE__*/react.cloneElement(tickComponent, tickProps);\n        var TickComponent = shouldRender(BaseTickComponent.props) ? BaseTickComponent : undefined;\n\n        var gridProps = _this.getComponentProps(gridComponent, "grid", index);\n\n        var BaseGridComponent = /*#__PURE__*/react.cloneElement(gridComponent, gridProps);\n        var GridComponent = shouldRender(BaseGridComponent.props) ? BaseGridComponent : undefined;\n\n        var tickLabelProps = _this.getComponentProps(tickLabelComponent, "tickLabels", index);\n\n        var TickLabel = /*#__PURE__*/react.cloneElement(tickLabelComponent, tickLabelProps);\n        var children = [GridComponent, TickComponent, TickLabel].filter(Boolean);\n        return /*#__PURE__*/react.cloneElement(props.groupComponent, {\n          key: "".concat(name, "-tick-group-").concat(key)\n        }, children);\n      });\n    }\n  }, {\n    key: "fixLabelOverlap",\n    value: function fixLabelOverlap(gridAndTicks, props) {\n      var isVertical = victory_util_axis/* isVertical */.cp(props);\n      var size = isVertical ? props.height : props.width;\n\n      var isVictoryLabel = function (child) {\n        return child.type && child.type.role === "label";\n      };\n\n      var labels = gridAndTicks.map(function (gridAndTick) {\n        return gridAndTick.props.children;\n      }).reduce(function (accumulator, childArr) {\n        return accumulator.concat(childArr);\n      }, []).filter(isVictoryLabel).map(function (child) {\n        return child.props;\n      });\n\n      var paddingToObject = function (padding) {\n        return typeof padding === "object" ? assign_default()({}, {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        }, padding) : {\n          top: padding,\n          right: padding,\n          bottom: padding,\n          left: padding\n        };\n      };\n\n      var labelsSumSize = labels.reduce(function (sum, label) {\n        var padding = paddingToObject(label.style.padding);\n        var labelSize = textsize/* approximateTextSize */.Z9(label.text, {\n          angle: label.angle,\n          fontSize: label.style.fontSize,\n          letterSpacing: label.style.letterSpacing,\n          fontFamily: label.style.fontFamily\n        });\n        return sum + (isVertical ? labelSize.height + padding.top + padding.bottom : labelSize.width + padding.right + padding.left);\n      }, 0);\n      var availiableLabelCount = Math.floor(size * gridAndTicks.length / labelsSumSize);\n      var divider = Math.ceil(gridAndTicks.length / availiableLabelCount) || 1;\n\n      var getLabelCoord = function (gridAndTick) {\n        return gridAndTick.props.children.filter(isVictoryLabel).reduce(function (prev, child) {\n          return (isVertical ? child.props.y : child.props.x) || 0;\n        }, 0);\n      };\n\n      var sorted = gridAndTicks.sort(function (a, b) {\n        return isVertical ? getLabelCoord(b) - getLabelCoord(a) // ordinary axis has top-bottom orientation\n        : getLabelCoord(a) - getLabelCoord(b);\n      } // ordinary axis has left-right orientation\n      );\n      return sorted.filter(function (gridAndTick, index) {\n        return index % divider === 0;\n      });\n    } // Overridden in native versions\n\n  }, {\n    key: "shouldAnimate",\n    value: function shouldAnimate() {\n      return !!this.props.animate;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var animationWhitelist = VictoryAxis.animationWhitelist;\n      var props = victory_util_axis/* modifyProps */.TY(this.props, fallbackProps);\n      var userProps = user_props/* getSafeUserProps */.I(this.props);\n\n      if (this.shouldAnimate()) {\n        return this.animateComponent(props, animationWhitelist);\n      }\n\n      var gridAndTicks = this.renderGridAndTicks(props);\n      var modifiedGridAndTicks = props.fixLabelOverlap ? this.fixLabelOverlap(gridAndTicks, props) : gridAndTicks;\n      var children = [this.renderLine(props), this.renderLabel(props)].concat(victory_axis_toConsumableArray(modifiedGridAndTicks));\n      var container = /*#__PURE__*/react.cloneElement(props.containerComponent, userProps);\n      return props.standalone ? this.renderContainer(container, children) : /*#__PURE__*/react.cloneElement(props.groupComponent, userProps, children);\n    }\n  }]);\n\n  return VictoryAxisBase;\n}(react.Component);\n\nVictoryAxisBase.animationWhitelist = ["style", "domain", "range", "tickCount", "tickValues", "offsetX", "offsetY", "padding", "width", "height"];\nVictoryAxisBase.displayName = "VictoryAxis";\nVictoryAxisBase.role = "axis";\nVictoryAxisBase.defaultTransitions = {\n  onExit: {\n    duration: 500\n  },\n  onEnter: {\n    duration: 500\n  }\n};\nVictoryAxisBase.propTypes = _objectSpread(_objectSpread({}, common_props/* CommonProps.baseProps */.l.baseProps), {}, {\n  axisComponent: (prop_types_default()).element,\n  axisLabelComponent: (prop_types_default()).element,\n  axisValue: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string, (prop_types_default()).object]),\n  categories: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).string), prop_types_default().shape({\n    x: prop_types_default().arrayOf((prop_types_default()).string),\n    y: prop_types_default().arrayOf((prop_types_default()).string)\n  })]),\n  crossAxis: (prop_types_default()).bool,\n  dependentAxis: (prop_types_default()).bool,\n  events: prop_types_default().arrayOf(prop_types_default().shape({\n    target: prop_types_default().oneOf(["axis", "axisLabel", "grid", "ticks", "tickLabels"]),\n    eventKey: prop_types_default().oneOfType([(prop_types_default()).array, victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* nonNegative */.A7]), (prop_types_default()).string]),\n    eventHandlers: (prop_types_default()).object\n  })),\n  fixLabelOverlap: (prop_types_default()).bool,\n  gridComponent: (prop_types_default()).element,\n  groupComponent: (prop_types_default()).element,\n  invertAxis: (prop_types_default()).bool,\n  label: (prop_types_default()).any,\n  offsetX: (prop_types_default()).number,\n  offsetY: (prop_types_default()).number,\n  orientation: prop_types_default().oneOf(["top", "bottom", "left", "right"]),\n  origin: prop_types_default().shape({\n    x: (prop_types_default()).number,\n    y: (prop_types_default()).number\n  }),\n  stringMap: (prop_types_default()).object,\n  style: prop_types_default().shape({\n    parent: (prop_types_default()).object,\n    axis: (prop_types_default()).object,\n    axisLabel: (prop_types_default()).object,\n    grid: (prop_types_default()).object,\n    ticks: (prop_types_default()).object,\n    tickLabels: (prop_types_default()).object\n  }),\n  tickComponent: (prop_types_default()).element,\n  tickCount: victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* greaterThanZero */.KO]),\n  tickFormat: prop_types_default().oneOfType([(prop_types_default()).func, victory_util_prop_types/* homogeneousArray */.xx]),\n  tickLabelComponent: (prop_types_default()).element,\n  tickValues: victory_util_prop_types/* homogeneousArray */.xx\n});\nVictoryAxisBase.defaultProps = {\n  axisComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  axisLabelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null),\n  tickLabelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null),\n  tickComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  gridComponent: /*#__PURE__*/react.createElement(line_segment/* LineSegment */.c, null),\n  standalone: true,\n  theme: victory_theme/* VictoryTheme.grayscale */.J.grayscale,\n  containerComponent: /*#__PURE__*/react.createElement(victory_container/* VictoryContainer */._, null),\n  groupComponent: /*#__PURE__*/react.createElement("g", {\n    role: "presentation"\n  }),\n  fixLabelOverlap: false\n};\nVictoryAxisBase.getDomain = victory_util_axis/* getDomain */.ge;\nVictoryAxisBase.getAxis = victory_util_axis/* getAxis */.dd;\n\nVictoryAxisBase.getStyles = function (props) {\n  return getStyles(props);\n};\n\nVictoryAxisBase.getBaseProps = function (props) {\n  return getBaseProps(props, fallbackProps);\n};\n\nVictoryAxisBase.expectedComponents = ["axisComponent", "axisLabelComponent", "groupComponent", "containerComponent", "tickComponent", "tickLabelComponent", "gridComponent"];\nvar VictoryAxis = (0,add_events/* addEvents */.o)(VictoryAxisBase, options);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMwOTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0o7O0FBRXBDLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1Msa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVoSjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQ0FBWTtBQUN6QjtBQUNBLGNBQWMsdUNBQWtCO0FBQ2hDO0FBQ0EsOEJBQThCLG1DQUFjO0FBQzVDLGNBQWMsd0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFTLEdBQUc7QUFDL0I7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFTO0FBQ3JCLFVBQVUsa0JBQVMsR0FBRztBQUN0QixlQUFlLGtCQUFTLEdBQUc7QUFDM0IsVUFBVSxrQkFBUyxHQUFHO0FBQ3RCLFdBQVcsa0JBQVMsR0FBRztBQUN2QixnQkFBZ0Isa0JBQVMsR0FBRztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDZCQUFxQjtBQUNwQyxnQkFBZ0IsNkJBQXFCO0FBQ3JDLGVBQWUsNkJBQXFCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQ0FBZSxTQUFTOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBLG9CQUFvQiw2QkFBcUIsY0FBYyxnQkFBTyxHQUFHO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQWtCO0FBQ2xDO0FBQ0Esb0JBQW9CLHFDQUFnQjtBQUNwQyxhQUFhLGlDQUFZO0FBQ3pCLG1CQUFtQixtQ0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFhO0FBQzNCLG1CQUFtQix1Q0FBa0I7QUFDckM7QUFDQSxPQUFPLHdCQUFnQjtBQUN2QixPQUFPLHdCQUFnQjtBQUN2QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0NBQXdDLHVDQUFrQjtBQUMxRCx3Q0FBd0MsdUNBQWtCO0FBQzFEO0FBQ0Esc0NBQXNDLG1DQUFjO0FBQ3BEO0FBQ0EsT0FBTyx1Q0FBa0I7QUFDekIsT0FBTyx1Q0FBa0I7QUFDekIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixvQ0FBZSxpQkFBaUI7QUFDbkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLHFDQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsd0JBQWdCO0FBQzFELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxnQkFBTyxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQU87QUFDbkI7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCLGdCQUFPLEdBQUc7QUFDM0IsYUFBYSxnQkFBTyxHQUFHO0FBQ3ZCLGtCQUFrQixnQkFBTyxHQUFHO0FBQzVCLFlBQVksZ0JBQU8sR0FBRztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNILEU7O0FDdG1Cc0M7QUFDRjs7QUFFcEMsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsMkJBQWUsNkJBQTZCLG9LQUFvSyxtRkFBbUYsS0FBSzs7QUFFMWUsU0FBUywyQkFBZSxvQkFBb0Isa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE0sU0FBUyw4QkFBa0IsUUFBUSxPQUFPLDhCQUFrQixTQUFTLDRCQUFnQixTQUFTLHVDQUEyQixTQUFTLDhCQUFrQjs7QUFFcEosU0FBUyw4QkFBa0IsS0FBSzs7QUFFaEMsU0FBUyx1Q0FBMkIsY0FBYyxnQkFBZ0Isa0NBQWtDLDZCQUFpQixhQUFhLHdEQUF3RCw2REFBNkQsc0RBQXNELG9GQUFvRiw2QkFBaUI7O0FBRWxaLFNBQVMsNEJBQWdCLFNBQVM7O0FBRWxDLFNBQVMsOEJBQWtCLFFBQVEsK0JBQStCLDZCQUFpQjs7QUFFbkYsU0FBUyw2QkFBaUIsYUFBYSx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRXhRLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHLCtDQUErQyxpQkFBaUIsR0FBRzs7QUFFNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7QUFFekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0Qsd0VBQXdFLGVBQWUsNEJBQTRCLG1GQUFtRjs7QUFFeFAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLHVHQUF1RyxtREFBbUQ7O0FBRXJKO0FBQ1Q7QUFDZ0o7QUFDL0c7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsMkJBQTJCLGlCQUFRO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLGtCQUFrQjtBQUMvRDs7QUFFQTs7QUFFQSw2Q0FBNkMsa0JBQWtCO0FBQy9EOztBQUVBOztBQUVBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFlO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDZDQUE2QyxnQkFBTyxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBZ0I7QUFDbEMsc0JBQXNCLGtDQUEwQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RUFBOEUsOEJBQWtCO0FBQ2hHLG1DQUFtQyxrQkFBa0I7QUFDckQseUZBQXlGLGtCQUFrQjtBQUMzRztBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLENBQUMsZUFBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEVBQUUsbURBQXFCLEtBQUs7QUFDdEYsaUJBQWlCLDhCQUFpQjtBQUNsQyxzQkFBc0IsOEJBQWlCO0FBQ3ZDLGFBQWEsOEJBQW1CLEVBQUUsNkJBQWdCLEVBQUUsNkJBQWdCLEVBQUUsNkJBQWdCO0FBQ3RGLGNBQWMsOEJBQW1CLEVBQUUsNEJBQWlCLENBQUMsNkJBQWdCLEdBQUcsMEJBQWU7QUFDdkYsT0FBTyw0QkFBaUIsQ0FBQyw2QkFBZ0I7QUFDekMsT0FBTyw0QkFBaUIsQ0FBQyw2QkFBZ0I7QUFDekMsR0FBRztBQUNILGFBQWEsMkJBQWM7QUFDM0IsaUJBQWlCLDJCQUFjO0FBQy9CLFVBQVUsNEJBQWlCLENBQUMsMEJBQWU7QUFDM0MsWUFBWSwwQkFBZTtBQUMzQixjQUFjLDhCQUFtQixFQUFFLDRCQUFlLEVBQUUseUNBQXlCLEVBQUUsdUNBQXVCLEVBQUUsMkNBQTJCLElBQUksNkJBQWdCO0FBQ3ZKLG1CQUFtQiw2QkFBZ0I7QUFDbkMsR0FBRztBQUNILG1CQUFtQiwyQkFBYztBQUNqQyxpQkFBaUIsOEJBQWlCO0FBQ2xDLGtCQUFrQiw4QkFBaUI7QUFDbkMsY0FBYywyQkFBYztBQUM1QixTQUFTLDBCQUFhO0FBQ3RCLFdBQVcsNkJBQWdCO0FBQzNCLFdBQVcsNkJBQWdCO0FBQzNCLGVBQWUsMEJBQWU7QUFDOUIsVUFBVSwwQkFBZTtBQUN6QixPQUFPLDZCQUFnQjtBQUN2QixPQUFPLDZCQUFnQjtBQUN2QixHQUFHO0FBQ0gsYUFBYSw2QkFBZ0I7QUFDN0IsU0FBUywwQkFBZTtBQUN4QixZQUFZLDZCQUFnQjtBQUM1QixVQUFVLDZCQUFnQjtBQUMxQixlQUFlLDZCQUFnQjtBQUMvQixVQUFVLDZCQUFnQjtBQUMxQixXQUFXLDZCQUFnQjtBQUMzQixnQkFBZ0IsNkJBQWdCO0FBQ2hDLEdBQUc7QUFDSCxpQkFBaUIsOEJBQWlCO0FBQ2xDLGFBQWEseUNBQXlCLEVBQUUsdUNBQXVCLEVBQUUsK0NBQStCO0FBQ2hHLGNBQWMsOEJBQW1CLEVBQUUsMkJBQWMsRUFBRSxnREFBZ0M7QUFDbkYsc0JBQXNCLDhCQUFpQjtBQUN2QyxjQUFjLGdEQUFnQztBQUM5QyxDQUFDO0FBQ0Q7QUFDQSw4QkFBOEIsbUJBQW1CLENBQUMsK0JBQVc7QUFDN0QsbUNBQW1DLG1CQUFtQixDQUFDLGlDQUFZO0FBQ25FLG1DQUFtQyxtQkFBbUIsQ0FBQyxpQ0FBWTtBQUNuRSw4QkFBOEIsbUJBQW1CLENBQUMsK0JBQVc7QUFDN0QsOEJBQThCLG1CQUFtQixDQUFDLCtCQUFXO0FBQzdEO0FBQ0EsU0FBUyxxREFBc0I7QUFDL0IsbUNBQW1DLG1CQUFtQixDQUFDLHlDQUFnQjtBQUN2RSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQWM7QUFDMUMsMEJBQTBCLGlDQUFZOztBQUV0QztBQUNBLFNBQVMsU0FBUztBQUNsQjs7QUFFQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjs7QUFFQTtBQUNPLGtCQUFrQiwrQkFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LWF4aXMvZXMvaGVscGVyLW1ldGhvZHMuanM/MjgwZSIsIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2VzL3ZpY3RvcnktYXhpcy5qcz84YWYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmYXVsdHMgZnJvbSBcImxvZGFzaC9kZWZhdWx0c1wiO1xuaW1wb3J0IF9hc3NpZ24gZnJvbSBcImxvZGFzaC9hc3NpZ25cIjtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBIZWxwZXJzLCBTY2FsZSwgQXhpcyB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbnZhciBvcmllbnRhdGlvblNpZ24gPSB7XG4gIHRvcDogLTEsXG4gIGxlZnQ6IC0xLFxuICByaWdodDogMSxcbiAgYm90dG9tOiAxXG59O1xuXG52YXIgZXhpc3RzID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEN1cnJlbnRBeGlzID0gZnVuY3Rpb24gKHByb3BzLCBheGlzKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgaG9yaXpvbnRhbCA9IHByb3BzLmhvcml6b250YWw7XG5cbiAgaWYgKG9yaWVudGF0aW9uKSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgICB0b3A6IFwieFwiLFxuICAgICAgYm90dG9tOiBcInhcIixcbiAgICAgIGxlZnQ6IFwieVwiLFxuICAgICAgcmlnaHQ6IFwieVwiXG4gICAgfTtcbiAgICByZXR1cm4gZGltZW5zaW9uc1tvcmllbnRhdGlvbl07XG4gIH1cblxuICB2YXIgb3RoZXJBeGlzID0gYXhpcyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xuICByZXR1cm4gaG9yaXpvbnRhbCA/IG90aGVyQXhpcyA6IGF4aXM7XG59O1xuXG52YXIgZ2V0U2NhbGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIGF4aXMgPSBBeGlzLmdldEF4aXMocHJvcHMpO1xuICB2YXIgY3VycmVudEF4aXMgPSBnZXRDdXJyZW50QXhpcyhwcm9wcywgYXhpcyk7XG4gIHZhciBzY2FsZSA9IFNjYWxlLmdldEJhc2VTY2FsZShwcm9wcywgYXhpcyk7XG4gIHZhciBwcm9wc0RvbWFpbiA9IHByb3BzLmRvbWFpbiAmJiBwcm9wcy5kb21haW5bYXhpc107XG4gIHZhciBkb21haW4gPSBwcm9wc0RvbWFpbiB8fCBBeGlzLmdldERvbWFpbihwcm9wcykgfHwgc2NhbGUuZG9tYWluKCk7XG4gIHNjYWxlLnJhbmdlKEhlbHBlcnMuZ2V0UmFuZ2UocHJvcHMsIGN1cnJlbnRBeGlzKSk7XG4gIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICByZXR1cm4gc2NhbGU7XG59O1xuXG52YXIgZ2V0U3R5bGVPYmplY3QgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIHRoZW1lID0gcHJvcHMudGhlbWUsXG4gICAgICBkZXBlbmRlbnRBeGlzID0gcHJvcHMuZGVwZW5kZW50QXhpcztcbiAgdmFyIGdlbmVyYWxBeGlzU3R5bGUgPSB0aGVtZSAmJiB0aGVtZS5heGlzICYmIHRoZW1lLmF4aXMuc3R5bGU7XG4gIHZhciBheGlzVHlwZSA9IGRlcGVuZGVudEF4aXMgPyBcImRlcGVuZGVudEF4aXNcIiA6IFwiaW5kZXBlbmRlbnRBeGlzXCI7XG4gIHZhciBzcGVjaWZpY0F4aXNTdHlsZSA9IHRoZW1lICYmIHRoZW1lW2F4aXNUeXBlXSAmJiB0aGVtZVtheGlzVHlwZV0uc3R5bGU7XG5cbiAgdmFyIG1lcmdlU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZU5hbWVzcGFjZXMgPSBbXCJheGlzXCIsIFwiYXhpc0xhYmVsXCIsIFwiZ3JpZFwiLCBcInBhcmVudFwiLCBcInRpY2tMYWJlbHNcIiwgXCJ0aWNrc1wiXTtcbiAgICByZXR1cm4gc3R5bGVOYW1lc3BhY2VzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3Vycikge1xuICAgICAgbWVtb1tjdXJyXSA9IF9kZWZhdWx0cyh7fSwgc3BlY2lmaWNBeGlzU3R5bGVbY3Vycl0sIGdlbmVyYWxBeGlzU3R5bGVbY3Vycl0pO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuICB9O1xuXG4gIHJldHVybiBnZW5lcmFsQXhpc1N0eWxlICYmIHNwZWNpZmljQXhpc1N0eWxlID8gbWVyZ2VTdHlsZXMoKSA6IHNwZWNpZmljQXhpc1N0eWxlIHx8IGdlbmVyYWxBeGlzU3R5bGU7XG59O1xuXG5leHBvcnQgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcywgc3R5bGVPYmplY3QpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIHN0eWxlT2JqZWN0ID0gc3R5bGVPYmplY3QgfHwge307XG4gIHZhciBwYXJlbnRTdHlsZVByb3BzID0ge1xuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgcGFyZW50OiBfZGVmYXVsdHMoc3R5bGUucGFyZW50LCBzdHlsZU9iamVjdC5wYXJlbnQsIHBhcmVudFN0eWxlUHJvcHMpLFxuICAgIGF4aXM6IF9kZWZhdWx0cyh7fSwgc3R5bGUuYXhpcywgc3R5bGVPYmplY3QuYXhpcyksXG4gICAgYXhpc0xhYmVsOiBfZGVmYXVsdHMoe30sIHN0eWxlLmF4aXNMYWJlbCwgc3R5bGVPYmplY3QuYXhpc0xhYmVsKSxcbiAgICBncmlkOiBfZGVmYXVsdHMoe30sIHN0eWxlLmdyaWQsIHN0eWxlT2JqZWN0LmdyaWQpLFxuICAgIHRpY2tzOiBfZGVmYXVsdHMoe30sIHN0eWxlLnRpY2tzLCBzdHlsZU9iamVjdC50aWNrcyksXG4gICAgdGlja0xhYmVsczogX2RlZmF1bHRzKHt9LCBzdHlsZS50aWNrTGFiZWxzLCBzdHlsZU9iamVjdC50aWNrTGFiZWxzKVxuICB9O1xufTtcblxudmFyIGdldFRpY2tQcm9wcyA9IGZ1bmN0aW9uIChsYXlvdXQsIHN0eWxlLCBkYXR1bSkge1xuICB2YXIgcG9zaXRpb24gPSBsYXlvdXQucG9zaXRpb24sXG4gICAgICB0cmFuc2Zvcm0gPSBsYXlvdXQudHJhbnNmb3JtO1xuICByZXR1cm4ge1xuICAgIHgxOiB0cmFuc2Zvcm0ueCxcbiAgICB5MTogdHJhbnNmb3JtLnksXG4gICAgeDI6IHRyYW5zZm9ybS54ICsgcG9zaXRpb24ueDIsXG4gICAgeTI6IHRyYW5zZm9ybS55ICsgcG9zaXRpb24ueTIsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIGRhdHVtOiBkYXR1bVxuICB9O1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblxuXG52YXIgZ2V0VGlja0xhYmVsUHJvcHMgPSBmdW5jdGlvbiAobGF5b3V0LCBzdHlsZSwgYW5jaG9ycywgZGF0dW0sIHRleHQpIHtcbiAgdmFyIHBvc2l0aW9uID0gbGF5b3V0LnBvc2l0aW9uLFxuICAgICAgdHJhbnNmb3JtID0gbGF5b3V0LnRyYW5zZm9ybTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgeDogdHJhbnNmb3JtLnggKyBwb3NpdGlvbi54LFxuICAgIHk6IHRyYW5zZm9ybS55ICsgcG9zaXRpb24ueSxcbiAgICB2ZXJ0aWNhbEFuY2hvcjogYW5jaG9ycy52ZXJ0aWNhbEFuY2hvcixcbiAgICB0ZXh0QW5jaG9yOiBhbmNob3JzLnRleHRBbmNob3IsXG4gICAgYW5nbGU6IHN0eWxlLmFuZ2xlLFxuICAgIHRleHQ6IHRleHQsXG4gICAgZGF0dW06IGRhdHVtXG4gIH07XG59O1xuXG52YXIgZ2V0R3JpZFByb3BzID0gZnVuY3Rpb24gKGxheW91dCwgc3R5bGUsIGRhdHVtKSB7XG4gIHZhciBlZGdlID0gbGF5b3V0LmVkZ2UsXG4gICAgICB0cmFuc2Zvcm0gPSBsYXlvdXQudHJhbnNmb3JtO1xuICByZXR1cm4ge1xuICAgIHgxOiB0cmFuc2Zvcm0ueCxcbiAgICB5MTogdHJhbnNmb3JtLnksXG4gICAgeDI6IGVkZ2UueCArIHRyYW5zZm9ybS54LFxuICAgIHkyOiBlZGdlLnkgKyB0cmFuc2Zvcm0ueSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgZGF0dW06IGRhdHVtXG4gIH07XG59O1xuXG52YXIgZ2V0QXhpc1Byb3BzID0gZnVuY3Rpb24gKG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIGdsb2JhbFRyYW5zZm9ybSkge1xuICB2YXIgc3R5bGUgPSBjYWxjdWxhdGVkVmFsdWVzLnN0eWxlLFxuICAgICAgcGFkZGluZyA9IGNhbGN1bGF0ZWRWYWx1ZXMucGFkZGluZyxcbiAgICAgIGlzVmVydGljYWwgPSBjYWxjdWxhdGVkVmFsdWVzLmlzVmVydGljYWw7XG4gIHZhciB3aWR0aCA9IG1vZGlmaWVkUHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBtb2RpZmllZFByb3BzLmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogc3R5bGUuYXhpcyxcbiAgICB4MTogaXNWZXJ0aWNhbCA/IGdsb2JhbFRyYW5zZm9ybS54IDogcGFkZGluZy5sZWZ0ICsgZ2xvYmFsVHJhbnNmb3JtLngsXG4gICAgeDI6IGlzVmVydGljYWwgPyBnbG9iYWxUcmFuc2Zvcm0ueCA6IHdpZHRoIC0gcGFkZGluZy5yaWdodCArIGdsb2JhbFRyYW5zZm9ybS54LFxuICAgIHkxOiBpc1ZlcnRpY2FsID8gcGFkZGluZy50b3AgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55LFxuICAgIHkyOiBpc1ZlcnRpY2FsID8gaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20gKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55XG4gIH07XG59O1xuXG52YXIgZ2V0RXZhbHVhdGVkU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlLCBwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHRpY2tTdHlsZTogSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tzLCBwcm9wcyksXG4gICAgbGFiZWxTdHlsZTogSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tMYWJlbHMsIHByb3BzKSxcbiAgICBncmlkU3R5bGU6IEhlbHBlcnMuZXZhbHVhdGVTdHlsZShzdHlsZS5ncmlkLCBwcm9wcylcbiAgfTtcbn07XG5cbnZhciBnZXRBeGlzTGFiZWxQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcywgZ2xvYmFsVHJhbnNmb3JtKSB7XG4gIHZhciBzdHlsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc3R5bGUsXG4gICAgICBvcmllbnRhdGlvbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZW50YXRpb24sXG4gICAgICBwYWRkaW5nID0gY2FsY3VsYXRlZFZhbHVlcy5wYWRkaW5nLFxuICAgICAgbGFiZWxQYWRkaW5nID0gY2FsY3VsYXRlZFZhbHVlcy5sYWJlbFBhZGRpbmcsXG4gICAgICBpc1ZlcnRpY2FsID0gY2FsY3VsYXRlZFZhbHVlcy5pc1ZlcnRpY2FsO1xuICB2YXIgc2lnbiA9IG9yaWVudGF0aW9uU2lnbltvcmllbnRhdGlvbl07XG4gIHZhciBoUGFkZGluZyA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gIHZhciB2UGFkZGluZyA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIHZhciB2ZXJ0aWNhbEFuY2hvciA9IHNpZ24gPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIjtcbiAgdmFyIGxhYmVsU3R5bGUgPSBzdHlsZS5heGlzTGFiZWw7XG4gIHZhciBhbmdsZSA9IGlzVmVydGljYWwgPyAtOTAgOiAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcblxuICB2YXIgeCA9IGlzVmVydGljYWwgPyBnbG9iYWxUcmFuc2Zvcm0ueCArIHNpZ24gKiBsYWJlbFBhZGRpbmcgOiAocHJvcHMud2lkdGggLSBoUGFkZGluZykgLyAyICsgcGFkZGluZy5sZWZ0ICsgZ2xvYmFsVHJhbnNmb3JtLng7XG4gIHZhciB5ID0gaXNWZXJ0aWNhbCA/IChwcm9wcy5oZWlnaHQgLSB2UGFkZGluZykgLyAyICsgcGFkZGluZy50b3AgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IHNpZ24gKiBsYWJlbFBhZGRpbmcgKyBnbG9iYWxUcmFuc2Zvcm0ueTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdmVydGljYWxBbmNob3I6IGxhYmVsU3R5bGUudmVydGljYWxBbmNob3IgfHwgdmVydGljYWxBbmNob3IsXG4gICAgdGV4dEFuY2hvcjogbGFiZWxTdHlsZS50ZXh0QW5jaG9yIHx8IFwibWlkZGxlXCIsXG4gICAgYW5nbGU6IGxhYmVsU3R5bGUuYW5nbGUgPT09IHVuZGVmaW5lZCA/IGFuZ2xlIDogbGFiZWxTdHlsZS5hbmdsZSxcbiAgICBzdHlsZTogbGFiZWxTdHlsZSxcbiAgICB0ZXh0OiBwcm9wcy5sYWJlbFxuICB9O1xufTtcblxudmFyIGdldEFuY2hvcnMgPSBmdW5jdGlvbiAob3JpZW50YXRpb24sIGlzVmVydGljYWwpIHtcbiAgdmFyIGFuY2hvck9yaWVudGF0aW9uID0ge1xuICAgIHRvcDogXCJlbmRcIixcbiAgICBsZWZ0OiBcImVuZFwiLFxuICAgIHJpZ2h0OiBcInN0YXJ0XCIsXG4gICAgYm90dG9tOiBcInN0YXJ0XCJcbiAgfTtcbiAgdmFyIGFuY2hvciA9IGFuY2hvck9yaWVudGF0aW9uW29yaWVudGF0aW9uXTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0QW5jaG9yOiBpc1ZlcnRpY2FsID8gYW5jaG9yIDogXCJtaWRkbGVcIixcbiAgICB2ZXJ0aWNhbEFuY2hvcjogaXNWZXJ0aWNhbCA/IFwibWlkZGxlXCIgOiBhbmNob3JcbiAgfTtcbn07XG5cbnZhciBnZXRMYWJlbFBhZGRpbmcgPSBmdW5jdGlvbiAocHJvcHMsIHN0eWxlKSB7XG4gIHZhciBsYWJlbFN0eWxlID0gc3R5bGUuYXhpc0xhYmVsIHx8IHt9O1xuXG4gIGlmIChsYWJlbFN0eWxlLnBhZGRpbmcgIT09IHVuZGVmaW5lZCAmJiBsYWJlbFN0eWxlLnBhZGRpbmcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbGFiZWxTdHlsZS5wYWRkaW5nO1xuICB9XG5cbiAgdmFyIGlzVmVydGljYWwgPSBBeGlzLmlzVmVydGljYWwocHJvcHMpOyAvLyBUT0RPOiBtYWdpYyBudW1iZXJzXG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyovXG5cbiAgdmFyIGZvbnRTaXplID0gbGFiZWxTdHlsZS5mb250U2l6ZSB8fCAxNDtcbiAgcmV0dXJuIHByb3BzLmxhYmVsID8gZm9udFNpemUgKiAoaXNWZXJ0aWNhbCA/IDIuMyA6IDEuNikgOiAwO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLW1hZ2ljLW51bWJlcnMqL1xufTtcblxudmFyIGdldERlZmF1bHRPcmllbnRhdGlvbnMgPSBmdW5jdGlvbiAoYXhpcywgb3JpZ2luU2lnbiwgaG9yaXpvbnRhbCkge1xuICB2YXIgc2lnbiA9IG9yaWdpblNpZ24gfHwgXCJwb3NpdGl2ZVwiO1xuICB2YXIgb3JpZW50YXRpb25zID0ge1xuICAgIHBvc2l0aXZlOiB7XG4gICAgICB4OiBcImJvdHRvbVwiLFxuICAgICAgeTogXCJsZWZ0XCJcbiAgICB9LFxuICAgIG5lZ2F0aXZlOiB7XG4gICAgICB4OiBcInRvcFwiLFxuICAgICAgeTogXCJyaWdodFwiXG4gICAgfVxuICB9O1xuICB2YXIgaG9yaXpvbnRhbE9yaWVudGF0aW9ucyA9IHtcbiAgICBwb3NpdGl2ZToge1xuICAgICAgeDogXCJsZWZ0XCIsXG4gICAgICB5OiBcImJvdHRvbVwiXG4gICAgfSxcbiAgICBuZWdhdGl2ZToge1xuICAgICAgeDogXCJyaWdodFwiLFxuICAgICAgeTogXCJ0b3BcIlxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhvcml6b250YWwgPyBob3Jpem9udGFsT3JpZW50YXRpb25zW3NpZ25dW2F4aXNdIDogb3JpZW50YXRpb25zW3NpZ25dW2F4aXNdO1xufTtcblxudmFyIGdldFN0YW5kYWxvbmVPZmZzZXQgPSBmdW5jdGlvbiAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpIHtcbiAgdmFyIHN0eWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zdHlsZSxcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFZhbHVlcy5zY2FsZSxcbiAgICAgIG9yaWVudGF0aW9uID0gY2FsY3VsYXRlZFZhbHVlcy5vcmllbnRhdGlvbixcbiAgICAgIHBhZGRpbmcgPSBjYWxjdWxhdGVkVmFsdWVzLnBhZGRpbmcsXG4gICAgICBheGlzID0gY2FsY3VsYXRlZFZhbHVlcy5heGlzLFxuICAgICAgdGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnRpY2tzLFxuICAgICAgc3RyaW5nVGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnN0cmluZ1RpY2tzLFxuICAgICAgaXNWZXJ0aWNhbCA9IGNhbGN1bGF0ZWRWYWx1ZXMuaXNWZXJ0aWNhbCxcbiAgICAgIGxhYmVsUGFkZGluZyA9IGNhbGN1bGF0ZWRWYWx1ZXMubGFiZWxQYWRkaW5nO1xuICB2YXIgcG9sYXIgPSBwcm9wcy5wb2xhcixcbiAgICAgIGhvcml6b250YWwgPSBwcm9wcy5ob3Jpem9udGFsO1xuICB2YXIgc2hhcmVkUHJvcHMgPSB7XG4gICAgc2NhbGU6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgYXhpcywgc2NhbGUpLFxuICAgIHBvbGFyOiBwb2xhcixcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgIHRpY2tzOiB0aWNrcyxcbiAgICBzdHJpbmdUaWNrczogc3RyaW5nVGlja3NcbiAgfTtcbiAgdmFyIHhQYWRkaW5nID0gb3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IHBhZGRpbmcucmlnaHQgOiBwYWRkaW5nLmxlZnQ7XG4gIHZhciB5UGFkZGluZyA9IG9yaWVudGF0aW9uID09PSBcInRvcFwiID8gcGFkZGluZy50b3AgOiBwYWRkaW5nLmJvdHRvbTtcbiAgdmFyIG9mZnNldFggPSBwcm9wcy5vZmZzZXRYICE9PSBudWxsICYmIHByb3BzLm9mZnNldFggIT09IHVuZGVmaW5lZCA/IHByb3BzLm9mZnNldFggOiB4UGFkZGluZztcbiAgdmFyIG9mZnNldFkgPSBwcm9wcy5vZmZzZXRZICE9PSBudWxsICYmIHByb3BzLm9mZnNldFkgIT09IHVuZGVmaW5lZCA/IHByb3BzLm9mZnNldFkgOiB5UGFkZGluZztcbiAgdmFyIGZvbnRTaXplID0gc3R5bGUuYXhpc0xhYmVsLmZvbnRTaXplIHx8IDE0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcblxuICB2YXIgdGlja1NpemVzID0gdGlja3MubWFwKGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgIHZhciB0aWNrID0gc3RyaW5nVGlja3MgPyBwcm9wcy50aWNrVmFsdWVzW2RhdGEgLSAxXSA6IGRhdGE7XG4gICAgdmFyIHRpY2tTdHlsZSA9IEhlbHBlcnMuZXZhbHVhdGVTdHlsZShzdHlsZS50aWNrcywgX2Fzc2lnbih7fSwgc2hhcmVkUHJvcHMsIHtcbiAgICAgIHRpY2s6IHRpY2ssXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRpY2tTdHlsZS5zaXplIHx8IDA7XG4gIH0pO1xuICB2YXIgdG90YWxQYWRkaW5nID0gZm9udFNpemUgKyAyICogTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRpY2tTaXplcykpICsgbGFiZWxQYWRkaW5nO1xuICB2YXIgbWluaW11bVBhZGRpbmcgPSAxLjIgKiBmb250U2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG5cbiAgdmFyIHggPSBpc1ZlcnRpY2FsID8gdG90YWxQYWRkaW5nIDogbWluaW11bVBhZGRpbmc7XG4gIHZhciB5ID0gaXNWZXJ0aWNhbCA/IG1pbmltdW1QYWRkaW5nIDogdG90YWxQYWRkaW5nO1xuICByZXR1cm4ge1xuICAgIHg6IG9mZnNldFggIT09IG51bGwgJiYgb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0WCA6IHgsXG4gICAgeTogb2Zmc2V0WSAhPT0gbnVsbCAmJiBvZmZzZXRZICE9PSB1bmRlZmluZWQgPyBvZmZzZXRZIDogeVxuICB9O1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSB7XG4gIHZhciBzY2FsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc2NhbGUsXG4gICAgICBvcmlnaW4gPSBjYWxjdWxhdGVkVmFsdWVzLm9yaWdpbixcbiAgICAgIG9yaWVudGF0aW9uID0gY2FsY3VsYXRlZFZhbHVlcy5vcmllbnRhdGlvbixcbiAgICAgIG9yaWVudGF0aW9ucyA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZW50YXRpb25zLFxuICAgICAgZG9tYWluID0gY2FsY3VsYXRlZFZhbHVlcy5kb21haW4sXG4gICAgICBwYWRkaW5nID0gY2FsY3VsYXRlZFZhbHVlcy5wYWRkaW5nO1xuICB2YXIgdG9wID0gcGFkZGluZy50b3AsXG4gICAgICBib3R0b20gPSBwYWRkaW5nLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBwYWRkaW5nLmxlZnQsXG4gICAgICByaWdodCA9IHBhZGRpbmcucmlnaHQ7XG4gIHZhciBjYWxjdWxhdGVkT3JpZW50YXRpb24gPSB7XG4gICAgeDogb3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgfHwgb3JpZW50YXRpb24gPT09IFwidG9wXCIgPyBvcmllbnRhdGlvbiA6IG9yaWVudGF0aW9ucy54LFxuICAgIHk6IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueVxuICB9OyAvLyBtYWtlIHRoZSBheGVzIGxpbmUgdXAsIGFuZCBjcm9zcyB3aGVuIGFwcHJvcHJpYXRlXG5cbiAgdmFyIG9yaWVudGF0aW9uT2Zmc2V0ID0ge1xuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImxlZnRcIiA/IGxlZnQgOiByaWdodCxcbiAgICB5OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueCA9PT0gXCJib3R0b21cIiA/IGJvdHRvbSA6IHRvcFxuICB9O1xuICB2YXIgb3JpZ2luT2Zmc2V0ID0ge1xuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImxlZnRcIiA/IDAgOiBwcm9wcy53aWR0aCxcbiAgICB5OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueCA9PT0gXCJib3R0b21cIiA/IHByb3BzLmhlaWdodCA6IDBcbiAgfTtcbiAgdmFyIG9yaWdpblBvc2l0aW9uID0ge1xuICAgIHg6IG9yaWdpbi54ID09PSBkb21haW4ueFswXSB8fCBvcmlnaW4ueCA9PT0gZG9tYWluLnhbMV0gPyAwIDogc2NhbGUueChvcmlnaW4ueCksXG4gICAgeTogb3JpZ2luLnkgPT09IGRvbWFpbi55WzBdIHx8IG9yaWdpbi55ID09PSBkb21haW4ueVsxXSA/IDAgOiBzY2FsZS55KG9yaWdpbi55KVxuICB9O1xuICB2YXIgeCA9IG9yaWdpblBvc2l0aW9uLnggPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueCAtIG9yaWdpblBvc2l0aW9uLngpIDogb3JpZW50YXRpb25PZmZzZXQueDtcbiAgdmFyIHkgPSBvcmlnaW5Qb3NpdGlvbi55ID8gTWF0aC5hYnMob3JpZ2luT2Zmc2V0LnkgLSBvcmlnaW5Qb3NpdGlvbi55KSA6IG9yaWVudGF0aW9uT2Zmc2V0Lnk7XG4gIHZhciBvZmZzZXRYID0gZXhpc3RzKHByb3BzLm9mZnNldFgpID8gcHJvcHMub2Zmc2V0WCA6IHg7XG4gIHZhciBvZmZzZXRZID0gZXhpc3RzKHByb3BzLm9mZnNldFkpID8gcHJvcHMub2Zmc2V0WSA6IHk7XG4gIHJldHVybiB7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH07XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbnZhciBnZXRIb3Jpem9udGFsT2Zmc2V0ID0gZnVuY3Rpb24gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSB7XG4gIHZhciBzY2FsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc2NhbGUsXG4gICAgICBvcmlnaW4gPSBjYWxjdWxhdGVkVmFsdWVzLm9yaWdpbixcbiAgICAgIG9yaWVudGF0aW9uID0gY2FsY3VsYXRlZFZhbHVlcy5vcmllbnRhdGlvbixcbiAgICAgIG9yaWVudGF0aW9ucyA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZW50YXRpb25zLFxuICAgICAgZG9tYWluID0gY2FsY3VsYXRlZFZhbHVlcy5kb21haW4sXG4gICAgICBwYWRkaW5nID0gY2FsY3VsYXRlZFZhbHVlcy5wYWRkaW5nO1xuICB2YXIgdG9wID0gcGFkZGluZy50b3AsXG4gICAgICBib3R0b20gPSBwYWRkaW5nLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBwYWRkaW5nLmxlZnQsXG4gICAgICByaWdodCA9IHBhZGRpbmcucmlnaHQ7XG4gIHZhciBjYWxjdWxhdGVkT3JpZW50YXRpb24gPSB7XG4gICAgeTogb3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgfHwgb3JpZW50YXRpb24gPT09IFwidG9wXCIgPyBvcmllbnRhdGlvbiA6IG9yaWVudGF0aW9ucy54LFxuICAgIHg6IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueVxuICB9OyAvLyBtYWtlIHRoZSBheGVzIGxpbmUgdXAsIGFuZCBjcm9zcyB3aGVuIGFwcHJvcHJpYXRlXG5cbiAgdmFyIG9yaWVudGF0aW9uT2Zmc2V0ID0ge1xuICAgIHg6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi55ID09PSBcImJvdHRvbVwiID8gYm90dG9tIDogdG9wLFxuICAgIHk6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi54ID09PSBcImxlZnRcIiA/IGxlZnQgOiByaWdodFxuICB9O1xuICB2YXIgb3JpZ2luT2Zmc2V0ID0ge1xuICAgIHk6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi54ID09PSBcImxlZnRcIiA/IDAgOiBwcm9wcy53aWR0aCxcbiAgICB4OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueSA9PT0gXCJib3R0b21cIiA/IHByb3BzLmhlaWdodCA6IDBcbiAgfTtcbiAgdmFyIG9yaWdpblBvc2l0aW9uID0ge1xuICAgIHg6IG9yaWdpbi54ID09PSBkb21haW4ueFswXSB8fCBvcmlnaW4ueCA9PT0gZG9tYWluLnhbMV0gPyAwIDogc2NhbGUueChvcmlnaW4ueCksXG4gICAgeTogb3JpZ2luLnkgPT09IGRvbWFpbi55WzBdIHx8IG9yaWdpbi55ID09PSBkb21haW4ueVsxXSA/IDAgOiBzY2FsZS55KG9yaWdpbi55KVxuICB9O1xuICB2YXIgeSA9IG9yaWdpblBvc2l0aW9uLnggPyBNYXRoLmFicyhvcmlnaW5PZmZzZXQueCAtIG9yaWdpblBvc2l0aW9uLngpIDogb3JpZW50YXRpb25PZmZzZXQueDtcbiAgdmFyIHggPSBvcmlnaW5Qb3NpdGlvbi55ID8gTWF0aC5hYnMob3JpZ2luT2Zmc2V0LnkgLSBvcmlnaW5Qb3NpdGlvbi55KSA6IG9yaWVudGF0aW9uT2Zmc2V0Lnk7XG4gIHZhciBvZmZzZXRYID0gZXhpc3RzKHByb3BzLm9mZnNldFgpID8gcHJvcHMub2Zmc2V0WCA6IHg7XG4gIHZhciBvZmZzZXRZID0gZXhpc3RzKHByb3BzLm9mZnNldFkpID8gcHJvcHMub2Zmc2V0WSA6IHk7XG4gIHJldHVybiB7XG4gICAgeDogb2Zmc2V0WCxcbiAgICB5OiBvZmZzZXRZXG4gIH07XG59O1xuXG52YXIgZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gY2FsY3VsYXRlZFZhbHVlcy5vcmllbnRhdGlvbixcbiAgICAgIGF4aXMgPSBjYWxjdWxhdGVkVmFsdWVzLmF4aXM7XG4gIHZhciBheGlzVmFsdWUgPSBBeGlzLmdldEF4aXNWYWx1ZShwcm9wcywgYXhpcyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBvZmZzZXQueVxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBwcm9wcy5oZWlnaHQgLSBvZmZzZXQueVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgeDogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBvZmZzZXQueCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB4OiBheGlzVmFsdWUgIT09IHVuZGVmaW5lZCA/IGF4aXNWYWx1ZSA6IHByb3BzLndpZHRoIC0gb2Zmc2V0LngsXG4gICAgICB5OiAwXG4gICAgfVxuICB9W29yaWVudGF0aW9uXTtcbn07XG5cbnZhciBnZXRUaWNrUG9zaXRpb24gPSBmdW5jdGlvbiAoc3R5bGUsIG9yaWVudGF0aW9uLCBpc1ZlcnRpY2FsKSB7XG4gIHZhciB0aWNrU3R5bGUgPSBzdHlsZS50aWNrU3R5bGUsXG4gICAgICBsYWJlbFN0eWxlID0gc3R5bGUubGFiZWxTdHlsZTtcbiAgdmFyIHNpemUgPSB0aWNrU3R5bGUuc2l6ZSB8fCAwO1xuICB2YXIgdGlja1BhZGRpbmcgPSB0aWNrU3R5bGUucGFkZGluZyB8fCAwO1xuICB2YXIgbGFiZWxQYWRkaW5nID0gbGFiZWxTdHlsZS5wYWRkaW5nIHx8IDA7XG4gIHZhciB0aWNrU3BhY2luZyA9IHNpemUgKyB0aWNrUGFkZGluZyArIGxhYmVsUGFkZGluZztcbiAgdmFyIHNpZ24gPSBvcmllbnRhdGlvblNpZ25bb3JpZW50YXRpb25dO1xuICByZXR1cm4ge1xuICAgIHg6IGlzVmVydGljYWwgPyBzaWduICogdGlja1NwYWNpbmcgOiAwLFxuICAgIHgyOiBpc1ZlcnRpY2FsID8gc2lnbiAqIHNpemUgOiAwLFxuICAgIHk6IGlzVmVydGljYWwgPyAwIDogc2lnbiAqIHRpY2tTcGFjaW5nLFxuICAgIHkyOiBpc1ZlcnRpY2FsID8gMCA6IHNpZ24gKiBzaXplXG4gIH07XG59O1xuXG52YXIgZ2V0VGlja1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrLCBnbG9iYWxUcmFuc2Zvcm0sIGlzVmVydGljYWwpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc1ZlcnRpY2FsID8gZ2xvYmFsVHJhbnNmb3JtLnggOiB0aWNrICsgZ2xvYmFsVHJhbnNmb3JtLngsXG4gICAgeTogaXNWZXJ0aWNhbCA/IHRpY2sgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55XG4gIH07XG59O1xuXG52YXIgZ2V0R3JpZEVkZ2UgPSBmdW5jdGlvbiAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gY2FsY3VsYXRlZFZhbHVlcy5vcmllbnRhdGlvbixcbiAgICAgIHBhZGRpbmcgPSBjYWxjdWxhdGVkVmFsdWVzLnBhZGRpbmcsXG4gICAgICBpc1ZlcnRpY2FsID0gY2FsY3VsYXRlZFZhbHVlcy5pc1ZlcnRpY2FsO1xuICB2YXIgc2lnbiA9IC1vcmllbnRhdGlvblNpZ25bb3JpZW50YXRpb25dO1xuICB2YXIgeCA9IGlzVmVydGljYWwgPyBzaWduICogKHByb3BzLndpZHRoIC0gKHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpKSA6IDA7XG4gIHZhciB5ID0gaXNWZXJ0aWNhbCA/IDAgOiBzaWduICogKHByb3BzLmhlaWdodCAtIChwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59O1xuXG52YXIgZ2V0R3JpZE9mZnNldCA9IGZ1bmN0aW9uIChjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpIHtcbiAgdmFyIHBhZGRpbmcgPSBjYWxjdWxhdGVkVmFsdWVzLnBhZGRpbmcsXG4gICAgICBvcmllbnRhdGlvbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZW50YXRpb24sXG4gICAgICBjcm9zc0F4aXMgPSBjYWxjdWxhdGVkVmFsdWVzLmNyb3NzQXhpcztcbiAgdmFyIHhQYWRkaW5nID0gb3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IHBhZGRpbmcucmlnaHQgOiBwYWRkaW5nLmxlZnQ7XG4gIHZhciB5UGFkZGluZyA9IG9yaWVudGF0aW9uID09PSBcInRvcFwiID8gcGFkZGluZy50b3AgOiBwYWRkaW5nLmJvdHRvbTtcbiAgcmV0dXJuIHtcbiAgICB4OiBjcm9zc0F4aXMgPyBvZmZzZXQueCAtIHhQYWRkaW5nIDogMCxcbiAgICB5OiBjcm9zc0F4aXMgPyBvZmZzZXQueSAtIHlQYWRkaW5nIDogMFxuICB9O1xufTtcblxudmFyIGdldExheW91dFByb3BzID0gZnVuY3Rpb24gKG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpIHtcbiAgdmFyIG9mZnNldDtcblxuICBpZiAoY2FsY3VsYXRlZFZhbHVlcy5kb21haW4ueCAmJiBjYWxjdWxhdGVkVmFsdWVzLmRvbWFpbi55KSB7XG4gICAgb2Zmc2V0ID0gbW9kaWZpZWRQcm9wcy5ob3Jpem9udGFsID8gZ2V0SG9yaXpvbnRhbE9mZnNldChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA6IGdldE9mZnNldChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBnZXRTdGFuZGFsb25lT2Zmc2V0KG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnbG9iYWxUcmFuc2Zvcm06IGdldFRyYW5zZm9ybShtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpLFxuICAgIGdyaWRPZmZzZXQ6IGdldEdyaWRPZmZzZXQoY2FsY3VsYXRlZFZhbHVlcywgb2Zmc2V0KSxcbiAgICBncmlkRWRnZTogZ2V0R3JpZEVkZ2UobW9kaWZpZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcylcbiAgfTtcbn07XG5cbnZhciBnZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChwcm9wcykge1xuICBpZiAocHJvcHMub3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4gcHJvcHMub3JpZW50YXRpb247XG4gIH1cblxuICB2YXIgZGVmYXVsdE9yaWVudGF0aW9ucyA9IHtcbiAgICBkZXBlbmRlbnQ6IHByb3BzLmhvcml6b250YWwgPyBcImJvdHRvbVwiIDogXCJsZWZ0XCIsXG4gICAgaW5kZXBlbmRlbnQ6IHByb3BzLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwiYm90dG9tXCJcbiAgfTtcbiAgcmV0dXJuIHByb3BzLmRlcGVuZGVudEF4aXMgPyBkZWZhdWx0T3JpZW50YXRpb25zLmRlcGVuZGVudCA6IGRlZmF1bHRPcmllbnRhdGlvbnMuaW5kZXBlbmRlbnQ7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbnZhciBnZXRDYWxjdWxhdGVkVmFsdWVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciBkZWZhdWx0U3R5bGVzID0gZ2V0U3R5bGVPYmplY3QocHJvcHMpO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZXMocHJvcHMsIGRlZmF1bHRTdHlsZXMpO1xuICB2YXIgcGFkZGluZyA9IEhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyk7XG4gIHZhciBsYWJlbFBhZGRpbmcgPSBnZXRMYWJlbFBhZGRpbmcocHJvcHMsIHN0eWxlKTtcbiAgdmFyIHN0cmluZ1RpY2tzID0gQXhpcy5zdHJpbmdUaWNrcyhwcm9wcykgPyBwcm9wcy50aWNrVmFsdWVzIDogdW5kZWZpbmVkO1xuICB2YXIgYXhpcyA9IEF4aXMuZ2V0QXhpcyhwcm9wcyk7XG4gIHZhciBheGlzRG9tYWluID0gQXhpcy5nZXREb21haW4ocHJvcHMpO1xuICB2YXIgYXhpc1NjYWxlID0gZ2V0U2NhbGUocHJvcHMpO1xuICB2YXIgeEF4aXNEb21haW4gPSBheGlzID09PSBcInhcIiA/IGF4aXNEb21haW4gOiB1bmRlZmluZWQ7XG4gIHZhciB5QXhpc0RvbWFpbiA9IGF4aXMgPT09IFwieVwiID8gYXhpc0RvbWFpbiA6IHVuZGVmaW5lZDtcbiAgdmFyIHhBeGlzU2NhbGUgPSBheGlzID09PSBcInhcIiA/IGF4aXNTY2FsZSA6IHVuZGVmaW5lZDtcbiAgdmFyIHlBeGlzU2NhbGUgPSBheGlzID09PSBcInlcIiA/IGF4aXNTY2FsZSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNyb3NzQXhpcyA9ICEocHJvcHMuY3Jvc3NBeGlzID09PSBmYWxzZSB8fCBwcm9wcy5zdGFuZGFsb25lID09PSB0cnVlKTtcbiAgdmFyIHRpY2tzID0gQXhpcy5nZXRUaWNrcyhwcm9wcywgYXhpc1NjYWxlLCBjcm9zc0F4aXMpO1xuICB2YXIgdGlja0Zvcm1hdCA9IEF4aXMuZ2V0VGlja0Zvcm1hdChwcm9wcywgYXhpc1NjYWxlKTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIHg6IEhlbHBlcnMuZ2V0UmFuZ2UocHJvcHMsIFwieFwiKSxcbiAgICB5OiBIZWxwZXJzLmdldFJhbmdlKHByb3BzLCBcInlcIilcbiAgfTsgLy8gdXNlIGZ1bGwgZG9tYWluIGlmIHBhc3NlZCBpbiBmcm9tIHBhcmVudCxcbiAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUganVzdCB0aGUgb25lIGF4aXMgYXZhaWxhYmxlXG5cbiAgdmFyIGRvbWFpbiA9IHtcbiAgICB4OiBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluLnggPyBwcm9wcy5kb21haW4ueCA6IHhBeGlzRG9tYWluLFxuICAgIHk6IHByb3BzLmRvbWFpbiAmJiBwcm9wcy5kb21haW4ueSA/IHByb3BzLmRvbWFpbi55IDogeUF4aXNEb21haW5cbiAgfTsgLy8gdXNlIGZ1bGwgc2NhbGUgaWYgcGFzc2VkIGluIGZyb20gcGFyZW50LFxuICAvLyBvdGhlcndpc2UgdXNlIHRoZSBqdXN0IHRoZSBvbmUgYXhpcyBhdmFpbGFibGVcblxuICB2YXIgc2NhbGUgPSB7XG4gICAgeDogcHJvcHMuZG9tYWluICYmIHByb3BzLmRvbWFpbi54ID8gU2NhbGUuZ2V0QmFzZVNjYWxlKHByb3BzLCBcInhcIikuZG9tYWluKHByb3BzLmRvbWFpbi54KS5yYW5nZShwcm9wcy5ob3Jpem9udGFsID8gcmFuZ2UueSA6IHJhbmdlLngpIDogeEF4aXNTY2FsZSxcbiAgICB5OiBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluLnkgPyBTY2FsZS5nZXRCYXNlU2NhbGUocHJvcHMsIFwieVwiKS5kb21haW4ocHJvcHMuZG9tYWluLnkpLnJhbmdlKHByb3BzLmhvcml6b250YWwgPyByYW5nZS54IDogcmFuZ2UueSkgOiB5QXhpc1NjYWxlXG4gIH07XG4gIHZhciBvcmlnaW4gPSBkb21haW4ueCAmJiBkb21haW4ueSA/IEF4aXMuZ2V0T3JpZ2luKGRvbWFpbikgOiB1bmRlZmluZWQ7XG4gIHZhciBvcmlnaW5TaWduID0gb3JpZ2luID8ge1xuICAgIHg6IEF4aXMuZ2V0T3JpZ2luU2lnbihvcmlnaW4ueCwgZG9tYWluLngpLFxuICAgIHk6IEF4aXMuZ2V0T3JpZ2luU2lnbihvcmlnaW4ueSwgZG9tYWluLnkpXG4gIH0gOiB1bmRlZmluZWQ7XG4gIHZhciBvcmllbnRhdGlvbnMgPSBvcmlnaW5TaWduID8ge1xuICAgIHg6IGdldERlZmF1bHRPcmllbnRhdGlvbnMoXCJ4XCIsIG9yaWdpblNpZ24ueSwgcHJvcHMuaG9yaXpvbnRhbCksXG4gICAgeTogZ2V0RGVmYXVsdE9yaWVudGF0aW9ucyhcInlcIiwgb3JpZ2luU2lnbi54LCBwcm9wcy5ob3Jpem9udGFsKVxuICB9IDogdW5kZWZpbmVkO1xuICB2YXIgb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbnMgPyBwcm9wcy5vcmllbnRhdGlvbiB8fCBvcmllbnRhdGlvbnNbYXhpc10gOiBnZXRPcmllbnRhdGlvbihwcm9wcyk7XG4gIHZhciBpc1ZlcnRpY2FsID0gQXhpcy5pc1ZlcnRpY2FsKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uXG4gIH0pKTtcbiAgdmFyIGFuY2hvcnMgPSBnZXRBbmNob3JzKG9yaWVudGF0aW9uLCBpc1ZlcnRpY2FsKTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3JzOiBhbmNob3JzLFxuICAgIGF4aXM6IGF4aXMsXG4gICAgY3Jvc3NBeGlzOiBjcm9zc0F4aXMsXG4gICAgZG9tYWluOiBkb21haW4sXG4gICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICBsYWJlbFBhZGRpbmc6IGxhYmVsUGFkZGluZyxcbiAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgb3JpZW50YXRpb25zOiBvcmllbnRhdGlvbnMsXG4gICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3RyaW5nVGlja3M6IHN0cmluZ1RpY2tzLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgIHRpY2tzOiB0aWNrc1xuICB9O1xufTtcblxuZXhwb3J0IHZhciBnZXRCYXNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGZhbGxiYWNrUHJvcHMpIHtcbiAgcHJvcHMgPSBBeGlzLm1vZGlmeVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzKTtcbiAgdmFyIGNhbGN1bGF0ZWRWYWx1ZXMgPSBnZXRDYWxjdWxhdGVkVmFsdWVzKHByb3BzKTtcbiAgdmFyIGF4aXMgPSBjYWxjdWxhdGVkVmFsdWVzLmF4aXMsXG4gICAgICBzdHlsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc3R5bGUsXG4gICAgICBvcmllbnRhdGlvbiA9IGNhbGN1bGF0ZWRWYWx1ZXMub3JpZW50YXRpb24sXG4gICAgICBpc1ZlcnRpY2FsID0gY2FsY3VsYXRlZFZhbHVlcy5pc1ZlcnRpY2FsLFxuICAgICAgc2NhbGUgPSBjYWxjdWxhdGVkVmFsdWVzLnNjYWxlLFxuICAgICAgdGlja3MgPSBjYWxjdWxhdGVkVmFsdWVzLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IGNhbGN1bGF0ZWRWYWx1ZXMudGlja0Zvcm1hdCxcbiAgICAgIGFuY2hvcnMgPSBjYWxjdWxhdGVkVmFsdWVzLmFuY2hvcnMsXG4gICAgICBkb21haW4gPSBjYWxjdWxhdGVkVmFsdWVzLmRvbWFpbixcbiAgICAgIHN0cmluZ1RpY2tzID0gY2FsY3VsYXRlZFZhbHVlcy5zdHJpbmdUaWNrcztcbiAgdmFyIG90aGVyQXhpcyA9IGF4aXMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgd2lkdGggPSBfcHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcHJvcHMuaGVpZ2h0LFxuICAgICAgc3RhbmRhbG9uZSA9IF9wcm9wcy5zdGFuZGFsb25lLFxuICAgICAgdGhlbWUgPSBfcHJvcHMudGhlbWUsXG4gICAgICBwb2xhciA9IF9wcm9wcy5wb2xhcixcbiAgICAgIHBhZGRpbmcgPSBfcHJvcHMucGFkZGluZyxcbiAgICAgIGhvcml6b250YWwgPSBfcHJvcHMuaG9yaXpvbnRhbDtcblxuICB2YXIgX2dldExheW91dFByb3BzID0gZ2V0TGF5b3V0UHJvcHMocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpLFxuICAgICAgZ2xvYmFsVHJhbnNmb3JtID0gX2dldExheW91dFByb3BzLmdsb2JhbFRyYW5zZm9ybSxcbiAgICAgIGdyaWRPZmZzZXQgPSBfZ2V0TGF5b3V0UHJvcHMuZ3JpZE9mZnNldCxcbiAgICAgIGdyaWRFZGdlID0gX2dldExheW91dFByb3BzLmdyaWRFZGdlO1xuXG4gIHZhciBzaGFyZWRQcm9wcyA9IHtcbiAgICBzY2FsZTogX2RlZmluZVByb3BlcnR5KHt9LCBheGlzLCBzY2FsZVtheGlzXSksXG4gICAgcG9sYXI6IHBvbGFyLFxuICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgdGlja3M6IHRpY2tzLFxuICAgIHN0cmluZ1RpY2tzOiBzdHJpbmdUaWNrc1xuICB9O1xuICB2YXIgYXhpc1Byb3BzID0gZ2V0QXhpc1Byb3BzKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBnbG9iYWxUcmFuc2Zvcm0pO1xuICB2YXIgYXhpc0xhYmVsUHJvcHMgPSBnZXRBeGlzTGFiZWxQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFZhbHVlcywgZ2xvYmFsVHJhbnNmb3JtKTtcbiAgdmFyIGluaXRpYWxDaGlsZFByb3BzID0ge1xuICAgIHBhcmVudDogX2Fzc2lnbih7XG4gICAgICBzdHlsZTogc3R5bGUucGFyZW50LFxuICAgICAgdGlja3M6IHRpY2tzLFxuICAgICAgc3RhbmRhbG9uZTogc3RhbmRhbG9uZSxcbiAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGRvbWFpbjogZG9tYWluXG4gICAgfSwgc2hhcmVkUHJvcHMpXG4gIH07XG4gIHZhciBncmlkUHJvcHMgPSB7XG4gICAgZGltZW5zaW9uOiBvdGhlckF4aXMsXG4gICAgcmFuZ2U6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3RoZXJBeGlzLCBIZWxwZXJzLmdldFJhbmdlKHByb3BzLCBvdGhlckF4aXMpKSxcbiAgICBzY2FsZTogcHJvcHMuc2NhbGUgJiYgcHJvcHMuc2NhbGVbb3RoZXJBeGlzXSA/IF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3RoZXJBeGlzLCBwcm9wcy5zY2FsZVtvdGhlckF4aXNdKSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gdGlja3MucmVkdWNlKGZ1bmN0aW9uIChjaGlsZFByb3BzLCB0aWNrVmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIF9zY2FsZSRheGlzLCBfc2NhbGUkYXhpczIsIF9zY2FsZSRheGlzMztcblxuICAgIHZhciB0aWNrID0gc3RyaW5nVGlja3MgPyBzdHJpbmdUaWNrc1tpbmRleF0gOiB0aWNrVmFsdWU7XG4gICAgdmFyIHRleHQgPSB0aWNrRm9ybWF0KHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB2YXIgc3R5bGVzID0gZ2V0RXZhbHVhdGVkU3R5bGVzKHN0eWxlLCBfYXNzaWduKHt9LCBzaGFyZWRQcm9wcywge1xuICAgICAgdGljazogdGljayxcbiAgICAgIHRpY2tWYWx1ZTogdGlja1ZhbHVlLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgdGV4dDogdGV4dFxuICAgIH0pKTtcbiAgICB2YXIgdGlja0xheW91dCA9IHtcbiAgICAgIHBvc2l0aW9uOiBnZXRUaWNrUG9zaXRpb24oc3R5bGVzLCBvcmllbnRhdGlvbiwgaXNWZXJ0aWNhbCksXG4gICAgICB0cmFuc2Zvcm06IGdldFRpY2tUcmFuc2Zvcm0oKF9zY2FsZSRheGlzID0gc2NhbGVbYXhpc10pID09PSBudWxsIHx8IF9zY2FsZSRheGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NhbGUkYXhpcy5jYWxsKHNjYWxlLCB0aWNrVmFsdWUpLCBnbG9iYWxUcmFuc2Zvcm0sIGlzVmVydGljYWwpXG4gICAgfTtcbiAgICB2YXIgZ3JpZExheW91dCA9IHtcbiAgICAgIGVkZ2U6IGdyaWRFZGdlLFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHg6IGlzVmVydGljYWwgPyAtZ3JpZE9mZnNldC54ICsgZ2xvYmFsVHJhbnNmb3JtLnggOiAoKF9zY2FsZSRheGlzMiA9IHNjYWxlW2F4aXNdKSA9PT0gbnVsbCB8fCBfc2NhbGUkYXhpczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2FsZSRheGlzMi5jYWxsKHNjYWxlLCB0aWNrVmFsdWUpKSArIGdsb2JhbFRyYW5zZm9ybS54LFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gKChfc2NhbGUkYXhpczMgPSBzY2FsZVtheGlzXSkgPT09IG51bGwgfHwgX3NjYWxlJGF4aXMzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NhbGUkYXhpczMuY2FsbChzY2FsZSwgdGlja1ZhbHVlKSkgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdyaWRPZmZzZXQueSArIGdsb2JhbFRyYW5zZm9ybS55XG4gICAgICB9XG4gICAgfTtcbiAgICBjaGlsZFByb3BzW2luZGV4XSA9IHtcbiAgICAgIGF4aXM6IF9hc3NpZ24oe1xuICAgICAgICBkaW1lbnNpb246IGF4aXNcbiAgICAgIH0sIHNoYXJlZFByb3BzLCBheGlzUHJvcHMpLFxuICAgICAgYXhpc0xhYmVsOiBfYXNzaWduKHt9LCBzaGFyZWRQcm9wcywgYXhpc0xhYmVsUHJvcHMpLFxuICAgICAgdGlja3M6IF9hc3NpZ24oe30sIHNoYXJlZFByb3BzLCBnZXRUaWNrUHJvcHModGlja0xheW91dCwgc3R5bGVzLnRpY2tTdHlsZSwgdGlja1ZhbHVlKSksXG4gICAgICB0aWNrTGFiZWxzOiBfYXNzaWduKHt9LCBzaGFyZWRQcm9wcywgZ2V0VGlja0xhYmVsUHJvcHModGlja0xheW91dCwgc3R5bGVzLmxhYmVsU3R5bGUsIGFuY2hvcnMsIHRpY2tWYWx1ZSwgdGV4dCkpLFxuICAgICAgZ3JpZDogX2Fzc2lnbih7fSwgc2hhcmVkUHJvcHMsIGdyaWRQcm9wcywgZ2V0R3JpZFByb3BzKGdyaWRMYXlvdXQsIHN0eWxlcy5ncmlkU3R5bGUsIHRpY2tWYWx1ZSkpXG4gICAgfTtcbiAgICByZXR1cm4gY2hpbGRQcm9wcztcbiAgfSwgaW5pdGlhbENoaWxkUHJvcHMpO1xufTsiLCJpbXBvcnQgX2lzRW1wdHkgZnJvbSBcImxvZGFzaC9pc0VtcHR5XCI7XG5pbXBvcnQgX2Fzc2lnbiBmcm9tIFwibG9kYXNoL2Fzc2lnblwiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFByb3BUeXBlcyBhcyBDdXN0b21Qcm9wVHlwZXMsIFZpY3RvcnlMYWJlbCwgQ29tbW9uUHJvcHMsIFZpY3RvcnlDb250YWluZXIsIFZpY3RvcnlUaGVtZSwgTGluZVNlZ21lbnQsIFRleHRTaXplLCBhZGRFdmVudHMsIEF4aXMsIFVzZXJQcm9wcyB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbmltcG9ydCB7IGdldEJhc2VQcm9wcywgZ2V0U3R5bGVzIH0gZnJvbSBcIi4vaGVscGVyLW1ldGhvZHNcIjtcbnZhciBmYWxsYmFja1Byb3BzID0ge1xuICB3aWR0aDogNDUwLFxuICBoZWlnaHQ6IDMwMCxcbiAgcGFkZGluZzogNTBcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgY29tcG9uZW50czogW3tcbiAgICBuYW1lOiBcImF4aXNcIixcbiAgICBpbmRleDogMFxuICB9LCB7XG4gICAgbmFtZTogXCJheGlzTGFiZWxcIixcbiAgICBpbmRleDogMFxuICB9LCB7XG4gICAgbmFtZTogXCJncmlkXCJcbiAgfSwge1xuICAgIG5hbWU6IFwicGFyZW50XCIsXG4gICAgaW5kZXg6IFwicGFyZW50XCJcbiAgfSwge1xuICAgIG5hbWU6IFwidGlja3NcIlxuICB9LCB7XG4gICAgbmFtZTogXCJ0aWNrTGFiZWxzXCJcbiAgfV1cbn07XG5cbnZhciBWaWN0b3J5QXhpc0Jhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFZpY3RvcnlBeGlzQmFzZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihWaWN0b3J5QXhpc0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIFZpY3RvcnlBeGlzQmFzZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmljdG9yeUF4aXNCYXNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaWN0b3J5QXhpc0Jhc2UsIFt7XG4gICAga2V5OiBcInJlbmRlckxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGluZShwcm9wcykge1xuICAgICAgdmFyIGF4aXNDb21wb25lbnQgPSBwcm9wcy5heGlzQ29tcG9uZW50O1xuICAgICAgdmFyIGF4aXNQcm9wcyA9IHRoaXMuZ2V0Q29tcG9uZW50UHJvcHMoYXhpc0NvbXBvbmVudCwgXCJheGlzXCIsIDApO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoYXhpc0NvbXBvbmVudCwgYXhpc1Byb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWwocHJvcHMpIHtcbiAgICAgIHZhciBheGlzTGFiZWxDb21wb25lbnQgPSBwcm9wcy5heGlzTGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbDtcblxuICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNMYWJlbFByb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhheGlzTGFiZWxDb21wb25lbnQsIFwiYXhpc0xhYmVsXCIsIDApO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoYXhpc0xhYmVsQ29tcG9uZW50LCBheGlzTGFiZWxQcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckdyaWRBbmRUaWNrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJHcmlkQW5kVGlja3MocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB0aWNrQ29tcG9uZW50ID0gcHJvcHMudGlja0NvbXBvbmVudCxcbiAgICAgICAgICB0aWNrTGFiZWxDb21wb25lbnQgPSBwcm9wcy50aWNrTGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgZ3JpZENvbXBvbmVudCA9IHByb3BzLmdyaWRDb21wb25lbnQsXG4gICAgICAgICAgbmFtZSA9IHByb3BzLm5hbWU7XG5cbiAgICAgIHZhciBzaG91bGRSZW5kZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50UHJvcHMpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnRQcm9wcyRzdHlsZSA9IGNvbXBvbmVudFByb3BzLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGUgPSBfY29tcG9uZW50UHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX2NvbXBvbmVudFByb3BzJHN0eWxlLFxuICAgICAgICAgICAgX2NvbXBvbmVudFByb3BzJGV2ZW50ID0gY29tcG9uZW50UHJvcHMuZXZlbnRzLFxuICAgICAgICAgICAgZXZlbnRzID0gX2NvbXBvbmVudFByb3BzJGV2ZW50ID09PSB2b2lkIDAgPyB7fSA6IF9jb21wb25lbnRQcm9wcyRldmVudDtcbiAgICAgICAgdmFyIHZpc2libGUgPSBzdHlsZS5zdHJva2UgIT09IFwidHJhbnNwYXJlbnRcIiAmJiBzdHlsZS5zdHJva2UgIT09IFwibm9uZVwiICYmIHN0eWxlLnN0cm9rZVdpZHRoICE9PSAwO1xuICAgICAgICByZXR1cm4gdmlzaWJsZSB8fCAhX2lzRW1wdHkoZXZlbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGFLZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICB2YXIgdGlja1Byb3BzID0gX3RoaXMuZ2V0Q29tcG9uZW50UHJvcHModGlja0NvbXBvbmVudCwgXCJ0aWNrc1wiLCBpbmRleCk7XG5cbiAgICAgICAgdmFyIEJhc2VUaWNrQ29tcG9uZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudCh0aWNrQ29tcG9uZW50LCB0aWNrUHJvcHMpO1xuICAgICAgICB2YXIgVGlja0NvbXBvbmVudCA9IHNob3VsZFJlbmRlcihCYXNlVGlja0NvbXBvbmVudC5wcm9wcykgPyBCYXNlVGlja0NvbXBvbmVudCA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgZ3JpZFByb3BzID0gX3RoaXMuZ2V0Q29tcG9uZW50UHJvcHMoZ3JpZENvbXBvbmVudCwgXCJncmlkXCIsIGluZGV4KTtcblxuICAgICAgICB2YXIgQmFzZUdyaWRDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGdyaWRDb21wb25lbnQsIGdyaWRQcm9wcyk7XG4gICAgICAgIHZhciBHcmlkQ29tcG9uZW50ID0gc2hvdWxkUmVuZGVyKEJhc2VHcmlkQ29tcG9uZW50LnByb3BzKSA/IEJhc2VHcmlkQ29tcG9uZW50IDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciB0aWNrTGFiZWxQcm9wcyA9IF90aGlzLmdldENvbXBvbmVudFByb3BzKHRpY2tMYWJlbENvbXBvbmVudCwgXCJ0aWNrTGFiZWxzXCIsIGluZGV4KTtcblxuICAgICAgICB2YXIgVGlja0xhYmVsID0gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudCh0aWNrTGFiZWxDb21wb25lbnQsIHRpY2tMYWJlbFByb3BzKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW0dyaWRDb21wb25lbnQsIFRpY2tDb21wb25lbnQsIFRpY2tMYWJlbF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChwcm9wcy5ncm91cENvbXBvbmVudCwge1xuICAgICAgICAgIGtleTogXCJcIi5jb25jYXQobmFtZSwgXCItdGljay1ncm91cC1cIikuY29uY2F0KGtleSlcbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpeExhYmVsT3ZlcmxhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXhMYWJlbE92ZXJsYXAoZ3JpZEFuZFRpY2tzLCBwcm9wcykge1xuICAgICAgdmFyIGlzVmVydGljYWwgPSBBeGlzLmlzVmVydGljYWwocHJvcHMpO1xuICAgICAgdmFyIHNpemUgPSBpc1ZlcnRpY2FsID8gcHJvcHMuaGVpZ2h0IDogcHJvcHMud2lkdGg7XG5cbiAgICAgIHZhciBpc1ZpY3RvcnlMYWJlbCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLnJvbGUgPT09IFwibGFiZWxcIjtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbHMgPSBncmlkQW5kVGlja3MubWFwKGZ1bmN0aW9uIChncmlkQW5kVGljaykge1xuICAgICAgICByZXR1cm4gZ3JpZEFuZFRpY2sucHJvcHMuY2hpbGRyZW47XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjaGlsZEFycikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IuY29uY2F0KGNoaWxkQXJyKTtcbiAgICAgIH0sIFtdKS5maWx0ZXIoaXNWaWN0b3J5TGFiZWwpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnByb3BzO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBwYWRkaW5nVG9PYmplY3QgPSBmdW5jdGlvbiAocGFkZGluZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgPT09IFwib2JqZWN0XCIgPyBfYXNzaWduKHt9LCB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH0sIHBhZGRpbmcpIDoge1xuICAgICAgICAgIHRvcDogcGFkZGluZyxcbiAgICAgICAgICByaWdodDogcGFkZGluZyxcbiAgICAgICAgICBib3R0b206IHBhZGRpbmcsXG4gICAgICAgICAgbGVmdDogcGFkZGluZ1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsc1N1bVNpemUgPSBsYWJlbHMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGxhYmVsKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ1RvT2JqZWN0KGxhYmVsLnN0eWxlLnBhZGRpbmcpO1xuICAgICAgICB2YXIgbGFiZWxTaXplID0gVGV4dFNpemUuYXBwcm94aW1hdGVUZXh0U2l6ZShsYWJlbC50ZXh0LCB7XG4gICAgICAgICAgYW5nbGU6IGxhYmVsLmFuZ2xlLFxuICAgICAgICAgIGZvbnRTaXplOiBsYWJlbC5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBsYWJlbC5zdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLnN0eWxlLmZvbnRGYW1pbHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdW0gKyAoaXNWZXJ0aWNhbCA/IGxhYmVsU2l6ZS5oZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tIDogbGFiZWxTaXplLndpZHRoICsgcGFkZGluZy5yaWdodCArIHBhZGRpbmcubGVmdCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBhdmFpbGlhYmxlTGFiZWxDb3VudCA9IE1hdGguZmxvb3Ioc2l6ZSAqIGdyaWRBbmRUaWNrcy5sZW5ndGggLyBsYWJlbHNTdW1TaXplKTtcbiAgICAgIHZhciBkaXZpZGVyID0gTWF0aC5jZWlsKGdyaWRBbmRUaWNrcy5sZW5ndGggLyBhdmFpbGlhYmxlTGFiZWxDb3VudCkgfHwgMTtcblxuICAgICAgdmFyIGdldExhYmVsQ29vcmQgPSBmdW5jdGlvbiAoZ3JpZEFuZFRpY2spIHtcbiAgICAgICAgcmV0dXJuIGdyaWRBbmRUaWNrLnByb3BzLmNoaWxkcmVuLmZpbHRlcihpc1ZpY3RvcnlMYWJlbCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjaGlsZCkge1xuICAgICAgICAgIHJldHVybiAoaXNWZXJ0aWNhbCA/IGNoaWxkLnByb3BzLnkgOiBjaGlsZC5wcm9wcy54KSB8fCAwO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzb3J0ZWQgPSBncmlkQW5kVGlja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gaXNWZXJ0aWNhbCA/IGdldExhYmVsQ29vcmQoYikgLSBnZXRMYWJlbENvb3JkKGEpIC8vIG9yZGluYXJ5IGF4aXMgaGFzIHRvcC1ib3R0b20gb3JpZW50YXRpb25cbiAgICAgICAgOiBnZXRMYWJlbENvb3JkKGEpIC0gZ2V0TGFiZWxDb29yZChiKTtcbiAgICAgIH0gLy8gb3JkaW5hcnkgYXhpcyBoYXMgbGVmdC1yaWdodCBvcmllbnRhdGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybiBzb3J0ZWQuZmlsdGVyKGZ1bmN0aW9uIChncmlkQW5kVGljaywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICUgZGl2aWRlciA9PT0gMDtcbiAgICAgIH0pO1xuICAgIH0gLy8gT3ZlcnJpZGRlbiBpbiBuYXRpdmUgdmVyc2lvbnNcblxuICB9LCB7XG4gICAga2V5OiBcInNob3VsZEFuaW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQW5pbWF0ZSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMucHJvcHMuYW5pbWF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBhbmltYXRpb25XaGl0ZWxpc3QgPSBWaWN0b3J5QXhpcy5hbmltYXRpb25XaGl0ZWxpc3Q7XG4gICAgICB2YXIgcHJvcHMgPSBBeGlzLm1vZGlmeVByb3BzKHRoaXMucHJvcHMsIGZhbGxiYWNrUHJvcHMpO1xuICAgICAgdmFyIHVzZXJQcm9wcyA9IFVzZXJQcm9wcy5nZXRTYWZlVXNlclByb3BzKHRoaXMucHJvcHMpO1xuXG4gICAgICBpZiAodGhpcy5zaG91bGRBbmltYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZUNvbXBvbmVudChwcm9wcywgYW5pbWF0aW9uV2hpdGVsaXN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyaWRBbmRUaWNrcyA9IHRoaXMucmVuZGVyR3JpZEFuZFRpY2tzKHByb3BzKTtcbiAgICAgIHZhciBtb2RpZmllZEdyaWRBbmRUaWNrcyA9IHByb3BzLmZpeExhYmVsT3ZlcmxhcCA/IHRoaXMuZml4TGFiZWxPdmVybGFwKGdyaWRBbmRUaWNrcywgcHJvcHMpIDogZ3JpZEFuZFRpY2tzO1xuICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMucmVuZGVyTGluZShwcm9wcyksIHRoaXMucmVuZGVyTGFiZWwocHJvcHMpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1vZGlmaWVkR3JpZEFuZFRpY2tzKSk7XG4gICAgICB2YXIgY29udGFpbmVyID0gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChwcm9wcy5jb250YWluZXJDb21wb25lbnQsIHVzZXJQcm9wcyk7XG4gICAgICByZXR1cm4gcHJvcHMuc3RhbmRhbG9uZSA/IHRoaXMucmVuZGVyQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGRyZW4pIDogLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChwcm9wcy5ncm91cENvbXBvbmVudCwgdXNlclByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpY3RvcnlBeGlzQmFzZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVmljdG9yeUF4aXNCYXNlLmFuaW1hdGlvbldoaXRlbGlzdCA9IFtcInN0eWxlXCIsIFwiZG9tYWluXCIsIFwicmFuZ2VcIiwgXCJ0aWNrQ291bnRcIiwgXCJ0aWNrVmFsdWVzXCIsIFwib2Zmc2V0WFwiLCBcIm9mZnNldFlcIiwgXCJwYWRkaW5nXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl07XG5WaWN0b3J5QXhpc0Jhc2UuZGlzcGxheU5hbWUgPSBcIlZpY3RvcnlBeGlzXCI7XG5WaWN0b3J5QXhpc0Jhc2Uucm9sZSA9IFwiYXhpc1wiO1xuVmljdG9yeUF4aXNCYXNlLmRlZmF1bHRUcmFuc2l0aW9ucyA9IHtcbiAgb25FeGl0OiB7XG4gICAgZHVyYXRpb246IDUwMFxuICB9LFxuICBvbkVudGVyOiB7XG4gICAgZHVyYXRpb246IDUwMFxuICB9XG59O1xuVmljdG9yeUF4aXNCYXNlLnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgQ29tbW9uUHJvcHMuYmFzZVByb3BzKSwge30sIHtcbiAgYXhpc0NvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIGF4aXNMYWJlbENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIGF4aXNWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBjYXRlZ29yaWVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICB5OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKVxuICB9KV0pLFxuICBjcm9zc0F4aXM6IFByb3BUeXBlcy5ib29sLFxuICBkZXBlbmRlbnRBeGlzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHRhcmdldDogUHJvcFR5cGVzLm9uZU9mKFtcImF4aXNcIiwgXCJheGlzTGFiZWxcIiwgXCJncmlkXCIsIFwidGlja3NcIiwgXCJ0aWNrTGFiZWxzXCJdKSxcbiAgICBldmVudEtleTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBDdXN0b21Qcm9wVHlwZXMuYWxsT2ZUeXBlKFtDdXN0b21Qcm9wVHlwZXMuaW50ZWdlciwgQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlXSksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBldmVudEhhbmRsZXJzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pKSxcbiAgZml4TGFiZWxPdmVybGFwOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ3JpZENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIGdyb3VwQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgaW52ZXJ0QXhpczogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuYW55LFxuICBvZmZzZXRYOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvZmZzZXRZOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSksXG4gIG9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHk6IFByb3BUeXBlcy5udW1iZXJcbiAgfSksXG4gIHN0cmluZ01hcDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc3R5bGU6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcGFyZW50OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGF4aXM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgYXhpc0xhYmVsOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGdyaWQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdGlja3M6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdGlja0xhYmVsczogUHJvcFR5cGVzLm9iamVjdFxuICB9KSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIHRpY2tDb3VudDogQ3VzdG9tUHJvcFR5cGVzLmFsbE9mVHlwZShbQ3VzdG9tUHJvcFR5cGVzLmludGVnZXIsIEN1c3RvbVByb3BUeXBlcy5ncmVhdGVyVGhhblplcm9dKSxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIEN1c3RvbVByb3BUeXBlcy5ob21vZ2VuZW91c0FycmF5XSksXG4gIHRpY2tMYWJlbENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIHRpY2tWYWx1ZXM6IEN1c3RvbVByb3BUeXBlcy5ob21vZ2VuZW91c0FycmF5XG59KTtcblZpY3RvcnlBeGlzQmFzZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGF4aXNDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmVTZWdtZW50LCBudWxsKSxcbiAgYXhpc0xhYmVsQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5TGFiZWwsIG51bGwpLFxuICB0aWNrTGFiZWxDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlMYWJlbCwgbnVsbCksXG4gIHRpY2tDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmVTZWdtZW50LCBudWxsKSxcbiAgZ3JpZENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZVNlZ21lbnQsIG51bGwpLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICB0aGVtZTogVmljdG9yeVRoZW1lLmdyYXlzY2FsZSxcbiAgY29udGFpbmVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5Q29udGFpbmVyLCBudWxsKSxcbiAgZ3JvdXBDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgcm9sZTogXCJwcmVzZW50YXRpb25cIlxuICB9KSxcbiAgZml4TGFiZWxPdmVybGFwOiBmYWxzZVxufTtcblZpY3RvcnlBeGlzQmFzZS5nZXREb21haW4gPSBBeGlzLmdldERvbWFpbjtcblZpY3RvcnlBeGlzQmFzZS5nZXRBeGlzID0gQXhpcy5nZXRBeGlzO1xuXG5WaWN0b3J5QXhpc0Jhc2UuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBnZXRTdHlsZXMocHJvcHMpO1xufTtcblxuVmljdG9yeUF4aXNCYXNlLmdldEJhc2VQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gZ2V0QmFzZVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzKTtcbn07XG5cblZpY3RvcnlBeGlzQmFzZS5leHBlY3RlZENvbXBvbmVudHMgPSBbXCJheGlzQ29tcG9uZW50XCIsIFwiYXhpc0xhYmVsQ29tcG9uZW50XCIsIFwiZ3JvdXBDb21wb25lbnRcIiwgXCJjb250YWluZXJDb21wb25lbnRcIiwgXCJ0aWNrQ29tcG9uZW50XCIsIFwidGlja0xhYmVsQ29tcG9uZW50XCIsIFwiZ3JpZENvbXBvbmVudFwiXTtcbmV4cG9ydCB2YXIgVmljdG9yeUF4aXMgPSBhZGRFdmVudHMoVmljdG9yeUF4aXNCYXNlLCBvcHRpb25zKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73091\n')}}]);