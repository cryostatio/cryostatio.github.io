"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[5873],{77013:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": () => (/* binding */ VictoryTooltip)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash/orderBy.js\nvar orderBy = __webpack_require__(75472);\nvar orderBy_default = /*#__PURE__*/__webpack_require__.n(orderBy);\n// EXTERNAL MODULE: ./node_modules/lodash/isPlainObject.js\nvar isPlainObject = __webpack_require__(68630);\nvar isPlainObject_default = /*#__PURE__*/__webpack_require__.n(isPlainObject);\n// EXTERNAL MODULE: ./node_modules/lodash/uniqueId.js\nvar uniqueId = __webpack_require__(73955);\nvar uniqueId_default = /*#__PURE__*/__webpack_require__.n(uniqueId);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/label-helpers.js\nvar label_helpers = __webpack_require__(46144);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/textsize.js\nvar textsize = __webpack_require__(82254);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-portal/victory-portal.js\nvar victory_portal = __webpack_require__(73841);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-label/victory-label.js + 2 modules\nvar victory_label = __webpack_require__(41248);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/user-props.js\nvar user_props = __webpack_require__(80450);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/common-props.js\nvar common_props = __webpack_require__(5734);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/path.js\nvar path = __webpack_require__(5613);\n;// CONCATENATED MODULE: ./node_modules/victory-tooltip/es/flyout.js\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint no-magic-numbers: ["error", { "ignore": [-1, 0, 1, 2] }]*/\n\n\n\n\nvar getVerticalPath = function (props) {\n  var pointerWidth = props.pointerWidth,\n      cornerRadius = props.cornerRadius,\n      orientation = props.orientation,\n      width = props.width,\n      height = props.height,\n      center = props.center;\n  var sign = orientation === "bottom" ? 1 : -1;\n  var x = props.x + (props.dx || 0);\n  var y = props.y + (props.dy || 0);\n  var centerX = isPlainObject_default()(center) && center.x;\n  var centerY = isPlainObject_default()(center) && center.y;\n  var pointerEdge = centerY + sign * (height / 2);\n  var oppositeEdge = centerY - sign * (height / 2);\n  var rightEdge = centerX + width / 2;\n  var leftEdge = centerX - width / 2;\n  var pointerLength = sign * (y - pointerEdge) < 0 ? 0 : props.pointerLength;\n  var direction = orientation === "bottom" ? "0 0 0" : "0 0 1";\n  var arc = "".concat(cornerRadius, " ").concat(cornerRadius, " ").concat(direction);\n  return "M ".concat(centerX - pointerWidth / 2, ", ").concat(pointerEdge, "\\n    L ").concat(pointerLength ? x : centerX + pointerWidth / 2, ", ").concat(pointerLength ? y : pointerEdge, "\\n    L ").concat(centerX + pointerWidth / 2, ", ").concat(pointerEdge, "\\n    L ").concat(rightEdge - cornerRadius, ", ").concat(pointerEdge, "\\n    A ").concat(arc, " ").concat(rightEdge, ", ").concat(pointerEdge - sign * cornerRadius, "\\n    L ").concat(rightEdge, ", ").concat(oppositeEdge + sign * cornerRadius, "\\n    A ").concat(arc, " ").concat(rightEdge - cornerRadius, ", ").concat(oppositeEdge, "\\n    L ").concat(leftEdge + cornerRadius, ", ").concat(oppositeEdge, "\\n    A ").concat(arc, " ").concat(leftEdge, ", ").concat(oppositeEdge + sign * cornerRadius, "\\n    L ").concat(leftEdge, ", ").concat(pointerEdge - sign * cornerRadius, "\\n    A ").concat(arc, " ").concat(leftEdge + cornerRadius, ", ").concat(pointerEdge, "\\n    z");\n};\n\nvar getHorizontalPath = function (props) {\n  var pointerWidth = props.pointerWidth,\n      cornerRadius = props.cornerRadius,\n      orientation = props.orientation,\n      width = props.width,\n      height = props.height,\n      center = props.center;\n  var sign = orientation === "left" ? 1 : -1;\n  var x = props.x + (props.dx || 0);\n  var y = props.y + (props.dy || 0);\n  var centerX = isPlainObject_default()(center) && center.x;\n  var centerY = isPlainObject_default()(center) && center.y;\n  var pointerEdge = centerX - sign * (width / 2);\n  var oppositeEdge = centerX + sign * (width / 2);\n  var bottomEdge = centerY + height / 2;\n  var topEdge = centerY - height / 2;\n  var pointerLength = sign * (x - pointerEdge) > 0 ? 0 : props.pointerLength;\n  var direction = orientation === "left" ? "0 0 0" : "0 0 1";\n  var arc = "".concat(cornerRadius, " ").concat(cornerRadius, " ").concat(direction);\n  return "M ".concat(pointerEdge, ", ").concat(centerY - pointerWidth / 2, "\\n    L ").concat(pointerLength ? x : pointerEdge, ", ").concat(pointerLength ? y : centerY + pointerWidth / 2, "\\n    L ").concat(pointerEdge, ", ").concat(centerY + pointerWidth / 2, "\\n    L ").concat(pointerEdge, ", ").concat(bottomEdge - cornerRadius, "\\n    A ").concat(arc, " ").concat(pointerEdge + sign * cornerRadius, ", ").concat(bottomEdge, "\\n    L ").concat(oppositeEdge - sign * cornerRadius, ", ").concat(bottomEdge, "\\n    A ").concat(arc, " ").concat(oppositeEdge, ", ").concat(bottomEdge - cornerRadius, "\\n    L ").concat(oppositeEdge, ", ").concat(topEdge + cornerRadius, "\\n    A ").concat(arc, " ").concat(oppositeEdge - sign * cornerRadius, ", ").concat(topEdge, "\\n    L ").concat(pointerEdge + sign * cornerRadius, ", ").concat(topEdge, "\\n    A ").concat(arc, " ").concat(pointerEdge, ", ").concat(topEdge + cornerRadius, "\\n    z");\n};\n\nvar getFlyoutPath = function (props) {\n  var orientation = props.orientation || "top";\n  return orientation === "left" || orientation === "right" ? getHorizontalPath(props) : getVerticalPath(props);\n};\n\nvar evaluateProps = function (props) {\n  /**\n   * Potential evaluated props are:\n   * `id`\n   * `style`\n   */\n  var id = helpers/* evaluateProp */.xs(props.id, props);\n  var style = helpers/* evaluateStyle */.F3(props.style, props);\n  return assign_default()({}, props, {\n    id: id,\n    style: style\n  });\n};\n\nvar Flyout = function (props) {\n  props = evaluateProps(props);\n  var userProps = user_props/* getSafeUserProps */.I(props);\n  return /*#__PURE__*/react.cloneElement(props.pathComponent, _objectSpread(_objectSpread(_objectSpread({}, props.events), userProps), {}, {\n    style: props.style,\n    d: getFlyoutPath(props),\n    className: props.className,\n    shapeRendering: props.shapeRendering,\n    role: props.role,\n    transform: props.transform,\n    clipPath: props.clipPath\n  }));\n};\n\nFlyout.propTypes = _objectSpread(_objectSpread({}, common_props/* CommonProps.primitiveProps */.l.primitiveProps), {}, {\n  center: prop_types_default().shape({\n    x: (prop_types_default()).number,\n    y: (prop_types_default()).number\n  }),\n  cornerRadius: (prop_types_default()).number,\n  datum: (prop_types_default()).object,\n  dx: (prop_types_default()).number,\n  dy: (prop_types_default()).number,\n  height: (prop_types_default()).number,\n  orientation: prop_types_default().oneOf(["top", "bottom", "left", "right"]),\n  pathComponent: (prop_types_default()).element,\n  pointerLength: (prop_types_default()).number,\n  pointerWidth: (prop_types_default()).number,\n  width: (prop_types_default()).number,\n  x: (prop_types_default()).number,\n  y: (prop_types_default()).number\n});\nFlyout.defaultProps = {\n  pathComponent: /*#__PURE__*/react.createElement(path/* Path */.y, null),\n  role: "presentation",\n  shapeRendering: "auto"\n};\n/* harmony default export */ const flyout = (Flyout);\n;// CONCATENATED MODULE: ./node_modules/victory-tooltip/es/victory-tooltip.js\n\n\n\n\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar fallbackProps = {\n  cornerRadius: 5,\n  pointerLength: 10,\n  pointerWidth: 10\n};\n\nvar VictoryTooltip = /*#__PURE__*/function (_React$Component) {\n  _inherits(VictoryTooltip, _React$Component);\n\n  var _super = _createSuper(VictoryTooltip);\n\n  function VictoryTooltip(props) {\n    var _this;\n\n    _classCallCheck(this, VictoryTooltip);\n\n    _this = _super.call(this, props);\n    _this.id = props.id === undefined ? uniqueId_default()("tooltip-") : props.id;\n    return _this;\n  }\n\n  _createClass(VictoryTooltip, [{\n    key: "getDefaultOrientation",\n    value: function getDefaultOrientation(props) {\n      var datum = props.datum,\n          horizontal = props.horizontal,\n          polar = props.polar;\n\n      if (!polar) {\n        var positive = horizontal ? "right" : "top";\n        var negative = horizontal ? "left" : "bottom";\n        return datum && datum.y < 0 ? negative : positive;\n      }\n\n      return this.getPolarOrientation(props, datum);\n    }\n  }, {\n    key: "getPolarOrientation",\n    value: function getPolarOrientation(props, datum) {\n      var degrees = label_helpers/* getDegrees */.ow(props, datum);\n      var placement = props.labelPlacement || "vertical";\n\n      if (placement === " vertical") {\n        return this.getVerticalOrientations(degrees);\n      } else if (placement === "parallel") {\n        return degrees < 90 || degrees > 270 ? "right" : "left";\n      }\n\n      return degrees > 180 ? "bottom" : "top";\n    }\n  }, {\n    key: "getVerticalOrientations",\n    value: function getVerticalOrientations(degrees) {\n      // eslint-disable-next-line no-magic-numbers\n      if (degrees < 45 || degrees > 315) {\n        return "right"; // eslint-disable-next-line no-magic-numbers\n      } else if (degrees >= 45 && degrees <= 135) {\n        return "top"; // eslint-disable-next-line no-magic-numbers\n      } else if (degrees > 135 && degrees < 225) {\n        return "left";\n      }\n\n      return "bottom";\n    }\n  }, {\n    key: "getStyles",\n    value: function getStyles(props) {\n      var theme = props.theme || victory_theme/* VictoryTheme.grayscale */.J.grayscale;\n      var defaultLabelStyles = theme && theme.tooltip && theme.tooltip.style ? theme.tooltip.style : {};\n      var baseLabelStyle = Array.isArray(props.style) ? props.style.map(function (s) {\n        return defaults_default()({}, s, defaultLabelStyles);\n      }) : defaults_default()({}, props.style, defaultLabelStyles);\n      var defaultFlyoutStyles = theme && theme.tooltip && theme.tooltip.flyoutStyle ? theme.tooltip.flyoutStyle : {};\n      var baseFlyoutStyle = props.flyoutStyle ? defaults_default()({}, props.flyoutStyle, defaultFlyoutStyles) : defaultFlyoutStyles;\n      var style = Array.isArray(baseLabelStyle) ? baseLabelStyle.map(function (s) {\n        return helpers/* evaluateStyle */.F3(s, props);\n      }) : helpers/* evaluateStyle */.F3(baseLabelStyle, props);\n      var flyoutStyle = helpers/* evaluateStyle */.F3(baseFlyoutStyle, assign_default()({}, props, {\n        style: style\n      }));\n      return {\n        style: style,\n        flyoutStyle: flyoutStyle\n      };\n    }\n  }, {\n    key: "getEvaluatedProps",\n    value: function getEvaluatedProps(props) {\n      var cornerRadius = props.cornerRadius,\n          centerOffset = props.centerOffset,\n          dx = props.dx,\n          dy = props.dy;\n      var active = helpers/* evaluateProp */.xs(props.active, props);\n      var text = helpers/* evaluateProp */.xs(props.text, assign_default()({}, props, {\n        active: active\n      }));\n\n      var _this$getStyles = this.getStyles(assign_default()({}, props, {\n        active: active,\n        text: text\n      })),\n          style = _this$getStyles.style,\n          flyoutStyle = _this$getStyles.flyoutStyle;\n\n      var orientation = helpers/* evaluateProp */.xs(props.orientation, assign_default()({}, props, {\n        active: active,\n        text: text,\n        style: style,\n        flyoutStyle: flyoutStyle\n      })) || this.getDefaultOrientation(props);\n      var padding = helpers/* evaluateProp */.xs(props.flyoutPadding, assign_default()({}, props, {\n        active: active,\n        text: text,\n        style: style,\n        flyoutStyle: flyoutStyle,\n        orientation: orientation\n      })) || this.getLabelPadding(style);\n      var flyoutPadding = helpers/* getPadding */.tQ({\n        padding: padding\n      });\n      var pointerWidth = helpers/* evaluateProp */.xs(props.pointerWidth, assign_default()({}, props, {\n        active: active,\n        text: text,\n        style: style,\n        flyoutStyle: flyoutStyle,\n        orientation: orientation\n      }));\n      var pointerLength = helpers/* evaluateProp */.xs(props.pointerLength, assign_default()({}, props, {\n        active: active,\n        text: text,\n        style: style,\n        flyoutStyle: flyoutStyle,\n        orientation: orientation\n      }));\n      var labelSize = textsize/* approximateTextSize */.Z9(text, style);\n\n      var _this$getDimensions = this.getDimensions(assign_default()({}, props, {\n        style: style,\n        flyoutStyle: flyoutStyle,\n        active: active,\n        text: text,\n        orientation: orientation,\n        flyoutPadding: flyoutPadding,\n        pointerWidth: pointerWidth,\n        pointerLength: pointerLength\n      }), labelSize),\n          flyoutHeight = _this$getDimensions.flyoutHeight,\n          flyoutWidth = _this$getDimensions.flyoutWidth;\n\n      var evaluatedProps = assign_default()({}, props, {\n        active: active,\n        text: text,\n        style: style,\n        flyoutStyle: flyoutStyle,\n        orientation: orientation,\n        flyoutHeight: flyoutHeight,\n        flyoutWidth: flyoutWidth,\n        flyoutPadding: flyoutPadding,\n        pointerWidth: pointerWidth,\n        pointerLength: pointerLength\n      });\n\n      var offsetX = isPlainObject_default()(centerOffset) && centerOffset.x !== undefined ? helpers/* evaluateProp */.xs(centerOffset.x, evaluatedProps) : 0;\n      var offsetY = isPlainObject_default()(centerOffset) && centerOffset.y !== undefined ? helpers/* evaluateProp */.xs(centerOffset.y, evaluatedProps) : 0;\n      return assign_default()({}, evaluatedProps, {\n        centerOffset: {\n          x: offsetX,\n          y: offsetY\n        },\n        dx: dx !== undefined ? helpers/* evaluateProp */.xs(dx, evaluatedProps) : 0,\n        dy: dy !== undefined ? helpers/* evaluateProp */.xs(dy, evaluatedProps) : 0,\n        cornerRadius: helpers/* evaluateProp */.xs(cornerRadius, evaluatedProps)\n      });\n    }\n  }, {\n    key: "getCalculatedValues",\n    value: function getCalculatedValues(props) {\n      var style = props.style,\n          text = props.text,\n          flyoutStyle = props.flyoutStyle,\n          flyoutHeight = props.flyoutHeight,\n          flyoutWidth = props.flyoutWidth;\n      var labelSize = textsize/* approximateTextSize */.Z9(text, style);\n      var flyoutDimensions = {\n        height: flyoutHeight,\n        width: flyoutWidth\n      };\n      var flyoutCenter = this.getFlyoutCenter(props, flyoutDimensions);\n      var transform = this.getTransform(props);\n      return {\n        style: style,\n        flyoutStyle: flyoutStyle,\n        labelSize: labelSize,\n        flyoutDimensions: flyoutDimensions,\n        flyoutCenter: flyoutCenter,\n        transform: transform\n      };\n    }\n  }, {\n    key: "getTransform",\n    value: function getTransform(props) {\n      var x = props.x,\n          y = props.y,\n          style = props.style;\n      var labelStyle = style || {};\n      var angle = labelStyle.angle || props.angle || this.getDefaultAngle(props);\n      return angle ? "rotate(".concat(angle, " ").concat(x, " ").concat(y, ")") : undefined;\n    } // eslint-disable-next-line complexity\n\n  }, {\n    key: "getDefaultAngle",\n    value: function getDefaultAngle(props) {\n      var polar = props.polar,\n          labelPlacement = props.labelPlacement,\n          orientation = props.orientation,\n          datum = props.datum;\n\n      if (!polar || !labelPlacement || labelPlacement === "vertical") {\n        return 0;\n      }\n\n      var degrees = label_helpers/* getDegrees */.ow(props, datum);\n      var sign = degrees > 90 && degrees < 180 || degrees > 270 ? 1 : -1;\n      var labelRotation = labelPlacement === "perpendicular" ? 0 : 90;\n      var angle;\n\n      if (degrees === 0 || degrees === 180) {\n        angle = orientation === "top" && degrees === 180 ? 270 : 90;\n      } else if (degrees > 0 && degrees < 180) {\n        angle = 90 - degrees;\n      } else if (degrees > 180 && degrees < 360) {\n        angle = 270 - degrees;\n      }\n\n      return angle + sign * labelRotation;\n    }\n  }, {\n    key: "constrainTooltip",\n    value: function constrainTooltip(center, props, dimensions) {\n      var x = center.x,\n          y = center.y;\n      var width = dimensions.width,\n          height = dimensions.height;\n      var extent = {\n        x: [0, props.width],\n        y: [0, props.height]\n      };\n      var flyoutExtent = {\n        x: [x - width / 2, x + width / 2],\n        y: [y - height / 2, y + height / 2]\n      };\n      var adjustments = {\n        x: [flyoutExtent.x[0] < extent.x[0] ? extent.x[0] - flyoutExtent.x[0] : 0, flyoutExtent.x[1] > extent.x[1] ? flyoutExtent.x[1] - extent.x[1] : 0],\n        y: [flyoutExtent.y[0] < extent.y[0] ? extent.y[0] - flyoutExtent.y[0] : 0, flyoutExtent.y[1] > extent.y[1] ? flyoutExtent.y[1] - extent.y[1] : 0]\n      };\n      return {\n        x: Math.round(x + adjustments.x[0] - adjustments.x[1]),\n        y: Math.round(y + adjustments.y[0] - adjustments.y[1])\n      };\n    } // eslint-disable-next-line complexity\n\n  }, {\n    key: "getFlyoutCenter",\n    value: function getFlyoutCenter(props, dimensions) {\n      var x = props.x,\n          y = props.y,\n          dx = props.dx,\n          dy = props.dy,\n          pointerLength = props.pointerLength,\n          orientation = props.orientation,\n          constrainToVisibleArea = props.constrainToVisibleArea,\n          centerOffset = props.centerOffset;\n      var height = dimensions.height,\n          width = dimensions.width;\n      var xSign = orientation === "left" ? -1 : 1;\n      var ySign = orientation === "bottom" ? -1 : 1;\n      var flyoutCenter = {\n        x: orientation === "left" || orientation === "right" ? x + xSign * (pointerLength + width / 2 + xSign * dx) : x + dx,\n        y: orientation === "top" || orientation === "bottom" ? y - ySign * (pointerLength + height / 2 - ySign * dy) : y + dy\n      };\n      var center = {\n        x: isPlainObject_default()(props.center) && props.center.x !== undefined ? props.center.x : flyoutCenter.x,\n        y: isPlainObject_default()(props.center) && props.center.y !== undefined ? props.center.y : flyoutCenter.y\n      };\n      var centerWithOffset = {\n        x: center.x + centerOffset.x,\n        y: center.y + centerOffset.y\n      };\n      return constrainToVisibleArea ? this.constrainTooltip(centerWithOffset, props, dimensions) : centerWithOffset;\n    }\n  }, {\n    key: "getLabelPadding",\n    value: function getLabelPadding(style) {\n      if (!style) {\n        return 0;\n      }\n\n      var paddings = Array.isArray(style) ? style.map(function (s) {\n        return s.padding;\n      }) : [style.padding];\n      return Math.max.apply(Math, _toConsumableArray(paddings).concat([0]));\n    }\n  }, {\n    key: "getDimensions",\n    value: function getDimensions(props, labelSize) {\n      var orientation = props.orientation,\n          pointerLength = props.pointerLength,\n          pointerWidth = props.pointerWidth,\n          flyoutHeight = props.flyoutHeight,\n          flyoutWidth = props.flyoutWidth,\n          flyoutPadding = props.flyoutPadding;\n      var cornerRadius = helpers/* evaluateProp */.xs(props.cornerRadius, props);\n\n      var getHeight = function () {\n        var calculatedHeight = labelSize.height + flyoutPadding.top + flyoutPadding.bottom;\n        var minHeight = orientation === "top" || orientation === "bottom" ? 2 * cornerRadius : 2 * cornerRadius + pointerWidth;\n        return Math.max(minHeight, calculatedHeight);\n      };\n\n      var getWidth = function () {\n        var calculatedWidth = labelSize.width + flyoutPadding.left + flyoutPadding.right;\n        var minWidth = orientation === "left" || orientation === "right" ? 2 * cornerRadius + pointerLength : 2 * cornerRadius;\n        return Math.max(minWidth, calculatedWidth);\n      };\n\n      return {\n        flyoutHeight: flyoutHeight ? helpers/* evaluateProp */.xs(flyoutHeight, props) : getHeight(props, labelSize, orientation),\n        flyoutWidth: flyoutWidth ? helpers/* evaluateProp */.xs(flyoutWidth, props) : getWidth(props, labelSize, orientation)\n      };\n    }\n  }, {\n    key: "getLabelProps",\n    value: function getLabelProps(props, calculatedValues) {\n      var flyoutCenter = calculatedValues.flyoutCenter,\n          style = calculatedValues.style,\n          labelSize = calculatedValues.labelSize,\n          _calculatedValues$dy = calculatedValues.dy,\n          dy = _calculatedValues$dy === void 0 ? 0 : _calculatedValues$dy,\n          _calculatedValues$dx = calculatedValues.dx,\n          dx = _calculatedValues$dx === void 0 ? 0 : _calculatedValues$dx;\n      var text = props.text,\n          datum = props.datum,\n          activePoints = props.activePoints,\n          labelComponent = props.labelComponent,\n          index = props.index,\n          flyoutPadding = props.flyoutPadding;\n      var textAnchor = (Array.isArray(style) && style.length ? style[0].textAnchor : style.textAnchor) || "middle";\n\n      var getLabelX = function () {\n        if (!textAnchor || textAnchor === "middle") {\n          return flyoutCenter.x;\n        }\n\n        var sign = textAnchor === "end" ? -1 : 1;\n        return flyoutCenter.x - sign * (labelSize.width / 2);\n      };\n\n      return defaults_default()({}, labelComponent.props, {\n        key: "".concat(this.id, "-label-").concat(index),\n        text: text,\n        datum: datum,\n        activePoints: activePoints,\n        textAnchor: textAnchor,\n        dy: dy,\n        dx: dx,\n        style: style,\n        x: getLabelX() + (flyoutPadding.left - flyoutPadding.right) / 2,\n        y: flyoutCenter.y + (flyoutPadding.top - flyoutPadding.bottom) / 2,\n        verticalAnchor: "middle",\n        angle: style.angle\n      });\n    }\n  }, {\n    key: "getPointerOrientation",\n    value: function getPointerOrientation(point, center, flyoutDimensions) {\n      var edges = {\n        bottom: center.y + flyoutDimensions.height / 2,\n        top: center.y - flyoutDimensions.height / 2,\n        left: center.x - flyoutDimensions.width / 2,\n        right: center.x + flyoutDimensions.width / 2\n      };\n      var gaps = [{\n        side: "top",\n        val: edges.top > point.y ? edges.top - point.y : -1\n      }, {\n        side: "bottom",\n        val: edges.bottom < point.y ? point.y - edges.bottom : -1\n      }, {\n        side: "right",\n        val: edges.right < point.x ? point.x - edges.right : -1\n      }, {\n        side: "left",\n        val: edges.left > point.x ? edges.left - point.x : -1\n      }];\n      return orderBy_default()(gaps, "val", "desc")[0].side;\n    }\n  }, {\n    key: "getFlyoutProps",\n    value: function getFlyoutProps(props, calculatedValues) {\n      var flyoutDimensions = calculatedValues.flyoutDimensions,\n          flyoutStyle = calculatedValues.flyoutStyle,\n          flyoutCenter = calculatedValues.flyoutCenter;\n      var x = props.x,\n          y = props.y,\n          dx = props.dx,\n          dy = props.dy,\n          datum = props.datum,\n          activePoints = props.activePoints,\n          index = props.index,\n          pointerLength = props.pointerLength,\n          pointerWidth = props.pointerWidth,\n          cornerRadius = props.cornerRadius,\n          events = props.events,\n          flyoutComponent = props.flyoutComponent;\n      var pointerOrientation = helpers/* evaluateProp */.xs(props.pointerOrientation, props);\n      return defaults_default()({}, flyoutComponent.props, {\n        x: x,\n        y: y,\n        dx: dx,\n        dy: dy,\n        datum: datum,\n        activePoints: activePoints,\n        index: index,\n        pointerLength: pointerLength,\n        pointerWidth: pointerWidth,\n        cornerRadius: cornerRadius,\n        events: events,\n        orientation: pointerOrientation || this.getPointerOrientation({\n          x: x,\n          y: y\n        }, flyoutCenter, flyoutDimensions),\n        key: "".concat(this.id, "-tooltip-").concat(index),\n        width: flyoutDimensions.width,\n        height: flyoutDimensions.height,\n        style: flyoutStyle,\n        center: flyoutCenter\n      });\n    } // Overridden in victory-core-native\n\n  }, {\n    key: "renderTooltip",\n    value: function renderTooltip(props) {\n      var active = helpers/* evaluateProp */.xs(props.active, props);\n      var renderInPortal = props.renderInPortal;\n\n      if (!active) {\n        return renderInPortal ? /*#__PURE__*/react.createElement(victory_portal/* VictoryPortal */.V, null, null) : null;\n      }\n\n      var evaluatedProps = this.getEvaluatedProps(props);\n      var flyoutComponent = evaluatedProps.flyoutComponent,\n          labelComponent = evaluatedProps.labelComponent,\n          groupComponent = evaluatedProps.groupComponent;\n      var calculatedValues = this.getCalculatedValues(evaluatedProps);\n      var children = [/*#__PURE__*/react.cloneElement(flyoutComponent, this.getFlyoutProps(evaluatedProps, calculatedValues)), /*#__PURE__*/react.cloneElement(labelComponent, this.getLabelProps(evaluatedProps, calculatedValues))];\n      var tooltip = /*#__PURE__*/react.cloneElement(groupComponent, {\n        role: "presentation",\n        transform: calculatedValues.transform\n      }, children);\n      return renderInPortal ? /*#__PURE__*/react.createElement(victory_portal/* VictoryPortal */.V, null, tooltip) : tooltip;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var props = helpers/* modifyProps */.TY(this.props, fallbackProps, "tooltip");\n      return this.renderTooltip(props);\n    }\n  }]);\n\n  return VictoryTooltip;\n}(react.Component);\n\nVictoryTooltip.displayName = "VictoryTooltip";\nVictoryTooltip.role = "tooltip";\nVictoryTooltip.propTypes = {\n  activateData: (prop_types_default()).bool,\n  active: prop_types_default().oneOfType([(prop_types_default()).bool, (prop_types_default()).func]),\n  activePoints: (prop_types_default()).array,\n  angle: (prop_types_default()).number,\n  center: prop_types_default().shape({\n    x: victory_util_prop_types/* nonNegative */.A7,\n    y: victory_util_prop_types/* nonNegative */.A7\n  }),\n  centerOffset: prop_types_default().shape({\n    x: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).func]),\n    y: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).func])\n  }),\n  constrainToVisibleArea: (prop_types_default()).bool,\n  cornerRadius: prop_types_default().oneOfType([victory_util_prop_types/* nonNegative */.A7, (prop_types_default()).func]),\n  data: (prop_types_default()).array,\n  datum: (prop_types_default()).object,\n  dx: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).func]),\n  dy: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).func]),\n  events: (prop_types_default()).object,\n  flyoutComponent: (prop_types_default()).element,\n  flyoutHeight: prop_types_default().oneOfType([victory_util_prop_types/* nonNegative */.A7, (prop_types_default()).func]),\n  flyoutPadding: prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).number, prop_types_default().shape({\n    top: (prop_types_default()).number,\n    bottom: (prop_types_default()).number,\n    left: (prop_types_default()).number,\n    right: (prop_types_default()).number\n  })]),\n  flyoutStyle: (prop_types_default()).object,\n  flyoutWidth: prop_types_default().oneOfType([victory_util_prop_types/* nonNegative */.A7, (prop_types_default()).func]),\n  groupComponent: (prop_types_default()).element,\n  height: (prop_types_default()).number,\n  horizontal: (prop_types_default()).bool,\n  id: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  index: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  labelComponent: (prop_types_default()).element,\n  orientation: prop_types_default().oneOfType([prop_types_default().oneOf(["top", "bottom", "left", "right"]), (prop_types_default()).func]),\n  pointerLength: prop_types_default().oneOfType([victory_util_prop_types/* nonNegative */.A7, (prop_types_default()).func]),\n  pointerOrientation: prop_types_default().oneOfType([prop_types_default().oneOf(["top", "bottom", "left", "right"]), (prop_types_default()).func]),\n  pointerWidth: prop_types_default().oneOfType([victory_util_prop_types/* nonNegative */.A7, (prop_types_default()).func]),\n  polar: (prop_types_default()).bool,\n  renderInPortal: (prop_types_default()).bool,\n  scale: prop_types_default().shape({\n    x: victory_util_prop_types/* scale */.bA,\n    y: victory_util_prop_types/* scale */.bA\n  }),\n  style: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).array]),\n  text: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number, (prop_types_default()).func, (prop_types_default()).array]),\n  theme: (prop_types_default()).object,\n  width: (prop_types_default()).number,\n  x: (prop_types_default()).number,\n  y: (prop_types_default()).number\n};\nVictoryTooltip.defaultProps = {\n  active: false,\n  renderInPortal: true,\n  labelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null),\n  flyoutComponent: /*#__PURE__*/react.createElement(flyout, null),\n  groupComponent: /*#__PURE__*/react.createElement("g", null)\n};\n\nVictoryTooltip.defaultEvents = function (props) {\n  var activate = props.activateData ? [{\n    target: "labels",\n    mutation: function () {\n      return {\n        active: true\n      };\n    }\n  }, {\n    target: "data",\n    mutation: function () {\n      return {\n        active: true\n      };\n    }\n  }] : [{\n    target: "labels",\n    mutation: function () {\n      return {\n        active: true\n      };\n    }\n  }];\n  var deactivate = props.activateData ? [{\n    target: "labels",\n    mutation: function () {\n      return {\n        active: undefined\n      };\n    }\n  }, {\n    target: "data",\n    mutation: function () {\n      return {\n        active: undefined\n      };\n    }\n  }] : [{\n    target: "labels",\n    mutation: function () {\n      return {\n        active: undefined\n      };\n    }\n  }];\n  return [{\n    target: "data",\n    eventHandlers: {\n      onMouseOver: function () {\n        return activate;\n      },\n      onFocus: function () {\n        return activate;\n      },\n      onTouchStart: function () {\n        return activate;\n      },\n      onMouseOut: function () {\n        return deactivate;\n      },\n      onBlur: function () {\n        return deactivate;\n      },\n      onTouchEnd: function () {\n        return deactivate;\n      }\n    }\n  }];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBYztBQUN2QixrQkFBa0IsMkJBQWM7QUFDaEMsU0FBUywwQkFBZTtBQUN4QixPQUFPLHFDQUFxQjtBQUM1QixPQUFPLHFDQUFxQjtBQUM1QixHQUFHO0FBQ0gsU0FBUyw4QkFBbUIsRUFBRSw2QkFBZ0IsRUFBRSw0QkFBZTtBQUMvRCxRQUFRLDhCQUFtQixFQUFFLDZCQUFnQixFQUFFLDZCQUFnQixFQUFFLDJCQUFjLEVBQUUsNEJBQWU7QUFDaEcsU0FBUyw2QkFBZ0I7QUFDekIsU0FBUyw2QkFBZ0I7QUFDekIsS0FBSyw2QkFBZ0I7QUFDckIsS0FBSyw2QkFBZ0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CLENBQUMsaUNBQVk7QUFDL0QsZ0NBQWdDLG1CQUFtQixDQUFDLE1BQU07QUFDMUQsK0JBQStCLG1CQUFtQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvdmljdG9yeS10b29sdGlwL2VzL2ZseW91dC5qcz85NDZiIiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LXRvb2x0aXAvZXMvdmljdG9yeS10b29sdGlwLmpzPzE1ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3NpZ24gZnJvbSBcImxvZGFzaC9hc3NpZ25cIjtcbmltcG9ydCBfaXNQbGFpbk9iamVjdCBmcm9tIFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVcIjogWy0xLCAwLCAxLCAyXSB9XSovXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBIZWxwZXJzLCBDb21tb25Qcm9wcywgUGF0aCwgVXNlclByb3BzIH0gZnJvbSBcInZpY3RvcnktY29yZVwiO1xuXG52YXIgZ2V0VmVydGljYWxQYXRoID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciBwb2ludGVyV2lkdGggPSBwcm9wcy5wb2ludGVyV2lkdGgsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBwcm9wcy5jb3JuZXJSYWRpdXMsXG4gICAgICBvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgIGNlbnRlciA9IHByb3BzLmNlbnRlcjtcbiAgdmFyIHNpZ24gPSBvcmllbnRhdGlvbiA9PT0gXCJib3R0b21cIiA/IDEgOiAtMTtcbiAgdmFyIHggPSBwcm9wcy54ICsgKHByb3BzLmR4IHx8IDApO1xuICB2YXIgeSA9IHByb3BzLnkgKyAocHJvcHMuZHkgfHwgMCk7XG4gIHZhciBjZW50ZXJYID0gX2lzUGxhaW5PYmplY3QoY2VudGVyKSAmJiBjZW50ZXIueDtcbiAgdmFyIGNlbnRlclkgPSBfaXNQbGFpbk9iamVjdChjZW50ZXIpICYmIGNlbnRlci55O1xuICB2YXIgcG9pbnRlckVkZ2UgPSBjZW50ZXJZICsgc2lnbiAqIChoZWlnaHQgLyAyKTtcbiAgdmFyIG9wcG9zaXRlRWRnZSA9IGNlbnRlclkgLSBzaWduICogKGhlaWdodCAvIDIpO1xuICB2YXIgcmlnaHRFZGdlID0gY2VudGVyWCArIHdpZHRoIC8gMjtcbiAgdmFyIGxlZnRFZGdlID0gY2VudGVyWCAtIHdpZHRoIC8gMjtcbiAgdmFyIHBvaW50ZXJMZW5ndGggPSBzaWduICogKHkgLSBwb2ludGVyRWRnZSkgPCAwID8gMCA6IHByb3BzLnBvaW50ZXJMZW5ndGg7XG4gIHZhciBkaXJlY3Rpb24gPSBvcmllbnRhdGlvbiA9PT0gXCJib3R0b21cIiA/IFwiMCAwIDBcIiA6IFwiMCAwIDFcIjtcbiAgdmFyIGFyYyA9IFwiXCIuY29uY2F0KGNvcm5lclJhZGl1cywgXCIgXCIpLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiIFwiKS5jb25jYXQoZGlyZWN0aW9uKTtcbiAgcmV0dXJuIFwiTSBcIi5jb25jYXQoY2VudGVyWCAtIHBvaW50ZXJXaWR0aCAvIDIsIFwiLCBcIikuY29uY2F0KHBvaW50ZXJFZGdlLCBcIlxcbiAgICBMIFwiKS5jb25jYXQocG9pbnRlckxlbmd0aCA/IHggOiBjZW50ZXJYICsgcG9pbnRlcldpZHRoIC8gMiwgXCIsIFwiKS5jb25jYXQocG9pbnRlckxlbmd0aCA/IHkgOiBwb2ludGVyRWRnZSwgXCJcXG4gICAgTCBcIikuY29uY2F0KGNlbnRlclggKyBwb2ludGVyV2lkdGggLyAyLCBcIiwgXCIpLmNvbmNhdChwb2ludGVyRWRnZSwgXCJcXG4gICAgTCBcIikuY29uY2F0KHJpZ2h0RWRnZSAtIGNvcm5lclJhZGl1cywgXCIsIFwiKS5jb25jYXQocG9pbnRlckVkZ2UsIFwiXFxuICAgIEEgXCIpLmNvbmNhdChhcmMsIFwiIFwiKS5jb25jYXQocmlnaHRFZGdlLCBcIiwgXCIpLmNvbmNhdChwb2ludGVyRWRnZSAtIHNpZ24gKiBjb3JuZXJSYWRpdXMsIFwiXFxuICAgIEwgXCIpLmNvbmNhdChyaWdodEVkZ2UsIFwiLCBcIikuY29uY2F0KG9wcG9zaXRlRWRnZSArIHNpZ24gKiBjb3JuZXJSYWRpdXMsIFwiXFxuICAgIEEgXCIpLmNvbmNhdChhcmMsIFwiIFwiKS5jb25jYXQocmlnaHRFZGdlIC0gY29ybmVyUmFkaXVzLCBcIiwgXCIpLmNvbmNhdChvcHBvc2l0ZUVkZ2UsIFwiXFxuICAgIEwgXCIpLmNvbmNhdChsZWZ0RWRnZSArIGNvcm5lclJhZGl1cywgXCIsIFwiKS5jb25jYXQob3Bwb3NpdGVFZGdlLCBcIlxcbiAgICBBIFwiKS5jb25jYXQoYXJjLCBcIiBcIikuY29uY2F0KGxlZnRFZGdlLCBcIiwgXCIpLmNvbmNhdChvcHBvc2l0ZUVkZ2UgKyBzaWduICogY29ybmVyUmFkaXVzLCBcIlxcbiAgICBMIFwiKS5jb25jYXQobGVmdEVkZ2UsIFwiLCBcIikuY29uY2F0KHBvaW50ZXJFZGdlIC0gc2lnbiAqIGNvcm5lclJhZGl1cywgXCJcXG4gICAgQSBcIikuY29uY2F0KGFyYywgXCIgXCIpLmNvbmNhdChsZWZ0RWRnZSArIGNvcm5lclJhZGl1cywgXCIsIFwiKS5jb25jYXQocG9pbnRlckVkZ2UsIFwiXFxuICAgIHpcIik7XG59O1xuXG52YXIgZ2V0SG9yaXpvbnRhbFBhdGggPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIHBvaW50ZXJXaWR0aCA9IHByb3BzLnBvaW50ZXJXaWR0aCxcbiAgICAgIGNvcm5lclJhZGl1cyA9IHByb3BzLmNvcm5lclJhZGl1cyxcbiAgICAgIG9yaWVudGF0aW9uID0gcHJvcHMub3JpZW50YXRpb24sXG4gICAgICB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgY2VudGVyID0gcHJvcHMuY2VudGVyO1xuICB2YXIgc2lnbiA9IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiA/IDEgOiAtMTtcbiAgdmFyIHggPSBwcm9wcy54ICsgKHByb3BzLmR4IHx8IDApO1xuICB2YXIgeSA9IHByb3BzLnkgKyAocHJvcHMuZHkgfHwgMCk7XG4gIHZhciBjZW50ZXJYID0gX2lzUGxhaW5PYmplY3QoY2VudGVyKSAmJiBjZW50ZXIueDtcbiAgdmFyIGNlbnRlclkgPSBfaXNQbGFpbk9iamVjdChjZW50ZXIpICYmIGNlbnRlci55O1xuICB2YXIgcG9pbnRlckVkZ2UgPSBjZW50ZXJYIC0gc2lnbiAqICh3aWR0aCAvIDIpO1xuICB2YXIgb3Bwb3NpdGVFZGdlID0gY2VudGVyWCArIHNpZ24gKiAod2lkdGggLyAyKTtcbiAgdmFyIGJvdHRvbUVkZ2UgPSBjZW50ZXJZICsgaGVpZ2h0IC8gMjtcbiAgdmFyIHRvcEVkZ2UgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMjtcbiAgdmFyIHBvaW50ZXJMZW5ndGggPSBzaWduICogKHggLSBwb2ludGVyRWRnZSkgPiAwID8gMCA6IHByb3BzLnBvaW50ZXJMZW5ndGg7XG4gIHZhciBkaXJlY3Rpb24gPSBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgPyBcIjAgMCAwXCIgOiBcIjAgMCAxXCI7XG4gIHZhciBhcmMgPSBcIlwiLmNvbmNhdChjb3JuZXJSYWRpdXMsIFwiIFwiKS5jb25jYXQoY29ybmVyUmFkaXVzLCBcIiBcIikuY29uY2F0KGRpcmVjdGlvbik7XG4gIHJldHVybiBcIk0gXCIuY29uY2F0KHBvaW50ZXJFZGdlLCBcIiwgXCIpLmNvbmNhdChjZW50ZXJZIC0gcG9pbnRlcldpZHRoIC8gMiwgXCJcXG4gICAgTCBcIikuY29uY2F0KHBvaW50ZXJMZW5ndGggPyB4IDogcG9pbnRlckVkZ2UsIFwiLCBcIikuY29uY2F0KHBvaW50ZXJMZW5ndGggPyB5IDogY2VudGVyWSArIHBvaW50ZXJXaWR0aCAvIDIsIFwiXFxuICAgIEwgXCIpLmNvbmNhdChwb2ludGVyRWRnZSwgXCIsIFwiKS5jb25jYXQoY2VudGVyWSArIHBvaW50ZXJXaWR0aCAvIDIsIFwiXFxuICAgIEwgXCIpLmNvbmNhdChwb2ludGVyRWRnZSwgXCIsIFwiKS5jb25jYXQoYm90dG9tRWRnZSAtIGNvcm5lclJhZGl1cywgXCJcXG4gICAgQSBcIikuY29uY2F0KGFyYywgXCIgXCIpLmNvbmNhdChwb2ludGVyRWRnZSArIHNpZ24gKiBjb3JuZXJSYWRpdXMsIFwiLCBcIikuY29uY2F0KGJvdHRvbUVkZ2UsIFwiXFxuICAgIEwgXCIpLmNvbmNhdChvcHBvc2l0ZUVkZ2UgLSBzaWduICogY29ybmVyUmFkaXVzLCBcIiwgXCIpLmNvbmNhdChib3R0b21FZGdlLCBcIlxcbiAgICBBIFwiKS5jb25jYXQoYXJjLCBcIiBcIikuY29uY2F0KG9wcG9zaXRlRWRnZSwgXCIsIFwiKS5jb25jYXQoYm90dG9tRWRnZSAtIGNvcm5lclJhZGl1cywgXCJcXG4gICAgTCBcIikuY29uY2F0KG9wcG9zaXRlRWRnZSwgXCIsIFwiKS5jb25jYXQodG9wRWRnZSArIGNvcm5lclJhZGl1cywgXCJcXG4gICAgQSBcIikuY29uY2F0KGFyYywgXCIgXCIpLmNvbmNhdChvcHBvc2l0ZUVkZ2UgLSBzaWduICogY29ybmVyUmFkaXVzLCBcIiwgXCIpLmNvbmNhdCh0b3BFZGdlLCBcIlxcbiAgICBMIFwiKS5jb25jYXQocG9pbnRlckVkZ2UgKyBzaWduICogY29ybmVyUmFkaXVzLCBcIiwgXCIpLmNvbmNhdCh0b3BFZGdlLCBcIlxcbiAgICBBIFwiKS5jb25jYXQoYXJjLCBcIiBcIikuY29uY2F0KHBvaW50ZXJFZGdlLCBcIiwgXCIpLmNvbmNhdCh0b3BFZGdlICsgY29ybmVyUmFkaXVzLCBcIlxcbiAgICB6XCIpO1xufTtcblxudmFyIGdldEZseW91dFBhdGggPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gcHJvcHMub3JpZW50YXRpb24gfHwgXCJ0b3BcIjtcbiAgcmV0dXJuIG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gZ2V0SG9yaXpvbnRhbFBhdGgocHJvcHMpIDogZ2V0VmVydGljYWxQYXRoKHByb3BzKTtcbn07XG5cbnZhciBldmFsdWF0ZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIC8qKlxuICAgKiBQb3RlbnRpYWwgZXZhbHVhdGVkIHByb3BzIGFyZTpcbiAgICogYGlkYFxuICAgKiBgc3R5bGVgXG4gICAqL1xuICB2YXIgaWQgPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5pZCwgcHJvcHMpO1xuICB2YXIgc3R5bGUgPSBIZWxwZXJzLmV2YWx1YXRlU3R5bGUocHJvcHMuc3R5bGUsIHByb3BzKTtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgaWQ6IGlkLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9KTtcbn07XG5cbnZhciBGbHlvdXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcHJvcHMgPSBldmFsdWF0ZVByb3BzKHByb3BzKTtcbiAgdmFyIHVzZXJQcm9wcyA9IFVzZXJQcm9wcy5nZXRTYWZlVXNlclByb3BzKHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJvcHMucGF0aENvbXBvbmVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzLmV2ZW50cyksIHVzZXJQcm9wcyksIHt9LCB7XG4gICAgc3R5bGU6IHByb3BzLnN0eWxlLFxuICAgIGQ6IGdldEZseW91dFBhdGgocHJvcHMpLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgIHNoYXBlUmVuZGVyaW5nOiBwcm9wcy5zaGFwZVJlbmRlcmluZyxcbiAgICByb2xlOiBwcm9wcy5yb2xlLFxuICAgIHRyYW5zZm9ybTogcHJvcHMudHJhbnNmb3JtLFxuICAgIGNsaXBQYXRoOiBwcm9wcy5jbGlwUGF0aFxuICB9KSk7XG59O1xuXG5GbHlvdXQucHJvcFR5cGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBDb21tb25Qcm9wcy5wcmltaXRpdmVQcm9wcyksIHt9LCB7XG4gIGNlbnRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHk6IFByb3BUeXBlcy5udW1iZXJcbiAgfSksXG4gIGNvcm5lclJhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgZGF0dW06IFByb3BUeXBlcy5vYmplY3QsXG4gIGR4OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkeTogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSksXG4gIHBhdGhDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBwb2ludGVyTGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBwb2ludGVyV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICB5OiBQcm9wVHlwZXMubnVtYmVyXG59KTtcbkZseW91dC5kZWZhdWx0UHJvcHMgPSB7XG4gIHBhdGhDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhdGgsIG51bGwpLFxuICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICBzaGFwZVJlbmRlcmluZzogXCJhdXRvXCJcbn07XG5leHBvcnQgZGVmYXVsdCBGbHlvdXQ7IiwiaW1wb3J0IF9vcmRlckJ5IGZyb20gXCJsb2Rhc2gvb3JkZXJCeVwiO1xuaW1wb3J0IF9pc1BsYWluT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiO1xuaW1wb3J0IF91bmlxdWVJZCBmcm9tIFwibG9kYXNoL3VuaXF1ZUlkXCI7XG5pbXBvcnQgX2RlZmF1bHRzIGZyb20gXCJsb2Rhc2gvZGVmYXVsdHNcIjtcbmltcG9ydCBfYXNzaWduIGZyb20gXCJsb2Rhc2gvYXNzaWduXCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgUHJvcFR5cGVzIGFzIEN1c3RvbVByb3BUeXBlcywgVGV4dFNpemUsIEhlbHBlcnMsIExhYmVsSGVscGVycywgVmljdG9yeUxhYmVsLCBWaWN0b3J5VGhlbWUsIFZpY3RvcnlQb3J0YWwgfSBmcm9tIFwidmljdG9yeS1jb3JlXCI7XG5pbXBvcnQgRmx5b3V0IGZyb20gXCIuL2ZseW91dFwiO1xudmFyIGZhbGxiYWNrUHJvcHMgPSB7XG4gIGNvcm5lclJhZGl1czogNSxcbiAgcG9pbnRlckxlbmd0aDogMTAsXG4gIHBvaW50ZXJXaWR0aDogMTBcbn07XG5cbnZhciBWaWN0b3J5VG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVmljdG9yeVRvb2x0aXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVmljdG9yeVRvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIFZpY3RvcnlUb29sdGlwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpY3RvcnlUb29sdGlwKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLmlkID0gcHJvcHMuaWQgPT09IHVuZGVmaW5lZCA/IF91bmlxdWVJZChcInRvb2x0aXAtXCIpIDogcHJvcHMuaWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZpY3RvcnlUb29sdGlwLCBbe1xuICAgIGtleTogXCJnZXREZWZhdWx0T3JpZW50YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdE9yaWVudGF0aW9uKHByb3BzKSB7XG4gICAgICB2YXIgZGF0dW0gPSBwcm9wcy5kYXR1bSxcbiAgICAgICAgICBob3Jpem9udGFsID0gcHJvcHMuaG9yaXpvbnRhbCxcbiAgICAgICAgICBwb2xhciA9IHByb3BzLnBvbGFyO1xuXG4gICAgICBpZiAoIXBvbGFyKSB7XG4gICAgICAgIHZhciBwb3NpdGl2ZSA9IGhvcml6b250YWwgPyBcInJpZ2h0XCIgOiBcInRvcFwiO1xuICAgICAgICB2YXIgbmVnYXRpdmUgPSBob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiO1xuICAgICAgICByZXR1cm4gZGF0dW0gJiYgZGF0dW0ueSA8IDAgPyBuZWdhdGl2ZSA6IHBvc2l0aXZlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRQb2xhck9yaWVudGF0aW9uKHByb3BzLCBkYXR1bSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvbGFyT3JpZW50YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9sYXJPcmllbnRhdGlvbihwcm9wcywgZGF0dW0pIHtcbiAgICAgIHZhciBkZWdyZWVzID0gTGFiZWxIZWxwZXJzLmdldERlZ3JlZXMocHJvcHMsIGRhdHVtKTtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSBwcm9wcy5sYWJlbFBsYWNlbWVudCB8fCBcInZlcnRpY2FsXCI7XG5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09IFwiIHZlcnRpY2FsXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVydGljYWxPcmllbnRhdGlvbnMoZGVncmVlcyk7XG4gICAgICB9IGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gXCJwYXJhbGxlbFwiKSB7XG4gICAgICAgIHJldHVybiBkZWdyZWVzIDwgOTAgfHwgZGVncmVlcyA+IDI3MCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVncmVlcyA+IDE4MCA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWZXJ0aWNhbE9yaWVudGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWZXJ0aWNhbE9yaWVudGF0aW9ucyhkZWdyZWVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgaWYgKGRlZ3JlZXMgPCA0NSB8fCBkZWdyZWVzID4gMzE1KSB7XG4gICAgICAgIHJldHVybiBcInJpZ2h0XCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICB9IGVsc2UgaWYgKGRlZ3JlZXMgPj0gNDUgJiYgZGVncmVlcyA8PSAxMzUpIHtcbiAgICAgICAgcmV0dXJuIFwidG9wXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICB9IGVsc2UgaWYgKGRlZ3JlZXMgPiAxMzUgJiYgZGVncmVlcyA8IDIyNSkge1xuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGVzKHByb3BzKSB7XG4gICAgICB2YXIgdGhlbWUgPSBwcm9wcy50aGVtZSB8fCBWaWN0b3J5VGhlbWUuZ3JheXNjYWxlO1xuICAgICAgdmFyIGRlZmF1bHRMYWJlbFN0eWxlcyA9IHRoZW1lICYmIHRoZW1lLnRvb2x0aXAgJiYgdGhlbWUudG9vbHRpcC5zdHlsZSA/IHRoZW1lLnRvb2x0aXAuc3R5bGUgOiB7fTtcbiAgICAgIHZhciBiYXNlTGFiZWxTdHlsZSA9IEFycmF5LmlzQXJyYXkocHJvcHMuc3R5bGUpID8gcHJvcHMuc3R5bGUubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHMoe30sIHMsIGRlZmF1bHRMYWJlbFN0eWxlcyk7XG4gICAgICB9KSA6IF9kZWZhdWx0cyh7fSwgcHJvcHMuc3R5bGUsIGRlZmF1bHRMYWJlbFN0eWxlcyk7XG4gICAgICB2YXIgZGVmYXVsdEZseW91dFN0eWxlcyA9IHRoZW1lICYmIHRoZW1lLnRvb2x0aXAgJiYgdGhlbWUudG9vbHRpcC5mbHlvdXRTdHlsZSA/IHRoZW1lLnRvb2x0aXAuZmx5b3V0U3R5bGUgOiB7fTtcbiAgICAgIHZhciBiYXNlRmx5b3V0U3R5bGUgPSBwcm9wcy5mbHlvdXRTdHlsZSA/IF9kZWZhdWx0cyh7fSwgcHJvcHMuZmx5b3V0U3R5bGUsIGRlZmF1bHRGbHlvdXRTdHlsZXMpIDogZGVmYXVsdEZseW91dFN0eWxlcztcbiAgICAgIHZhciBzdHlsZSA9IEFycmF5LmlzQXJyYXkoYmFzZUxhYmVsU3R5bGUpID8gYmFzZUxhYmVsU3R5bGUubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBIZWxwZXJzLmV2YWx1YXRlU3R5bGUocywgcHJvcHMpO1xuICAgICAgfSkgOiBIZWxwZXJzLmV2YWx1YXRlU3R5bGUoYmFzZUxhYmVsU3R5bGUsIHByb3BzKTtcbiAgICAgIHZhciBmbHlvdXRTdHlsZSA9IEhlbHBlcnMuZXZhbHVhdGVTdHlsZShiYXNlRmx5b3V0U3R5bGUsIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBmbHlvdXRTdHlsZTogZmx5b3V0U3R5bGVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEV2YWx1YXRlZFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV2YWx1YXRlZFByb3BzKHByb3BzKSB7XG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gcHJvcHMuY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNlbnRlck9mZnNldCA9IHByb3BzLmNlbnRlck9mZnNldCxcbiAgICAgICAgICBkeCA9IHByb3BzLmR4LFxuICAgICAgICAgIGR5ID0gcHJvcHMuZHk7XG4gICAgICB2YXIgYWN0aXZlID0gSGVscGVycy5ldmFsdWF0ZVByb3AocHJvcHMuYWN0aXZlLCBwcm9wcyk7XG4gICAgICB2YXIgdGV4dCA9IEhlbHBlcnMuZXZhbHVhdGVQcm9wKHByb3BzLnRleHQsIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIGFjdGl2ZTogYWN0aXZlXG4gICAgICB9KSk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRTdHlsZXMgPSB0aGlzLmdldFN0eWxlcyhfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfSkpLFxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkZ2V0U3R5bGVzLnN0eWxlLFxuICAgICAgICAgIGZseW91dFN0eWxlID0gX3RoaXMkZ2V0U3R5bGVzLmZseW91dFN0eWxlO1xuXG4gICAgICB2YXIgb3JpZW50YXRpb24gPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5vcmllbnRhdGlvbiwgX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZmx5b3V0U3R5bGU6IGZseW91dFN0eWxlXG4gICAgICB9KSkgfHwgdGhpcy5nZXREZWZhdWx0T3JpZW50YXRpb24ocHJvcHMpO1xuICAgICAgdmFyIHBhZGRpbmcgPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5mbHlvdXRQYWRkaW5nLCBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBmbHlvdXRTdHlsZTogZmx5b3V0U3R5bGUsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfSkpIHx8IHRoaXMuZ2V0TGFiZWxQYWRkaW5nKHN0eWxlKTtcbiAgICAgIHZhciBmbHlvdXRQYWRkaW5nID0gSGVscGVycy5nZXRQYWRkaW5nKHtcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnRlcldpZHRoID0gSGVscGVycy5ldmFsdWF0ZVByb3AocHJvcHMucG9pbnRlcldpZHRoLCBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBmbHlvdXRTdHlsZTogZmx5b3V0U3R5bGUsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfSkpO1xuICAgICAgdmFyIHBvaW50ZXJMZW5ndGggPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5wb2ludGVyTGVuZ3RoLCBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBmbHlvdXRTdHlsZTogZmx5b3V0U3R5bGUsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfSkpO1xuICAgICAgdmFyIGxhYmVsU2l6ZSA9IFRleHRTaXplLmFwcHJveGltYXRlVGV4dFNpemUodGV4dCwgc3R5bGUpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0RGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucyhfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGZseW91dFN0eWxlOiBmbHlvdXRTdHlsZSxcbiAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgZmx5b3V0UGFkZGluZzogZmx5b3V0UGFkZGluZyxcbiAgICAgICAgcG9pbnRlcldpZHRoOiBwb2ludGVyV2lkdGgsXG4gICAgICAgIHBvaW50ZXJMZW5ndGg6IHBvaW50ZXJMZW5ndGhcbiAgICAgIH0pLCBsYWJlbFNpemUpLFxuICAgICAgICAgIGZseW91dEhlaWdodCA9IF90aGlzJGdldERpbWVuc2lvbnMuZmx5b3V0SGVpZ2h0LFxuICAgICAgICAgIGZseW91dFdpZHRoID0gX3RoaXMkZ2V0RGltZW5zaW9ucy5mbHlvdXRXaWR0aDtcblxuICAgICAgdmFyIGV2YWx1YXRlZFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZmx5b3V0U3R5bGU6IGZseW91dFN0eWxlLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIGZseW91dEhlaWdodDogZmx5b3V0SGVpZ2h0LFxuICAgICAgICBmbHlvdXRXaWR0aDogZmx5b3V0V2lkdGgsXG4gICAgICAgIGZseW91dFBhZGRpbmc6IGZseW91dFBhZGRpbmcsXG4gICAgICAgIHBvaW50ZXJXaWR0aDogcG9pbnRlcldpZHRoLFxuICAgICAgICBwb2ludGVyTGVuZ3RoOiBwb2ludGVyTGVuZ3RoXG4gICAgICB9KTtcblxuICAgICAgdmFyIG9mZnNldFggPSBfaXNQbGFpbk9iamVjdChjZW50ZXJPZmZzZXQpICYmIGNlbnRlck9mZnNldC54ICE9PSB1bmRlZmluZWQgPyBIZWxwZXJzLmV2YWx1YXRlUHJvcChjZW50ZXJPZmZzZXQueCwgZXZhbHVhdGVkUHJvcHMpIDogMDtcbiAgICAgIHZhciBvZmZzZXRZID0gX2lzUGxhaW5PYmplY3QoY2VudGVyT2Zmc2V0KSAmJiBjZW50ZXJPZmZzZXQueSAhPT0gdW5kZWZpbmVkID8gSGVscGVycy5ldmFsdWF0ZVByb3AoY2VudGVyT2Zmc2V0LnksIGV2YWx1YXRlZFByb3BzKSA6IDA7XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgZXZhbHVhdGVkUHJvcHMsIHtcbiAgICAgICAgY2VudGVyT2Zmc2V0OiB7XG4gICAgICAgICAgeDogb2Zmc2V0WCxcbiAgICAgICAgICB5OiBvZmZzZXRZXG4gICAgICAgIH0sXG4gICAgICAgIGR4OiBkeCAhPT0gdW5kZWZpbmVkID8gSGVscGVycy5ldmFsdWF0ZVByb3AoZHgsIGV2YWx1YXRlZFByb3BzKSA6IDAsXG4gICAgICAgIGR5OiBkeSAhPT0gdW5kZWZpbmVkID8gSGVscGVycy5ldmFsdWF0ZVByb3AoZHksIGV2YWx1YXRlZFByb3BzKSA6IDAsXG4gICAgICAgIGNvcm5lclJhZGl1czogSGVscGVycy5ldmFsdWF0ZVByb3AoY29ybmVyUmFkaXVzLCBldmFsdWF0ZWRQcm9wcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxjdWxhdGVkVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWRWYWx1ZXMocHJvcHMpIHtcbiAgICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgICAgIHRleHQgPSBwcm9wcy50ZXh0LFxuICAgICAgICAgIGZseW91dFN0eWxlID0gcHJvcHMuZmx5b3V0U3R5bGUsXG4gICAgICAgICAgZmx5b3V0SGVpZ2h0ID0gcHJvcHMuZmx5b3V0SGVpZ2h0LFxuICAgICAgICAgIGZseW91dFdpZHRoID0gcHJvcHMuZmx5b3V0V2lkdGg7XG4gICAgICB2YXIgbGFiZWxTaXplID0gVGV4dFNpemUuYXBwcm94aW1hdGVUZXh0U2l6ZSh0ZXh0LCBzdHlsZSk7XG4gICAgICB2YXIgZmx5b3V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgaGVpZ2h0OiBmbHlvdXRIZWlnaHQsXG4gICAgICAgIHdpZHRoOiBmbHlvdXRXaWR0aFxuICAgICAgfTtcbiAgICAgIHZhciBmbHlvdXRDZW50ZXIgPSB0aGlzLmdldEZseW91dENlbnRlcihwcm9wcywgZmx5b3V0RGltZW5zaW9ucyk7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0ocHJvcHMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBmbHlvdXRTdHlsZTogZmx5b3V0U3R5bGUsXG4gICAgICAgIGxhYmVsU2l6ZTogbGFiZWxTaXplLFxuICAgICAgICBmbHlvdXREaW1lbnNpb25zOiBmbHlvdXREaW1lbnNpb25zLFxuICAgICAgICBmbHlvdXRDZW50ZXI6IGZseW91dENlbnRlcixcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0ocHJvcHMpIHtcbiAgICAgIHZhciB4ID0gcHJvcHMueCxcbiAgICAgICAgICB5ID0gcHJvcHMueSxcbiAgICAgICAgICBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICAgICAgdmFyIGxhYmVsU3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICAgIHZhciBhbmdsZSA9IGxhYmVsU3R5bGUuYW5nbGUgfHwgcHJvcHMuYW5nbGUgfHwgdGhpcy5nZXREZWZhdWx0QW5nbGUocHJvcHMpO1xuICAgICAgcmV0dXJuIGFuZ2xlID8gXCJyb3RhdGUoXCIuY29uY2F0KGFuZ2xlLCBcIiBcIikuY29uY2F0KHgsIFwiIFwiKS5jb25jYXQoeSwgXCIpXCIpIDogdW5kZWZpbmVkO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuICB9LCB7XG4gICAga2V5OiBcImdldERlZmF1bHRBbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0QW5nbGUocHJvcHMpIHtcbiAgICAgIHZhciBwb2xhciA9IHByb3BzLnBvbGFyLFxuICAgICAgICAgIGxhYmVsUGxhY2VtZW50ID0gcHJvcHMubGFiZWxQbGFjZW1lbnQsXG4gICAgICAgICAgb3JpZW50YXRpb24gPSBwcm9wcy5vcmllbnRhdGlvbixcbiAgICAgICAgICBkYXR1bSA9IHByb3BzLmRhdHVtO1xuXG4gICAgICBpZiAoIXBvbGFyIHx8ICFsYWJlbFBsYWNlbWVudCB8fCBsYWJlbFBsYWNlbWVudCA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVncmVlcyA9IExhYmVsSGVscGVycy5nZXREZWdyZWVzKHByb3BzLCBkYXR1bSk7XG4gICAgICB2YXIgc2lnbiA9IGRlZ3JlZXMgPiA5MCAmJiBkZWdyZWVzIDwgMTgwIHx8IGRlZ3JlZXMgPiAyNzAgPyAxIDogLTE7XG4gICAgICB2YXIgbGFiZWxSb3RhdGlvbiA9IGxhYmVsUGxhY2VtZW50ID09PSBcInBlcnBlbmRpY3VsYXJcIiA/IDAgOiA5MDtcbiAgICAgIHZhciBhbmdsZTtcblxuICAgICAgaWYgKGRlZ3JlZXMgPT09IDAgfHwgZGVncmVlcyA9PT0gMTgwKSB7XG4gICAgICAgIGFuZ2xlID0gb3JpZW50YXRpb24gPT09IFwidG9wXCIgJiYgZGVncmVlcyA9PT0gMTgwID8gMjcwIDogOTA7XG4gICAgICB9IGVsc2UgaWYgKGRlZ3JlZXMgPiAwICYmIGRlZ3JlZXMgPCAxODApIHtcbiAgICAgICAgYW5nbGUgPSA5MCAtIGRlZ3JlZXM7XG4gICAgICB9IGVsc2UgaWYgKGRlZ3JlZXMgPiAxODAgJiYgZGVncmVlcyA8IDM2MCkge1xuICAgICAgICBhbmdsZSA9IDI3MCAtIGRlZ3JlZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmdsZSArIHNpZ24gKiBsYWJlbFJvdGF0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25zdHJhaW5Ub29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN0cmFpblRvb2x0aXAoY2VudGVyLCBwcm9wcywgZGltZW5zaW9ucykge1xuICAgICAgdmFyIHggPSBjZW50ZXIueCxcbiAgICAgICAgICB5ID0gY2VudGVyLnk7XG4gICAgICB2YXIgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgdmFyIGV4dGVudCA9IHtcbiAgICAgICAgeDogWzAsIHByb3BzLndpZHRoXSxcbiAgICAgICAgeTogWzAsIHByb3BzLmhlaWdodF1cbiAgICAgIH07XG4gICAgICB2YXIgZmx5b3V0RXh0ZW50ID0ge1xuICAgICAgICB4OiBbeCAtIHdpZHRoIC8gMiwgeCArIHdpZHRoIC8gMl0sXG4gICAgICAgIHk6IFt5IC0gaGVpZ2h0IC8gMiwgeSArIGhlaWdodCAvIDJdXG4gICAgICB9O1xuICAgICAgdmFyIGFkanVzdG1lbnRzID0ge1xuICAgICAgICB4OiBbZmx5b3V0RXh0ZW50LnhbMF0gPCBleHRlbnQueFswXSA/IGV4dGVudC54WzBdIC0gZmx5b3V0RXh0ZW50LnhbMF0gOiAwLCBmbHlvdXRFeHRlbnQueFsxXSA+IGV4dGVudC54WzFdID8gZmx5b3V0RXh0ZW50LnhbMV0gLSBleHRlbnQueFsxXSA6IDBdLFxuICAgICAgICB5OiBbZmx5b3V0RXh0ZW50LnlbMF0gPCBleHRlbnQueVswXSA/IGV4dGVudC55WzBdIC0gZmx5b3V0RXh0ZW50LnlbMF0gOiAwLCBmbHlvdXRFeHRlbnQueVsxXSA+IGV4dGVudC55WzFdID8gZmx5b3V0RXh0ZW50LnlbMV0gLSBleHRlbnQueVsxXSA6IDBdXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZCh4ICsgYWRqdXN0bWVudHMueFswXSAtIGFkanVzdG1lbnRzLnhbMV0pLFxuICAgICAgICB5OiBNYXRoLnJvdW5kKHkgKyBhZGp1c3RtZW50cy55WzBdIC0gYWRqdXN0bWVudHMueVsxXSlcbiAgICAgIH07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rmx5b3V0Q2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZseW91dENlbnRlcihwcm9wcywgZGltZW5zaW9ucykge1xuICAgICAgdmFyIHggPSBwcm9wcy54LFxuICAgICAgICAgIHkgPSBwcm9wcy55LFxuICAgICAgICAgIGR4ID0gcHJvcHMuZHgsXG4gICAgICAgICAgZHkgPSBwcm9wcy5keSxcbiAgICAgICAgICBwb2ludGVyTGVuZ3RoID0gcHJvcHMucG9pbnRlckxlbmd0aCxcbiAgICAgICAgICBvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICAgIGNvbnN0cmFpblRvVmlzaWJsZUFyZWEgPSBwcm9wcy5jb25zdHJhaW5Ub1Zpc2libGVBcmVhLFxuICAgICAgICAgIGNlbnRlck9mZnNldCA9IHByb3BzLmNlbnRlck9mZnNldDtcbiAgICAgIHZhciBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICB2YXIgeFNpZ24gPSBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgPyAtMSA6IDE7XG4gICAgICB2YXIgeVNpZ24gPSBvcmllbnRhdGlvbiA9PT0gXCJib3R0b21cIiA/IC0xIDogMTtcbiAgICAgIHZhciBmbHlvdXRDZW50ZXIgPSB7XG4gICAgICAgIHg6IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8geCArIHhTaWduICogKHBvaW50ZXJMZW5ndGggKyB3aWR0aCAvIDIgKyB4U2lnbiAqIGR4KSA6IHggKyBkeCxcbiAgICAgICAgeTogb3JpZW50YXRpb24gPT09IFwidG9wXCIgfHwgb3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgPyB5IC0geVNpZ24gKiAocG9pbnRlckxlbmd0aCArIGhlaWdodCAvIDIgLSB5U2lnbiAqIGR5KSA6IHkgKyBkeVxuICAgICAgfTtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IF9pc1BsYWluT2JqZWN0KHByb3BzLmNlbnRlcikgJiYgcHJvcHMuY2VudGVyLnggIT09IHVuZGVmaW5lZCA/IHByb3BzLmNlbnRlci54IDogZmx5b3V0Q2VudGVyLngsXG4gICAgICAgIHk6IF9pc1BsYWluT2JqZWN0KHByb3BzLmNlbnRlcikgJiYgcHJvcHMuY2VudGVyLnkgIT09IHVuZGVmaW5lZCA/IHByb3BzLmNlbnRlci55IDogZmx5b3V0Q2VudGVyLnlcbiAgICAgIH07XG4gICAgICB2YXIgY2VudGVyV2l0aE9mZnNldCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyBjZW50ZXJPZmZzZXQueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBjZW50ZXJPZmZzZXQueVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjb25zdHJhaW5Ub1Zpc2libGVBcmVhID8gdGhpcy5jb25zdHJhaW5Ub29sdGlwKGNlbnRlcldpdGhPZmZzZXQsIHByb3BzLCBkaW1lbnNpb25zKSA6IGNlbnRlcldpdGhPZmZzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFBhZGRpbmcoc3R5bGUpIHtcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWRkaW5ncyA9IEFycmF5LmlzQXJyYXkoc3R5bGUpID8gc3R5bGUubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnBhZGRpbmc7XG4gICAgICB9KSA6IFtzdHlsZS5wYWRkaW5nXTtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkocGFkZGluZ3MpLmNvbmNhdChbMF0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKHByb3BzLCBsYWJlbFNpemUpIHtcbiAgICAgIHZhciBvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICAgIHBvaW50ZXJMZW5ndGggPSBwcm9wcy5wb2ludGVyTGVuZ3RoLFxuICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHByb3BzLnBvaW50ZXJXaWR0aCxcbiAgICAgICAgICBmbHlvdXRIZWlnaHQgPSBwcm9wcy5mbHlvdXRIZWlnaHQsXG4gICAgICAgICAgZmx5b3V0V2lkdGggPSBwcm9wcy5mbHlvdXRXaWR0aCxcbiAgICAgICAgICBmbHlvdXRQYWRkaW5nID0gcHJvcHMuZmx5b3V0UGFkZGluZztcbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5jb3JuZXJSYWRpdXMsIHByb3BzKTtcblxuICAgICAgdmFyIGdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQgPSBsYWJlbFNpemUuaGVpZ2h0ICsgZmx5b3V0UGFkZGluZy50b3AgKyBmbHlvdXRQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgdmFyIG1pbkhlaWdodCA9IG9yaWVudGF0aW9uID09PSBcInRvcFwiIHx8IG9yaWVudGF0aW9uID09PSBcImJvdHRvbVwiID8gMiAqIGNvcm5lclJhZGl1cyA6IDIgKiBjb3JuZXJSYWRpdXMgKyBwb2ludGVyV2lkdGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW5IZWlnaHQsIGNhbGN1bGF0ZWRIZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsY3VsYXRlZFdpZHRoID0gbGFiZWxTaXplLndpZHRoICsgZmx5b3V0UGFkZGluZy5sZWZ0ICsgZmx5b3V0UGFkZGluZy5yaWdodDtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gb3JpZW50YXRpb24gPT09IFwibGVmdFwiIHx8IG9yaWVudGF0aW9uID09PSBcInJpZ2h0XCIgPyAyICogY29ybmVyUmFkaXVzICsgcG9pbnRlckxlbmd0aCA6IDIgKiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW5XaWR0aCwgY2FsY3VsYXRlZFdpZHRoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZseW91dEhlaWdodDogZmx5b3V0SGVpZ2h0ID8gSGVscGVycy5ldmFsdWF0ZVByb3AoZmx5b3V0SGVpZ2h0LCBwcm9wcykgOiBnZXRIZWlnaHQocHJvcHMsIGxhYmVsU2l6ZSwgb3JpZW50YXRpb24pLFxuICAgICAgICBmbHlvdXRXaWR0aDogZmx5b3V0V2lkdGggPyBIZWxwZXJzLmV2YWx1YXRlUHJvcChmbHlvdXRXaWR0aCwgcHJvcHMpIDogZ2V0V2lkdGgocHJvcHMsIGxhYmVsU2l6ZSwgb3JpZW50YXRpb24pXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsUHJvcHMocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpIHtcbiAgICAgIHZhciBmbHlvdXRDZW50ZXIgPSBjYWxjdWxhdGVkVmFsdWVzLmZseW91dENlbnRlcixcbiAgICAgICAgICBzdHlsZSA9IGNhbGN1bGF0ZWRWYWx1ZXMuc3R5bGUsXG4gICAgICAgICAgbGFiZWxTaXplID0gY2FsY3VsYXRlZFZhbHVlcy5sYWJlbFNpemUsXG4gICAgICAgICAgX2NhbGN1bGF0ZWRWYWx1ZXMkZHkgPSBjYWxjdWxhdGVkVmFsdWVzLmR5LFxuICAgICAgICAgIGR5ID0gX2NhbGN1bGF0ZWRWYWx1ZXMkZHkgPT09IHZvaWQgMCA/IDAgOiBfY2FsY3VsYXRlZFZhbHVlcyRkeSxcbiAgICAgICAgICBfY2FsY3VsYXRlZFZhbHVlcyRkeCA9IGNhbGN1bGF0ZWRWYWx1ZXMuZHgsXG4gICAgICAgICAgZHggPSBfY2FsY3VsYXRlZFZhbHVlcyRkeCA9PT0gdm9pZCAwID8gMCA6IF9jYWxjdWxhdGVkVmFsdWVzJGR4O1xuICAgICAgdmFyIHRleHQgPSBwcm9wcy50ZXh0LFxuICAgICAgICAgIGRhdHVtID0gcHJvcHMuZGF0dW0sXG4gICAgICAgICAgYWN0aXZlUG9pbnRzID0gcHJvcHMuYWN0aXZlUG9pbnRzLFxuICAgICAgICAgIGxhYmVsQ29tcG9uZW50ID0gcHJvcHMubGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgaW5kZXggPSBwcm9wcy5pbmRleCxcbiAgICAgICAgICBmbHlvdXRQYWRkaW5nID0gcHJvcHMuZmx5b3V0UGFkZGluZztcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gKEFycmF5LmlzQXJyYXkoc3R5bGUpICYmIHN0eWxlLmxlbmd0aCA/IHN0eWxlWzBdLnRleHRBbmNob3IgOiBzdHlsZS50ZXh0QW5jaG9yKSB8fCBcIm1pZGRsZVwiO1xuXG4gICAgICB2YXIgZ2V0TGFiZWxYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRleHRBbmNob3IgfHwgdGV4dEFuY2hvciA9PT0gXCJtaWRkbGVcIikge1xuICAgICAgICAgIHJldHVybiBmbHlvdXRDZW50ZXIueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gdGV4dEFuY2hvciA9PT0gXCJlbmRcIiA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIGZseW91dENlbnRlci54IC0gc2lnbiAqIChsYWJlbFNpemUud2lkdGggLyAyKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfZGVmYXVsdHMoe30sIGxhYmVsQ29tcG9uZW50LnByb3BzLCB7XG4gICAgICAgIGtleTogXCJcIi5jb25jYXQodGhpcy5pZCwgXCItbGFiZWwtXCIpLmNvbmNhdChpbmRleCksXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGRhdHVtOiBkYXR1bSxcbiAgICAgICAgYWN0aXZlUG9pbnRzOiBhY3RpdmVQb2ludHMsXG4gICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgIGR5OiBkeSxcbiAgICAgICAgZHg6IGR4LFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHg6IGdldExhYmVsWCgpICsgKGZseW91dFBhZGRpbmcubGVmdCAtIGZseW91dFBhZGRpbmcucmlnaHQpIC8gMixcbiAgICAgICAgeTogZmx5b3V0Q2VudGVyLnkgKyAoZmx5b3V0UGFkZGluZy50b3AgLSBmbHlvdXRQYWRkaW5nLmJvdHRvbSkgLyAyLFxuICAgICAgICB2ZXJ0aWNhbEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgYW5nbGU6IHN0eWxlLmFuZ2xlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRlck9yaWVudGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50ZXJPcmllbnRhdGlvbihwb2ludCwgY2VudGVyLCBmbHlvdXREaW1lbnNpb25zKSB7XG4gICAgICB2YXIgZWRnZXMgPSB7XG4gICAgICAgIGJvdHRvbTogY2VudGVyLnkgKyBmbHlvdXREaW1lbnNpb25zLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcDogY2VudGVyLnkgLSBmbHlvdXREaW1lbnNpb25zLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IGNlbnRlci54IC0gZmx5b3V0RGltZW5zaW9ucy53aWR0aCAvIDIsXG4gICAgICAgIHJpZ2h0OiBjZW50ZXIueCArIGZseW91dERpbWVuc2lvbnMud2lkdGggLyAyXG4gICAgICB9O1xuICAgICAgdmFyIGdhcHMgPSBbe1xuICAgICAgICBzaWRlOiBcInRvcFwiLFxuICAgICAgICB2YWw6IGVkZ2VzLnRvcCA+IHBvaW50LnkgPyBlZGdlcy50b3AgLSBwb2ludC55IDogLTFcbiAgICAgIH0sIHtcbiAgICAgICAgc2lkZTogXCJib3R0b21cIixcbiAgICAgICAgdmFsOiBlZGdlcy5ib3R0b20gPCBwb2ludC55ID8gcG9pbnQueSAtIGVkZ2VzLmJvdHRvbSA6IC0xXG4gICAgICB9LCB7XG4gICAgICAgIHNpZGU6IFwicmlnaHRcIixcbiAgICAgICAgdmFsOiBlZGdlcy5yaWdodCA8IHBvaW50LnggPyBwb2ludC54IC0gZWRnZXMucmlnaHQgOiAtMVxuICAgICAgfSwge1xuICAgICAgICBzaWRlOiBcImxlZnRcIixcbiAgICAgICAgdmFsOiBlZGdlcy5sZWZ0ID4gcG9pbnQueCA/IGVkZ2VzLmxlZnQgLSBwb2ludC54IDogLTFcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIF9vcmRlckJ5KGdhcHMsIFwidmFsXCIsIFwiZGVzY1wiKVswXS5zaWRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGbHlvdXRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGbHlvdXRQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFZhbHVlcykge1xuICAgICAgdmFyIGZseW91dERpbWVuc2lvbnMgPSBjYWxjdWxhdGVkVmFsdWVzLmZseW91dERpbWVuc2lvbnMsXG4gICAgICAgICAgZmx5b3V0U3R5bGUgPSBjYWxjdWxhdGVkVmFsdWVzLmZseW91dFN0eWxlLFxuICAgICAgICAgIGZseW91dENlbnRlciA9IGNhbGN1bGF0ZWRWYWx1ZXMuZmx5b3V0Q2VudGVyO1xuICAgICAgdmFyIHggPSBwcm9wcy54LFxuICAgICAgICAgIHkgPSBwcm9wcy55LFxuICAgICAgICAgIGR4ID0gcHJvcHMuZHgsXG4gICAgICAgICAgZHkgPSBwcm9wcy5keSxcbiAgICAgICAgICBkYXR1bSA9IHByb3BzLmRhdHVtLFxuICAgICAgICAgIGFjdGl2ZVBvaW50cyA9IHByb3BzLmFjdGl2ZVBvaW50cyxcbiAgICAgICAgICBpbmRleCA9IHByb3BzLmluZGV4LFxuICAgICAgICAgIHBvaW50ZXJMZW5ndGggPSBwcm9wcy5wb2ludGVyTGVuZ3RoLFxuICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHByb3BzLnBvaW50ZXJXaWR0aCxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMgPSBwcm9wcy5jb3JuZXJSYWRpdXMsXG4gICAgICAgICAgZXZlbnRzID0gcHJvcHMuZXZlbnRzLFxuICAgICAgICAgIGZseW91dENvbXBvbmVudCA9IHByb3BzLmZseW91dENvbXBvbmVudDtcbiAgICAgIHZhciBwb2ludGVyT3JpZW50YXRpb24gPSBIZWxwZXJzLmV2YWx1YXRlUHJvcChwcm9wcy5wb2ludGVyT3JpZW50YXRpb24sIHByb3BzKTtcbiAgICAgIHJldHVybiBfZGVmYXVsdHMoe30sIGZseW91dENvbXBvbmVudC5wcm9wcywge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBkeDogZHgsXG4gICAgICAgIGR5OiBkeSxcbiAgICAgICAgZGF0dW06IGRhdHVtLFxuICAgICAgICBhY3RpdmVQb2ludHM6IGFjdGl2ZVBvaW50cyxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBwb2ludGVyTGVuZ3RoOiBwb2ludGVyTGVuZ3RoLFxuICAgICAgICBwb2ludGVyV2lkdGg6IHBvaW50ZXJXaWR0aCxcbiAgICAgICAgY29ybmVyUmFkaXVzOiBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICBvcmllbnRhdGlvbjogcG9pbnRlck9yaWVudGF0aW9uIHx8IHRoaXMuZ2V0UG9pbnRlck9yaWVudGF0aW9uKHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSwgZmx5b3V0Q2VudGVyLCBmbHlvdXREaW1lbnNpb25zKSxcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIi10b29sdGlwLVwiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICB3aWR0aDogZmx5b3V0RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBmbHlvdXREaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgc3R5bGU6IGZseW91dFN0eWxlLFxuICAgICAgICBjZW50ZXI6IGZseW91dENlbnRlclxuICAgICAgfSk7XG4gICAgfSAvLyBPdmVycmlkZGVuIGluIHZpY3RvcnktY29yZS1uYXRpdmVcblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9vbHRpcChwcm9wcykge1xuICAgICAgdmFyIGFjdGl2ZSA9IEhlbHBlcnMuZXZhbHVhdGVQcm9wKHByb3BzLmFjdGl2ZSwgcHJvcHMpO1xuICAgICAgdmFyIHJlbmRlckluUG9ydGFsID0gcHJvcHMucmVuZGVySW5Qb3J0YWw7XG5cbiAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJJblBvcnRhbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlQb3J0YWwsIG51bGwsIG51bGwpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2YWx1YXRlZFByb3BzID0gdGhpcy5nZXRFdmFsdWF0ZWRQcm9wcyhwcm9wcyk7XG4gICAgICB2YXIgZmx5b3V0Q29tcG9uZW50ID0gZXZhbHVhdGVkUHJvcHMuZmx5b3V0Q29tcG9uZW50LFxuICAgICAgICAgIGxhYmVsQ29tcG9uZW50ID0gZXZhbHVhdGVkUHJvcHMubGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgZ3JvdXBDb21wb25lbnQgPSBldmFsdWF0ZWRQcm9wcy5ncm91cENvbXBvbmVudDtcbiAgICAgIHZhciBjYWxjdWxhdGVkVmFsdWVzID0gdGhpcy5nZXRDYWxjdWxhdGVkVmFsdWVzKGV2YWx1YXRlZFByb3BzKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFsvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGZseW91dENvbXBvbmVudCwgdGhpcy5nZXRGbHlvdXRQcm9wcyhldmFsdWF0ZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcykpLCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGxhYmVsQ29tcG9uZW50LCB0aGlzLmdldExhYmVsUHJvcHMoZXZhbHVhdGVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpKV07XG4gICAgICB2YXIgdG9vbHRpcCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoZ3JvdXBDb21wb25lbnQsIHtcbiAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgdHJhbnNmb3JtOiBjYWxjdWxhdGVkVmFsdWVzLnRyYW5zZm9ybVxuICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIHJlbmRlckluUG9ydGFsID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeVBvcnRhbCwgbnVsbCwgdG9vbHRpcCkgOiB0b29sdGlwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gSGVscGVycy5tb2RpZnlQcm9wcyh0aGlzLnByb3BzLCBmYWxsYmFja1Byb3BzLCBcInRvb2x0aXBcIik7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb29sdGlwKHByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmljdG9yeVRvb2x0aXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblZpY3RvcnlUb29sdGlwLmRpc3BsYXlOYW1lID0gXCJWaWN0b3J5VG9vbHRpcFwiO1xuVmljdG9yeVRvb2x0aXAucm9sZSA9IFwidG9vbHRpcFwiO1xuVmljdG9yeVRvb2x0aXAucHJvcFR5cGVzID0ge1xuICBhY3RpdmF0ZURhdGE6IFByb3BUeXBlcy5ib29sLFxuICBhY3RpdmU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICBhY3RpdmVQb2ludHM6IFByb3BUeXBlcy5hcnJheSxcbiAgYW5nbGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNlbnRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4OiBDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmUsXG4gICAgeTogQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlXG4gIH0pLFxuICBjZW50ZXJPZmZzZXQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICB5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuY10pXG4gIH0pLFxuICBjb25zdHJhaW5Ub1Zpc2libGVBcmVhOiBQcm9wVHlwZXMuYm9vbCxcbiAgY29ybmVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmUsIFByb3BUeXBlcy5mdW5jXSksXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgZGF0dW06IFByb3BUeXBlcy5vYmplY3QsXG4gIGR4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuY10pLFxuICBkeTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgZXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICBmbHlvdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBmbHlvdXRIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW0N1c3RvbVByb3BUeXBlcy5ub25OZWdhdGl2ZSwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgZmx5b3V0UGFkZGluZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGJvdHRvbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG4gIGZseW91dFN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBmbHlvdXRXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlLCBQcm9wVHlwZXMuZnVuY10pLFxuICBncm91cENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgaG9yaXpvbnRhbDogUHJvcFR5cGVzLmJvb2wsXG4gIGlkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGluZGV4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGxhYmVsQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgb3JpZW50YXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pLCBQcm9wVHlwZXMuZnVuY10pLFxuICBwb2ludGVyTGVuZ3RoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmUsIFByb3BUeXBlcy5mdW5jXSksXG4gIHBvaW50ZXJPcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFtcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSksIFByb3BUeXBlcy5mdW5jXSksXG4gIHBvaW50ZXJXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlLCBQcm9wVHlwZXMuZnVuY10pLFxuICBwb2xhcjogUHJvcFR5cGVzLmJvb2wsXG4gIHJlbmRlckluUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2NhbGU6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogQ3VzdG9tUHJvcFR5cGVzLnNjYWxlLFxuICAgIHk6IEN1c3RvbVByb3BUeXBlcy5zY2FsZVxuICB9KSxcbiAgc3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5hcnJheV0pLFxuICB0ZXh0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmFycmF5XSksXG4gIHRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLm51bWJlcixcbiAgeTogUHJvcFR5cGVzLm51bWJlclxufTtcblZpY3RvcnlUb29sdGlwLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlOiBmYWxzZSxcbiAgcmVuZGVySW5Qb3J0YWw6IHRydWUsXG4gIGxhYmVsQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5TGFiZWwsIG51bGwpLFxuICBmbHlvdXRDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZseW91dCwgbnVsbCksXG4gIGdyb3VwQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbClcbn07XG5cblZpY3RvcnlUb29sdGlwLmRlZmF1bHRFdmVudHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIGFjdGl2YXRlID0gcHJvcHMuYWN0aXZhdGVEYXRhID8gW3tcbiAgICB0YXJnZXQ6IFwibGFiZWxzXCIsXG4gICAgbXV0YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICB0YXJnZXQ6IFwiZGF0YVwiLFxuICAgIG11dGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XSA6IFt7XG4gICAgdGFyZ2V0OiBcImxhYmVsc1wiLFxuICAgIG11dGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9XTtcbiAgdmFyIGRlYWN0aXZhdGUgPSBwcm9wcy5hY3RpdmF0ZURhdGEgPyBbe1xuICAgIHRhcmdldDogXCJsYWJlbHNcIixcbiAgICBtdXRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAgdGFyZ2V0OiBcImRhdGFcIixcbiAgICBtdXRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuICB9XSA6IFt7XG4gICAgdGFyZ2V0OiBcImxhYmVsc1wiLFxuICAgIG11dGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH1dO1xuICByZXR1cm4gW3tcbiAgICB0YXJnZXQ6IFwiZGF0YVwiLFxuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmF0ZTtcbiAgICAgIH0sXG4gICAgICBvbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmF0ZTtcbiAgICAgIH0sXG4gICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2YXRlO1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlYWN0aXZhdGU7XG4gICAgICB9LFxuICAgICAgb25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZWFjdGl2YXRlO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlYWN0aXZhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XTtcbn07XG5cbmV4cG9ydCB7IFZpY3RvcnlUb29sdGlwIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77013\n')}}]);