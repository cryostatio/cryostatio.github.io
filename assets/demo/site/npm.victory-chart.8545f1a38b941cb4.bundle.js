"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[5880],{59908:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "k": () => (/* binding */ VictoryChart)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__(41609);\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/hooks/use-animation-state.js\nvar use_animation_state = __webpack_require__(16178);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/user-props.js\nvar user_props = __webpack_require__(80450);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/wrapper.js\nvar wrapper = __webpack_require__(82191);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/hooks/use-previous-props.js\nvar use_previous_props = __webpack_require__(40066);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/common-props.js\nvar common_props = __webpack_require__(5734);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/background.js\nvar background = __webpack_require__(57632);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-shared-events/es/victory-shared-events.js\nvar victory_shared_events = __webpack_require__(22755);\n// EXTERNAL MODULE: ./node_modules/victory-axis/es/victory-axis.js + 1 modules\nvar victory_axis = __webpack_require__(73091);\n// EXTERNAL MODULE: ./node_modules/victory-polar-axis/es/victory-polar-axis.js + 1 modules\nvar victory_polar_axis = __webpack_require__(22528);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/axis.js\nvar victory_util_axis = __webpack_require__(92555);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/scale.js\nvar victory_util_scale = __webpack_require__(74765);\n;// CONCATENATED MODULE: ./node_modules/victory-chart/es/helper-methods.js\n\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable no-use-before-define */\n\n\nvar fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\n\nfunction getAxisProps(child, props, calculatedProps) {\n  var domain = calculatedProps.domain,\n      scale = calculatedProps.scale,\n      stringMap = calculatedProps.stringMap,\n      categories = calculatedProps.categories,\n      horizontal = calculatedProps.horizontal;\n  return {\n    stringMap: stringMap,\n    horizontal: horizontal,\n    categories: categories,\n    startAngle: props.startAngle,\n    endAngle: props.endAngle,\n    innerRadius: props.innerRadius,\n    domain: domain,\n    scale: scale\n  };\n}\n\nfunction getBackgroundWithProps(props, calculatedProps) {\n  var backgroundElement = props.backgroundComponent;\n  var height = props.polar ? calculatedProps.range.y[1] : calculatedProps.range.y[0] - calculatedProps.range.y[1];\n  var width = calculatedProps.range.x[1] - calculatedProps.range.x[0];\n  var xScale = props.horizontal ? calculatedProps.scale.y.range()[0] : calculatedProps.scale.x.range()[0];\n  var yScale = props.horizontal ? calculatedProps.scale.x.range()[1] : calculatedProps.scale.y.range()[1];\n  var xCoordinate = props.polar ? calculatedProps.origin.x : xScale;\n  var yCoordinate = props.polar ? calculatedProps.origin.y : yScale;\n  var parentName = props.name || "chart";\n  var backgroundProps = {\n    height: height,\n    polar: props.polar,\n    scale: calculatedProps.scale,\n    style: props.style.background,\n    x: xCoordinate,\n    y: yCoordinate,\n    key: "".concat(parentName, "-background"),\n    width: width\n  };\n  return /*#__PURE__*/react.cloneElement(backgroundElement, defaults_default()({}, backgroundElement.props, backgroundProps));\n}\n\nfunction getChildProps(child, props, calculatedProps) {\n  var axisChild = victory_util_axis/* findAxisComponents */.qM([child]);\n\n  if (axisChild.length > 0) {\n    return getAxisProps(axisChild[0], props, calculatedProps);\n  }\n\n  var categories = calculatedProps.categories,\n      domain = calculatedProps.domain,\n      range = calculatedProps.range,\n      scale = calculatedProps.scale,\n      stringMap = calculatedProps.stringMap,\n      horizontal = calculatedProps.horizontal;\n  return {\n    categories: categories,\n    domain: domain,\n    range: range,\n    scale: scale,\n    stringMap: stringMap,\n    horizontal: horizontal\n  };\n}\n\nfunction getStyles(props) {\n  var styleProps = props.style && props.style.parent;\n  return {\n    parent: defaults_default()({}, styleProps, {\n      height: "100%",\n      width: "100%",\n      userSelect: "none"\n    })\n  };\n}\n\nfunction getCalculatedProps(props, childComponents) {\n  var style = getStyles(props);\n  props = helpers/* modifyProps */.TY(props, fallbackProps, "chart");\n  var _props = props,\n      horizontal = _props.horizontal,\n      polar = _props.polar;\n  var allStrings = wrapper/* getStringsFromChildren */.Oz(props, childComponents);\n  var categories = wrapper/* getCategories */.CP(props, childComponents, allStrings);\n  var stringMap = createStringMap(props, childComponents, allStrings);\n  var domain = {\n    x: getDomain(assign_default()({}, props, {\n      categories: categories\n    }), "x", childComponents),\n    y: getDomain(assign_default()({}, props, {\n      categories: categories\n    }), "y", childComponents)\n  };\n  var range = {\n    x: helpers/* getRange */.rx(props, "x"),\n    y: helpers/* getRange */.rx(props, "y")\n  };\n  var baseScale = {\n    x: victory_util_scale/* getScaleFromProps */.j$(props, "x") || wrapper/* getScale */.yZ(props, "x"),\n    y: victory_util_scale/* getScaleFromProps */.j$(props, "y") || wrapper/* getScale */.yZ(props, "y")\n  };\n  var scale = {\n    x: baseScale.x.domain(domain.x).range(horizontal ? range.y : range.x),\n    y: baseScale.y.domain(domain.y).range(horizontal ? range.x : range.y)\n  };\n  var origin = polar ? helpers/* getPolarOrigin */.IW(props) : victory_util_axis/* getOrigin */.P$(domain);\n  var padding = helpers/* getPadding */.tQ(props);\n  return {\n    categories: categories,\n    domain: domain,\n    range: range,\n    horizontal: horizontal,\n    scale: scale,\n    stringMap: stringMap,\n    style: style,\n    origin: origin,\n    padding: padding\n  };\n}\nfunction getChildren(props, childComponents, calculatedProps) {\n  childComponents = childComponents || getChildComponents(props);\n  calculatedProps = calculatedProps || getCalculatedProps(props, childComponents);\n  var baseStyle = calculatedProps.style.parent;\n  var height = props.height,\n      polar = props.polar,\n      theme = props.theme,\n      width = props.width;\n  var _calculatedProps = calculatedProps,\n      origin = _calculatedProps.origin,\n      horizontal = _calculatedProps.horizontal;\n  var parentName = props.name || "chart";\n  return childComponents.map(function (child, index) {\n    var role = child.type && child.type.role;\n    var style = Array.isArray(child.props.style) ? child.props.style : defaults_default()({}, child.props.style, {\n      parent: baseStyle\n    });\n    var childProps = getChildProps(child, props, calculatedProps);\n    var name = child.props.name || "".concat(parentName, "-").concat(role, "-").concat(index);\n\n    var newProps = defaults_default()({\n      horizontal: horizontal,\n      height: height,\n      polar: polar,\n      theme: theme,\n      width: width,\n      style: style,\n      name: name,\n      origin: polar ? origin : undefined,\n      padding: calculatedProps.padding,\n      key: "".concat(name, "-key-").concat(index),\n      standalone: false\n    }, childProps);\n\n    return /*#__PURE__*/react.cloneElement(child, newProps);\n  });\n}\nvar getChildComponents = function (props, defaultAxes) {\n  var childComponents = react.Children.toArray(props.children);\n\n  var newChildComponents = _toConsumableArray(childComponents);\n\n  if (childComponents.length === 0) {\n    newChildComponents.push(defaultAxes.independent, defaultAxes.dependent);\n  } else {\n    var axisComponents = {\n      dependent: victory_util_axis/* getAxisComponentsWithParent */.X$(childComponents, "dependent"),\n      independent: victory_util_axis/* getAxisComponentsWithParent */.X$(childComponents, "independent")\n    };\n\n    if (axisComponents.dependent.length === 0 && axisComponents.independent.length === 0) {\n      newChildComponents = props.prependDefaultAxes ? [defaultAxes.independent, defaultAxes.dependent].concat(newChildComponents) : newChildComponents.concat([defaultAxes.independent, defaultAxes.dependent]);\n    }\n  }\n\n  return newChildComponents;\n};\n\nvar getDomain = function (props, axis, childComponents) {\n  childComponents = childComponents || react.Children.toArray(props.children);\n  var domain = wrapper/* getDomain */.ge(props, axis, childComponents);\n  var axisComponent = victory_util_axis/* getAxisComponent */.OO(childComponents, axis);\n  var invertDomain = axisComponent && axisComponent.props && axisComponent.props.invertAxis;\n  return invertDomain ? domain.concat().reverse() : domain;\n};\n\nvar createStringMap = function (props, childComponents, allStrings) {\n  var x = !allStrings.x || allStrings.x.length === 0 ? null : allStrings.x.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var y = !allStrings.y || allStrings.y.length === 0 ? null : allStrings.y.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  return {\n    x: x,\n    y: y\n  };\n};\n// EXTERNAL MODULE: ./node_modules/react-fast-compare/index.js\nvar react_fast_compare = __webpack_require__(69590);\nvar react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);\n;// CONCATENATED MODULE: ./node_modules/victory-chart/es/victory-chart.js\n\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\nvar victory_chart_fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\n\nvar VictoryChartImpl = function (initialProps) {\n  var role = "chart";\n\n  var _Hooks$useAnimationSt = use_animation_state/* useAnimationState */.h(),\n      getAnimationProps = _Hooks$useAnimationSt.getAnimationProps,\n      setAnimationState = _Hooks$useAnimationSt.setAnimationState,\n      getProps = _Hooks$useAnimationSt.getProps;\n\n  var props = getProps(initialProps);\n  var modifiedProps = helpers/* modifyProps */.TY(props, victory_chart_fallbackProps, role);\n  var desc = modifiedProps.desc,\n      eventKey = modifiedProps.eventKey,\n      containerComponent = modifiedProps.containerComponent,\n      standalone = modifiedProps.standalone,\n      groupComponent = modifiedProps.groupComponent,\n      externalEventMutations = modifiedProps.externalEventMutations,\n      width = modifiedProps.width,\n      height = modifiedProps.height,\n      theme = modifiedProps.theme,\n      polar = modifiedProps.polar,\n      name = modifiedProps.name,\n      title = modifiedProps.title;\n  var axes = props.polar ? modifiedProps.defaultPolarAxes : modifiedProps.defaultAxes;\n  var childComponents = react.useMemo(function () {\n    return getChildComponents(modifiedProps, axes);\n  }, [modifiedProps, axes]);\n  var calculatedProps = react.useMemo(function () {\n    return getCalculatedProps(modifiedProps, childComponents);\n  }, [modifiedProps, childComponents]);\n  var domain = calculatedProps.domain,\n      scale = calculatedProps.scale,\n      style = calculatedProps.style,\n      origin = calculatedProps.origin,\n      horizontal = calculatedProps.horizontal;\n  var newChildren = react.useMemo(function () {\n    var children = getChildren(props, childComponents, calculatedProps);\n    var mappedChildren = children.map(function (child, index) {\n      var childProps = assign_default()({\n        animate: getAnimationProps(props, child, index)\n      }, child.props);\n\n      return /*#__PURE__*/react.cloneElement(child, childProps);\n    });\n\n    if (props.style && props.style.background) {\n      var backgroundComponent = getBackgroundWithProps(props, calculatedProps);\n      mappedChildren.unshift(backgroundComponent);\n    }\n\n    return mappedChildren;\n  }, [getAnimationProps, childComponents, props, calculatedProps]);\n  var containerProps = react.useMemo(function () {\n    if (standalone) {\n      return {\n        desc: desc,\n        domain: domain,\n        width: width,\n        height: height,\n        horizontal: horizontal,\n        name: name,\n        origin: polar ? origin : undefined,\n        polar: polar,\n        theme: theme,\n        title: title,\n        scale: scale,\n        standalone: standalone,\n        style: style.parent\n      };\n    }\n\n    return {};\n  }, [desc, domain, height, horizontal, name, origin, polar, scale, standalone, style, title, theme, width]);\n  var container = react.useMemo(function () {\n    if (standalone) {\n      var defaultContainerProps = defaults_default()({}, containerComponent.props, containerProps, user_props/* getSafeUserProps */.I(initialProps));\n\n      return /*#__PURE__*/react.cloneElement(containerComponent, defaultContainerProps);\n    }\n\n    return groupComponent;\n  }, [groupComponent, standalone, containerComponent, containerProps, initialProps]);\n  var events = react.useMemo(function () {\n    return wrapper/* getAllEvents */.IP(props);\n  }, [props]);\n  var previousProps = use_previous_props/* usePreviousProps */.Y(initialProps);\n  react.useEffect(function () {\n    // This is called before dismount to keep state in sync\n    return function () {\n      if (initialProps.animate) {\n        setAnimationState(previousProps, initialProps);\n      }\n    };\n  }, [setAnimationState, previousProps, initialProps]);\n\n  if (!isEmpty_default()(events)) {\n    return /*#__PURE__*/react.createElement(victory_shared_events/* default */.Z, {\n      container: container,\n      eventKey: eventKey,\n      events: events,\n      externalEventMutations: externalEventMutations\n    }, newChildren);\n  }\n\n  return /*#__PURE__*/react.cloneElement(container, container.props, newChildren);\n};\n\nVictoryChartImpl.propTypes = _objectSpread(_objectSpread({}, common_props/* CommonProps.baseProps */.l.baseProps), {}, {\n  backgroundComponent: (prop_types_default()).element,\n  children: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).node), (prop_types_default()).node]),\n  defaultAxes: prop_types_default().shape({\n    independent: (prop_types_default()).element,\n    dependent: (prop_types_default()).element\n  }),\n  defaultPolarAxes: prop_types_default().shape({\n    independent: (prop_types_default()).element,\n    dependent: (prop_types_default()).element\n  }),\n  endAngle: (prop_types_default()).number,\n  innerRadius: victory_util_prop_types/* nonNegative */.A7,\n  prependDefaultAxes: (prop_types_default()).bool,\n  startAngle: (prop_types_default()).number\n});\nVictoryChartImpl.defaultProps = {\n  backgroundComponent: /*#__PURE__*/react.createElement(background/* Background */.A, null),\n  containerComponent: /*#__PURE__*/react.createElement(victory_container/* VictoryContainer */._, null),\n  defaultAxes: {\n    independent: /*#__PURE__*/react.createElement(victory_axis/* VictoryAxis */.E, null),\n    dependent: /*#__PURE__*/react.createElement(victory_axis/* VictoryAxis */.E, {\n      dependentAxis: true\n    })\n  },\n  defaultPolarAxes: {\n    independent: /*#__PURE__*/react.createElement(victory_polar_axis/* default */.Z, null),\n    dependent: /*#__PURE__*/react.createElement(victory_polar_axis/* default */.Z, {\n      dependentAxis: true\n    })\n  },\n  groupComponent: /*#__PURE__*/react.createElement("g", null),\n  standalone: true,\n  theme: victory_theme/* VictoryTheme.grayscale */.J.grayscale\n};\nvar VictoryChart = /*#__PURE__*/react.memo(VictoryChartImpl, (react_fast_compare_default()));\nVictoryChart.displayName = "VictoryChart"; // @ts-expect-error FIXME: Does this "expectedComponents" do anything?\n\nVictoryChart.expectedComponents = ["groupComponent", "containerComponent"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE9BQU8saUJBQVE7QUFDZix3QkFBd0IsbUJBQW1CLENBQUMsb0NBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7O0FBRUEsMkRBQTJELEVBQUUsbURBQXFCLEtBQUs7QUFDdkYsdUJBQXVCLDhCQUFpQjtBQUN4QyxZQUFZLDhCQUFtQixFQUFFLDRCQUFpQixDQUFDLDJCQUFjLEdBQUcsMkJBQWM7QUFDbEYsZUFBZSwwQkFBZTtBQUM5QixpQkFBaUIsOEJBQWlCO0FBQ2xDLGVBQWUsOEJBQWlCO0FBQ2hDLEdBQUc7QUFDSCxvQkFBb0IsMEJBQWU7QUFDbkMsaUJBQWlCLDhCQUFpQjtBQUNsQyxlQUFlLDhCQUFpQjtBQUNoQyxHQUFHO0FBQ0gsWUFBWSw2QkFBZ0I7QUFDNUIsZUFBZSwyQ0FBMkI7QUFDMUMsc0JBQXNCLDJCQUFjO0FBQ3BDLGNBQWMsNkJBQWdCO0FBQzlCLENBQUM7QUFDRDtBQUNBLG9DQUFvQyxtQkFBbUIsQ0FBQyw0QkFBVTtBQUNsRSxtQ0FBbUMsbUJBQW1CLENBQUMseUNBQWdCO0FBQ3ZFO0FBQ0EsOEJBQThCLG1CQUFtQixDQUFDLCtCQUFXO0FBQzdELDRCQUE0QixtQkFBbUIsQ0FBQywrQkFBVztBQUMzRDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsbUJBQW1CLENBQUMsaUNBQWdCO0FBQ2xFLDRCQUE0QixtQkFBbUIsQ0FBQyxpQ0FBZ0I7QUFDaEU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQSxTQUFTLHFEQUFzQjtBQUMvQjtBQUNPLGdDQUFnQyxVQUFVLG1CQUFtQiw4QkFBTztBQUMzRSwyQ0FBMkM7O0FBRTNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3J5b3N0YXQtd2ViLy4vbm9kZV9tb2R1bGVzL3ZpY3RvcnktY2hhcnQvZXMvaGVscGVyLW1ldGhvZHMuanM/MzQ1OCIsIndlYnBhY2s6Ly9jcnlvc3RhdC13ZWIvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1jaGFydC9lcy92aWN0b3J5LWNoYXJ0LmpzP2ZlZWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9hc3NpZ24gZnJvbSBcImxvZGFzaC9hc3NpZ25cIjtcbmltcG9ydCBfZGVmYXVsdHMgZnJvbSBcImxvZGFzaC9kZWZhdWx0c1wiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBIZWxwZXJzLCBTY2FsZSwgQXhpcywgV3JhcHBlciB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbnZhciBmYWxsYmFja1Byb3BzID0ge1xuICB3aWR0aDogNDUwLFxuICBoZWlnaHQ6IDMwMCxcbiAgcGFkZGluZzogNTBcbn07XG5cbmZ1bmN0aW9uIGdldEF4aXNQcm9wcyhjaGlsZCwgcHJvcHMsIGNhbGN1bGF0ZWRQcm9wcykge1xuICB2YXIgZG9tYWluID0gY2FsY3VsYXRlZFByb3BzLmRvbWFpbixcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFByb3BzLnNjYWxlLFxuICAgICAgc3RyaW5nTWFwID0gY2FsY3VsYXRlZFByb3BzLnN0cmluZ01hcCxcbiAgICAgIGNhdGVnb3JpZXMgPSBjYWxjdWxhdGVkUHJvcHMuY2F0ZWdvcmllcyxcbiAgICAgIGhvcml6b250YWwgPSBjYWxjdWxhdGVkUHJvcHMuaG9yaXpvbnRhbDtcbiAgcmV0dXJuIHtcbiAgICBzdHJpbmdNYXA6IHN0cmluZ01hcCxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgc3RhcnRBbmdsZTogcHJvcHMuc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZTogcHJvcHMuZW5kQW5nbGUsXG4gICAgaW5uZXJSYWRpdXM6IHByb3BzLmlubmVyUmFkaXVzLFxuICAgIGRvbWFpbjogZG9tYWluLFxuICAgIHNjYWxlOiBzY2FsZVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFdpdGhQcm9wcyhwcm9wcywgY2FsY3VsYXRlZFByb3BzKSB7XG4gIHZhciBiYWNrZ3JvdW5kRWxlbWVudCA9IHByb3BzLmJhY2tncm91bmRDb21wb25lbnQ7XG4gIHZhciBoZWlnaHQgPSBwcm9wcy5wb2xhciA/IGNhbGN1bGF0ZWRQcm9wcy5yYW5nZS55WzFdIDogY2FsY3VsYXRlZFByb3BzLnJhbmdlLnlbMF0gLSBjYWxjdWxhdGVkUHJvcHMucmFuZ2UueVsxXTtcbiAgdmFyIHdpZHRoID0gY2FsY3VsYXRlZFByb3BzLnJhbmdlLnhbMV0gLSBjYWxjdWxhdGVkUHJvcHMucmFuZ2UueFswXTtcbiAgdmFyIHhTY2FsZSA9IHByb3BzLmhvcml6b250YWwgPyBjYWxjdWxhdGVkUHJvcHMuc2NhbGUueS5yYW5nZSgpWzBdIDogY2FsY3VsYXRlZFByb3BzLnNjYWxlLngucmFuZ2UoKVswXTtcbiAgdmFyIHlTY2FsZSA9IHByb3BzLmhvcml6b250YWwgPyBjYWxjdWxhdGVkUHJvcHMuc2NhbGUueC5yYW5nZSgpWzFdIDogY2FsY3VsYXRlZFByb3BzLnNjYWxlLnkucmFuZ2UoKVsxXTtcbiAgdmFyIHhDb29yZGluYXRlID0gcHJvcHMucG9sYXIgPyBjYWxjdWxhdGVkUHJvcHMub3JpZ2luLnggOiB4U2NhbGU7XG4gIHZhciB5Q29vcmRpbmF0ZSA9IHByb3BzLnBvbGFyID8gY2FsY3VsYXRlZFByb3BzLm9yaWdpbi55IDogeVNjYWxlO1xuICB2YXIgcGFyZW50TmFtZSA9IHByb3BzLm5hbWUgfHwgXCJjaGFydFwiO1xuICB2YXIgYmFja2dyb3VuZFByb3BzID0ge1xuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHBvbGFyOiBwcm9wcy5wb2xhcixcbiAgICBzY2FsZTogY2FsY3VsYXRlZFByb3BzLnNjYWxlLFxuICAgIHN0eWxlOiBwcm9wcy5zdHlsZS5iYWNrZ3JvdW5kLFxuICAgIHg6IHhDb29yZGluYXRlLFxuICAgIHk6IHlDb29yZGluYXRlLFxuICAgIGtleTogXCJcIi5jb25jYXQocGFyZW50TmFtZSwgXCItYmFja2dyb3VuZFwiKSxcbiAgICB3aWR0aDogd2lkdGhcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoYmFja2dyb3VuZEVsZW1lbnQsIF9kZWZhdWx0cyh7fSwgYmFja2dyb3VuZEVsZW1lbnQucHJvcHMsIGJhY2tncm91bmRQcm9wcykpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZFByb3BzKGNoaWxkLCBwcm9wcywgY2FsY3VsYXRlZFByb3BzKSB7XG4gIHZhciBheGlzQ2hpbGQgPSBBeGlzLmZpbmRBeGlzQ29tcG9uZW50cyhbY2hpbGRdKTtcblxuICBpZiAoYXhpc0NoaWxkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZ2V0QXhpc1Byb3BzKGF4aXNDaGlsZFswXSwgcHJvcHMsIGNhbGN1bGF0ZWRQcm9wcyk7XG4gIH1cblxuICB2YXIgY2F0ZWdvcmllcyA9IGNhbGN1bGF0ZWRQcm9wcy5jYXRlZ29yaWVzLFxuICAgICAgZG9tYWluID0gY2FsY3VsYXRlZFByb3BzLmRvbWFpbixcbiAgICAgIHJhbmdlID0gY2FsY3VsYXRlZFByb3BzLnJhbmdlLFxuICAgICAgc2NhbGUgPSBjYWxjdWxhdGVkUHJvcHMuc2NhbGUsXG4gICAgICBzdHJpbmdNYXAgPSBjYWxjdWxhdGVkUHJvcHMuc3RyaW5nTWFwLFxuICAgICAgaG9yaXpvbnRhbCA9IGNhbGN1bGF0ZWRQcm9wcy5ob3Jpem9udGFsO1xuICByZXR1cm4ge1xuICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgZG9tYWluOiBkb21haW4sXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzdHJpbmdNYXA6IHN0cmluZ01hcCxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlcyhwcm9wcykge1xuICB2YXIgc3R5bGVQcm9wcyA9IHByb3BzLnN0eWxlICYmIHByb3BzLnN0eWxlLnBhcmVudDtcbiAgcmV0dXJuIHtcbiAgICBwYXJlbnQ6IF9kZWZhdWx0cyh7fSwgc3R5bGVQcm9wcywge1xuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgfSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWRQcm9wcyhwcm9wcywgY2hpbGRDb21wb25lbnRzKSB7XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlcyhwcm9wcyk7XG4gIHByb3BzID0gSGVscGVycy5tb2RpZnlQcm9wcyhwcm9wcywgZmFsbGJhY2tQcm9wcywgXCJjaGFydFwiKTtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgaG9yaXpvbnRhbCA9IF9wcm9wcy5ob3Jpem9udGFsLFxuICAgICAgcG9sYXIgPSBfcHJvcHMucG9sYXI7XG4gIHZhciBhbGxTdHJpbmdzID0gV3JhcHBlci5nZXRTdHJpbmdzRnJvbUNoaWxkcmVuKHByb3BzLCBjaGlsZENvbXBvbmVudHMpO1xuICB2YXIgY2F0ZWdvcmllcyA9IFdyYXBwZXIuZ2V0Q2F0ZWdvcmllcyhwcm9wcywgY2hpbGRDb21wb25lbnRzLCBhbGxTdHJpbmdzKTtcbiAgdmFyIHN0cmluZ01hcCA9IGNyZWF0ZVN0cmluZ01hcChwcm9wcywgY2hpbGRDb21wb25lbnRzLCBhbGxTdHJpbmdzKTtcbiAgdmFyIGRvbWFpbiA9IHtcbiAgICB4OiBnZXREb21haW4oX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXNcbiAgICB9KSwgXCJ4XCIsIGNoaWxkQ29tcG9uZW50cyksXG4gICAgeTogZ2V0RG9tYWluKF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgfSksIFwieVwiLCBjaGlsZENvbXBvbmVudHMpXG4gIH07XG4gIHZhciByYW5nZSA9IHtcbiAgICB4OiBIZWxwZXJzLmdldFJhbmdlKHByb3BzLCBcInhcIiksXG4gICAgeTogSGVscGVycy5nZXRSYW5nZShwcm9wcywgXCJ5XCIpXG4gIH07XG4gIHZhciBiYXNlU2NhbGUgPSB7XG4gICAgeDogU2NhbGUuZ2V0U2NhbGVGcm9tUHJvcHMocHJvcHMsIFwieFwiKSB8fCBXcmFwcGVyLmdldFNjYWxlKHByb3BzLCBcInhcIiksXG4gICAgeTogU2NhbGUuZ2V0U2NhbGVGcm9tUHJvcHMocHJvcHMsIFwieVwiKSB8fCBXcmFwcGVyLmdldFNjYWxlKHByb3BzLCBcInlcIilcbiAgfTtcbiAgdmFyIHNjYWxlID0ge1xuICAgIHg6IGJhc2VTY2FsZS54LmRvbWFpbihkb21haW4ueCkucmFuZ2UoaG9yaXpvbnRhbCA/IHJhbmdlLnkgOiByYW5nZS54KSxcbiAgICB5OiBiYXNlU2NhbGUueS5kb21haW4oZG9tYWluLnkpLnJhbmdlKGhvcml6b250YWwgPyByYW5nZS54IDogcmFuZ2UueSlcbiAgfTtcbiAgdmFyIG9yaWdpbiA9IHBvbGFyID8gSGVscGVycy5nZXRQb2xhck9yaWdpbihwcm9wcykgOiBBeGlzLmdldE9yaWdpbihkb21haW4pO1xuICB2YXIgcGFkZGluZyA9IEhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyk7XG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcbiAgICBkb21haW46IGRvbWFpbixcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3RyaW5nTWFwOiBzdHJpbmdNYXAsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIG9yaWdpbjogb3JpZ2luLFxuICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZHJlbihwcm9wcywgY2hpbGRDb21wb25lbnRzLCBjYWxjdWxhdGVkUHJvcHMpIHtcbiAgY2hpbGRDb21wb25lbnRzID0gY2hpbGRDb21wb25lbnRzIHx8IGdldENoaWxkQ29tcG9uZW50cyhwcm9wcyk7XG4gIGNhbGN1bGF0ZWRQcm9wcyA9IGNhbGN1bGF0ZWRQcm9wcyB8fCBnZXRDYWxjdWxhdGVkUHJvcHMocHJvcHMsIGNoaWxkQ29tcG9uZW50cyk7XG4gIHZhciBiYXNlU3R5bGUgPSBjYWxjdWxhdGVkUHJvcHMuc3R5bGUucGFyZW50O1xuICB2YXIgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgcG9sYXIgPSBwcm9wcy5wb2xhcixcbiAgICAgIHRoZW1lID0gcHJvcHMudGhlbWUsXG4gICAgICB3aWR0aCA9IHByb3BzLndpZHRoO1xuICB2YXIgX2NhbGN1bGF0ZWRQcm9wcyA9IGNhbGN1bGF0ZWRQcm9wcyxcbiAgICAgIG9yaWdpbiA9IF9jYWxjdWxhdGVkUHJvcHMub3JpZ2luLFxuICAgICAgaG9yaXpvbnRhbCA9IF9jYWxjdWxhdGVkUHJvcHMuaG9yaXpvbnRhbDtcbiAgdmFyIHBhcmVudE5hbWUgPSBwcm9wcy5uYW1lIHx8IFwiY2hhcnRcIjtcbiAgcmV0dXJuIGNoaWxkQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIHZhciByb2xlID0gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLnJvbGU7XG4gICAgdmFyIHN0eWxlID0gQXJyYXkuaXNBcnJheShjaGlsZC5wcm9wcy5zdHlsZSkgPyBjaGlsZC5wcm9wcy5zdHlsZSA6IF9kZWZhdWx0cyh7fSwgY2hpbGQucHJvcHMuc3R5bGUsIHtcbiAgICAgIHBhcmVudDogYmFzZVN0eWxlXG4gICAgfSk7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBnZXRDaGlsZFByb3BzKGNoaWxkLCBwcm9wcywgY2FsY3VsYXRlZFByb3BzKTtcbiAgICB2YXIgbmFtZSA9IGNoaWxkLnByb3BzLm5hbWUgfHwgXCJcIi5jb25jYXQocGFyZW50TmFtZSwgXCItXCIpLmNvbmNhdChyb2xlLCBcIi1cIikuY29uY2F0KGluZGV4KTtcblxuICAgIHZhciBuZXdQcm9wcyA9IF9kZWZhdWx0cyh7XG4gICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwb2xhcjogcG9sYXIsXG4gICAgICB0aGVtZTogdGhlbWUsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb3JpZ2luOiBwb2xhciA/IG9yaWdpbiA6IHVuZGVmaW5lZCxcbiAgICAgIHBhZGRpbmc6IGNhbGN1bGF0ZWRQcm9wcy5wYWRkaW5nLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChuYW1lLCBcIi1rZXktXCIpLmNvbmNhdChpbmRleCksXG4gICAgICBzdGFuZGFsb25lOiBmYWxzZVxuICAgIH0sIGNoaWxkUHJvcHMpO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIG5ld1Byb3BzKTtcbiAgfSk7XG59XG5leHBvcnQgdmFyIGdldENoaWxkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChwcm9wcywgZGVmYXVsdEF4ZXMpIHtcbiAgdmFyIGNoaWxkQ29tcG9uZW50cyA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXG4gIHZhciBuZXdDaGlsZENvbXBvbmVudHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGRDb21wb25lbnRzKTtcblxuICBpZiAoY2hpbGRDb21wb25lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIG5ld0NoaWxkQ29tcG9uZW50cy5wdXNoKGRlZmF1bHRBeGVzLmluZGVwZW5kZW50LCBkZWZhdWx0QXhlcy5kZXBlbmRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBheGlzQ29tcG9uZW50cyA9IHtcbiAgICAgIGRlcGVuZGVudDogQXhpcy5nZXRBeGlzQ29tcG9uZW50c1dpdGhQYXJlbnQoY2hpbGRDb21wb25lbnRzLCBcImRlcGVuZGVudFwiKSxcbiAgICAgIGluZGVwZW5kZW50OiBBeGlzLmdldEF4aXNDb21wb25lbnRzV2l0aFBhcmVudChjaGlsZENvbXBvbmVudHMsIFwiaW5kZXBlbmRlbnRcIilcbiAgICB9O1xuXG4gICAgaWYgKGF4aXNDb21wb25lbnRzLmRlcGVuZGVudC5sZW5ndGggPT09IDAgJiYgYXhpc0NvbXBvbmVudHMuaW5kZXBlbmRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXdDaGlsZENvbXBvbmVudHMgPSBwcm9wcy5wcmVwZW5kRGVmYXVsdEF4ZXMgPyBbZGVmYXVsdEF4ZXMuaW5kZXBlbmRlbnQsIGRlZmF1bHRBeGVzLmRlcGVuZGVudF0uY29uY2F0KG5ld0NoaWxkQ29tcG9uZW50cykgOiBuZXdDaGlsZENvbXBvbmVudHMuY29uY2F0KFtkZWZhdWx0QXhlcy5pbmRlcGVuZGVudCwgZGVmYXVsdEF4ZXMuZGVwZW5kZW50XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0NoaWxkQ29tcG9uZW50cztcbn07XG5cbnZhciBnZXREb21haW4gPSBmdW5jdGlvbiAocHJvcHMsIGF4aXMsIGNoaWxkQ29tcG9uZW50cykge1xuICBjaGlsZENvbXBvbmVudHMgPSBjaGlsZENvbXBvbmVudHMgfHwgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG4gIHZhciBkb21haW4gPSBXcmFwcGVyLmdldERvbWFpbihwcm9wcywgYXhpcywgY2hpbGRDb21wb25lbnRzKTtcbiAgdmFyIGF4aXNDb21wb25lbnQgPSBBeGlzLmdldEF4aXNDb21wb25lbnQoY2hpbGRDb21wb25lbnRzLCBheGlzKTtcbiAgdmFyIGludmVydERvbWFpbiA9IGF4aXNDb21wb25lbnQgJiYgYXhpc0NvbXBvbmVudC5wcm9wcyAmJiBheGlzQ29tcG9uZW50LnByb3BzLmludmVydEF4aXM7XG4gIHJldHVybiBpbnZlcnREb21haW4gPyBkb21haW4uY29uY2F0KCkucmV2ZXJzZSgpIDogZG9tYWluO1xufTtcblxudmFyIGNyZWF0ZVN0cmluZ01hcCA9IGZ1bmN0aW9uIChwcm9wcywgY2hpbGRDb21wb25lbnRzLCBhbGxTdHJpbmdzKSB7XG4gIHZhciB4ID0gIWFsbFN0cmluZ3MueCB8fCBhbGxTdHJpbmdzLngubGVuZ3RoID09PSAwID8gbnVsbCA6IGFsbFN0cmluZ3MueC5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHN0cmluZywgaW5kZXgpIHtcbiAgICBtZW1vW3N0cmluZ10gPSBpbmRleCArIDE7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbiAgdmFyIHkgPSAhYWxsU3RyaW5ncy55IHx8IGFsbFN0cmluZ3MueS5sZW5ndGggPT09IDAgPyBudWxsIDogYWxsU3RyaW5ncy55LnJlZHVjZShmdW5jdGlvbiAobWVtbywgc3RyaW5nLCBpbmRleCkge1xuICAgIG1lbW9bc3RyaW5nXSA9IGluZGV4ICsgMTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufTsiLCJpbXBvcnQgX2lzRW1wdHkgZnJvbSBcImxvZGFzaC9pc0VtcHR5XCI7XG5pbXBvcnQgX2Fzc2lnbiBmcm9tIFwibG9kYXNoL2Fzc2lnblwiO1xuaW1wb3J0IF9kZWZhdWx0cyBmcm9tIFwibG9kYXNoL2RlZmF1bHRzXCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEJhY2tncm91bmQsIENvbW1vblByb3BzLCBIZWxwZXJzLCBIb29rcywgUHJvcFR5cGVzIGFzIEN1c3RvbVByb3BUeXBlcywgVXNlclByb3BzLCBWaWN0b3J5Q29udGFpbmVyLCBWaWN0b3J5VGhlbWUsIFdyYXBwZXIgfSBmcm9tIFwidmljdG9yeS1jb3JlXCI7XG5pbXBvcnQgeyBWaWN0b3J5U2hhcmVkRXZlbnRzIH0gZnJvbSBcInZpY3Rvcnktc2hhcmVkLWV2ZW50c1wiO1xuaW1wb3J0IHsgVmljdG9yeUF4aXMgfSBmcm9tIFwidmljdG9yeS1heGlzXCI7XG5pbXBvcnQgeyBWaWN0b3J5UG9sYXJBeGlzIH0gZnJvbSBcInZpY3RvcnktcG9sYXItYXhpc1wiO1xuaW1wb3J0IHsgZ2V0QmFja2dyb3VuZFdpdGhQcm9wcywgZ2V0Q2hpbGRDb21wb25lbnRzLCBnZXRDYWxjdWxhdGVkUHJvcHMsIGdldENoaWxkcmVuIH0gZnJvbSBcIi4vaGVscGVyLW1ldGhvZHNcIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJyZWFjdC1mYXN0LWNvbXBhcmVcIjtcbnZhciBmYWxsYmFja1Byb3BzID0ge1xuICB3aWR0aDogNDUwLFxuICBoZWlnaHQ6IDMwMCxcbiAgcGFkZGluZzogNTBcbn07XG5cbnZhciBWaWN0b3J5Q2hhcnRJbXBsID0gZnVuY3Rpb24gKGluaXRpYWxQcm9wcykge1xuICB2YXIgcm9sZSA9IFwiY2hhcnRcIjtcblxuICB2YXIgX0hvb2tzJHVzZUFuaW1hdGlvblN0ID0gSG9va3MudXNlQW5pbWF0aW9uU3RhdGUoKSxcbiAgICAgIGdldEFuaW1hdGlvblByb3BzID0gX0hvb2tzJHVzZUFuaW1hdGlvblN0LmdldEFuaW1hdGlvblByb3BzLFxuICAgICAgc2V0QW5pbWF0aW9uU3RhdGUgPSBfSG9va3MkdXNlQW5pbWF0aW9uU3Quc2V0QW5pbWF0aW9uU3RhdGUsXG4gICAgICBnZXRQcm9wcyA9IF9Ib29rcyR1c2VBbmltYXRpb25TdC5nZXRQcm9wcztcblxuICB2YXIgcHJvcHMgPSBnZXRQcm9wcyhpbml0aWFsUHJvcHMpO1xuICB2YXIgbW9kaWZpZWRQcm9wcyA9IEhlbHBlcnMubW9kaWZ5UHJvcHMocHJvcHMsIGZhbGxiYWNrUHJvcHMsIHJvbGUpO1xuICB2YXIgZGVzYyA9IG1vZGlmaWVkUHJvcHMuZGVzYyxcbiAgICAgIGV2ZW50S2V5ID0gbW9kaWZpZWRQcm9wcy5ldmVudEtleSxcbiAgICAgIGNvbnRhaW5lckNvbXBvbmVudCA9IG1vZGlmaWVkUHJvcHMuY29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgc3RhbmRhbG9uZSA9IG1vZGlmaWVkUHJvcHMuc3RhbmRhbG9uZSxcbiAgICAgIGdyb3VwQ29tcG9uZW50ID0gbW9kaWZpZWRQcm9wcy5ncm91cENvbXBvbmVudCxcbiAgICAgIGV4dGVybmFsRXZlbnRNdXRhdGlvbnMgPSBtb2RpZmllZFByb3BzLmV4dGVybmFsRXZlbnRNdXRhdGlvbnMsXG4gICAgICB3aWR0aCA9IG1vZGlmaWVkUHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBtb2RpZmllZFByb3BzLmhlaWdodCxcbiAgICAgIHRoZW1lID0gbW9kaWZpZWRQcm9wcy50aGVtZSxcbiAgICAgIHBvbGFyID0gbW9kaWZpZWRQcm9wcy5wb2xhcixcbiAgICAgIG5hbWUgPSBtb2RpZmllZFByb3BzLm5hbWUsXG4gICAgICB0aXRsZSA9IG1vZGlmaWVkUHJvcHMudGl0bGU7XG4gIHZhciBheGVzID0gcHJvcHMucG9sYXIgPyBtb2RpZmllZFByb3BzLmRlZmF1bHRQb2xhckF4ZXMgOiBtb2RpZmllZFByb3BzLmRlZmF1bHRBeGVzO1xuICB2YXIgY2hpbGRDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldENoaWxkQ29tcG9uZW50cyhtb2RpZmllZFByb3BzLCBheGVzKTtcbiAgfSwgW21vZGlmaWVkUHJvcHMsIGF4ZXNdKTtcbiAgdmFyIGNhbGN1bGF0ZWRQcm9wcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRDYWxjdWxhdGVkUHJvcHMobW9kaWZpZWRQcm9wcywgY2hpbGRDb21wb25lbnRzKTtcbiAgfSwgW21vZGlmaWVkUHJvcHMsIGNoaWxkQ29tcG9uZW50c10pO1xuICB2YXIgZG9tYWluID0gY2FsY3VsYXRlZFByb3BzLmRvbWFpbixcbiAgICAgIHNjYWxlID0gY2FsY3VsYXRlZFByb3BzLnNjYWxlLFxuICAgICAgc3R5bGUgPSBjYWxjdWxhdGVkUHJvcHMuc3R5bGUsXG4gICAgICBvcmlnaW4gPSBjYWxjdWxhdGVkUHJvcHMub3JpZ2luLFxuICAgICAgaG9yaXpvbnRhbCA9IGNhbGN1bGF0ZWRQcm9wcy5ob3Jpem9udGFsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihwcm9wcywgY2hpbGRDb21wb25lbnRzLCBjYWxjdWxhdGVkUHJvcHMpO1xuICAgIHZhciBtYXBwZWRDaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGRQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICBhbmltYXRlOiBnZXRBbmltYXRpb25Qcm9wcyhwcm9wcywgY2hpbGQsIGluZGV4KVxuICAgICAgfSwgY2hpbGQucHJvcHMpO1xuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcHMuc3R5bGUgJiYgcHJvcHMuc3R5bGUuYmFja2dyb3VuZCkge1xuICAgICAgdmFyIGJhY2tncm91bmRDb21wb25lbnQgPSBnZXRCYWNrZ3JvdW5kV2l0aFByb3BzKHByb3BzLCBjYWxjdWxhdGVkUHJvcHMpO1xuICAgICAgbWFwcGVkQ2hpbGRyZW4udW5zaGlmdChiYWNrZ3JvdW5kQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGVkQ2hpbGRyZW47XG4gIH0sIFtnZXRBbmltYXRpb25Qcm9wcywgY2hpbGRDb21wb25lbnRzLCBwcm9wcywgY2FsY3VsYXRlZFByb3BzXSk7XG4gIHZhciBjb250YWluZXJQcm9wcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXNjOiBkZXNjLFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luOiBwb2xhciA/IG9yaWdpbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9sYXI6IHBvbGFyLFxuICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBzdGFuZGFsb25lOiBzdGFuZGFsb25lLFxuICAgICAgICBzdHlsZTogc3R5bGUucGFyZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfSwgW2Rlc2MsIGRvbWFpbiwgaGVpZ2h0LCBob3Jpem9udGFsLCBuYW1lLCBvcmlnaW4sIHBvbGFyLCBzY2FsZSwgc3RhbmRhbG9uZSwgc3R5bGUsIHRpdGxlLCB0aGVtZSwgd2lkdGhdKTtcbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGFuZGFsb25lKSB7XG4gICAgICB2YXIgZGVmYXVsdENvbnRhaW5lclByb3BzID0gX2RlZmF1bHRzKHt9LCBjb250YWluZXJDb21wb25lbnQucHJvcHMsIGNvbnRhaW5lclByb3BzLCBVc2VyUHJvcHMuZ2V0U2FmZVVzZXJQcm9wcyhpbml0aWFsUHJvcHMpKTtcblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY29udGFpbmVyQ29tcG9uZW50LCBkZWZhdWx0Q29udGFpbmVyUHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cENvbXBvbmVudDtcbiAgfSwgW2dyb3VwQ29tcG9uZW50LCBzdGFuZGFsb25lLCBjb250YWluZXJDb21wb25lbnQsIGNvbnRhaW5lclByb3BzLCBpbml0aWFsUHJvcHNdKTtcbiAgdmFyIGV2ZW50cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBXcmFwcGVyLmdldEFsbEV2ZW50cyhwcm9wcyk7XG4gIH0sIFtwcm9wc10pO1xuICB2YXIgcHJldmlvdXNQcm9wcyA9IEhvb2tzLnVzZVByZXZpb3VzUHJvcHMoaW5pdGlhbFByb3BzKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgZGlzbW91bnQgdG8ga2VlcCBzdGF0ZSBpbiBzeW5jXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbml0aWFsUHJvcHMuYW5pbWF0ZSkge1xuICAgICAgICBzZXRBbmltYXRpb25TdGF0ZShwcmV2aW91c1Byb3BzLCBpbml0aWFsUHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtzZXRBbmltYXRpb25TdGF0ZSwgcHJldmlvdXNQcm9wcywgaW5pdGlhbFByb3BzXSk7XG5cbiAgaWYgKCFfaXNFbXB0eShldmVudHMpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlTaGFyZWRFdmVudHMsIHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgZXZlbnRLZXk6IGV2ZW50S2V5LFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBleHRlcm5hbEV2ZW50TXV0YXRpb25zOiBleHRlcm5hbEV2ZW50TXV0YXRpb25zXG4gICAgfSwgbmV3Q2hpbGRyZW4pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY29udGFpbmVyLCBjb250YWluZXIucHJvcHMsIG5ld0NoaWxkcmVuKTtcbn07XG5cblZpY3RvcnlDaGFydEltcGwucHJvcFR5cGVzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBDb21tb25Qcm9wcy5iYXNlUHJvcHMpLCB7fSwge1xuICBiYWNrZ3JvdW5kQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKSwgUHJvcFR5cGVzLm5vZGVdKSxcbiAgZGVmYXVsdEF4ZXM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaW5kZXBlbmRlbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICAgIGRlcGVuZGVudDogUHJvcFR5cGVzLmVsZW1lbnRcbiAgfSksXG4gIGRlZmF1bHRQb2xhckF4ZXM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaW5kZXBlbmRlbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICAgIGRlcGVuZGVudDogUHJvcFR5cGVzLmVsZW1lbnRcbiAgfSksXG4gIGVuZEFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBpbm5lclJhZGl1czogQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlLFxuICBwcmVwZW5kRGVmYXVsdEF4ZXM6IFByb3BUeXBlcy5ib29sLFxuICBzdGFydEFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyXG59KTtcblZpY3RvcnlDaGFydEltcGwuZGVmYXVsdFByb3BzID0ge1xuICBiYWNrZ3JvdW5kQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCYWNrZ3JvdW5kLCBudWxsKSxcbiAgY29udGFpbmVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5Q29udGFpbmVyLCBudWxsKSxcbiAgZGVmYXVsdEF4ZXM6IHtcbiAgICBpbmRlcGVuZGVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUF4aXMsIG51bGwpLFxuICAgIGRlcGVuZGVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUF4aXMsIHtcbiAgICAgIGRlcGVuZGVudEF4aXM6IHRydWVcbiAgICB9KVxuICB9LFxuICBkZWZhdWx0UG9sYXJBeGVzOiB7XG4gICAgaW5kZXBlbmRlbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlQb2xhckF4aXMsIG51bGwpLFxuICAgIGRlcGVuZGVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeVBvbGFyQXhpcywge1xuICAgICAgZGVwZW5kZW50QXhpczogdHJ1ZVxuICAgIH0pXG4gIH0sXG4gIGdyb3VwQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCksXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIHRoZW1lOiBWaWN0b3J5VGhlbWUuZ3JheXNjYWxlXG59O1xuZXhwb3J0IHZhciBWaWN0b3J5Q2hhcnQgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhWaWN0b3J5Q2hhcnRJbXBsLCBpc0VxdWFsKTtcblZpY3RvcnlDaGFydC5kaXNwbGF5TmFtZSA9IFwiVmljdG9yeUNoYXJ0XCI7IC8vIEB0cy1leHBlY3QtZXJyb3IgRklYTUU6IERvZXMgdGhpcyBcImV4cGVjdGVkQ29tcG9uZW50c1wiIGRvIGFueXRoaW5nP1xuXG5WaWN0b3J5Q2hhcnQuZXhwZWN0ZWRDb21wb25lbnRzID0gW1wiZ3JvdXBDb21wb25lbnRcIiwgXCJjb250YWluZXJDb21wb25lbnRcIl07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59908\n')}}]);