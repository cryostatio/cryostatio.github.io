"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[930],{10556:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": () => (/* binding */ victory_voronoi_container)\n});\n\n// UNUSED EXPORTS: voronoiContainerMixin\n\n// EXTERNAL MODULE: ./node_modules/lodash/pick.js\nvar pick = __webpack_require__(78718);\nvar pick_default = /*#__PURE__*/__webpack_require__.n(pick);\n// EXTERNAL MODULE: ./node_modules/lodash/isFunction.js\nvar isFunction = __webpack_require__(23560);\nvar isFunction_default = /*#__PURE__*/__webpack_require__.n(isFunction);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/victory-tooltip/es/victory-tooltip.js + 1 modules\nvar victory_tooltip = __webpack_require__(77013);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/lodash/isRegExp.js\nvar isRegExp = __webpack_require__(96347);\nvar isRegExp_default = /*#__PURE__*/__webpack_require__.n(isRegExp);\n// EXTERNAL MODULE: ./node_modules/lodash/isString.js\nvar isString = __webpack_require__(47037);\nvar isString_default = /*#__PURE__*/__webpack_require__.n(isString);\n// EXTERNAL MODULE: ./node_modules/lodash/includes.js\nvar includes = __webpack_require__(64721);\nvar includes_default = /*#__PURE__*/__webpack_require__.n(includes);\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__(41609);\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n// EXTERNAL MODULE: ./node_modules/lodash/throttle.js\nvar throttle = __webpack_require__(23493);\nvar throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/collection.js\nvar collection = __webpack_require__(24690);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/data.js + 1 modules\nvar victory_util_data = __webpack_require__(26063);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/selection.js\nvar selection = __webpack_require__(71955);\n// EXTERNAL MODULE: ./node_modules/react-fast-compare/index.js\nvar react_fast_compare = __webpack_require__(69590);\nvar react_fast_compare_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare);\n// EXTERNAL MODULE: ./node_modules/delaunay-find/lib/index.js\nvar lib = __webpack_require__(33759);\n;// CONCATENATED MODULE: ./node_modules/victory-voronoi-container/es/voronoi-helpers.js\n\n\n\n\n\n\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\nvar VoronoiHelpers = {\n  withinBounds: function (props, point) {\n    var width = props.width,\n        height = props.height,\n        polar = props.polar,\n        origin = props.origin,\n        scale = props.scale;\n    var padding = helpers/* getPadding */.tQ(props, "voronoiPadding");\n    var x = point.x,\n        y = point.y;\n\n    if (polar) {\n      var distanceSquared = Math.pow(x - origin.x, 2) + Math.pow(y - origin.y, 2);\n      var radius = Math.max.apply(Math, _toConsumableArray(scale.y.range()));\n      return distanceSquared < Math.pow(radius, 2);\n    }\n\n    return x >= padding.left && x <= width - padding.right && y >= padding.top && y <= height - padding.bottom;\n  },\n  getDatasets: function (props) {\n    var minDomain = {\n      x: collection/* getMinValue */.ao(props.domain.x),\n      y: collection/* getMinValue */.ao(props.domain.y)\n    };\n    var children = react.Children.toArray(props.children);\n\n    var addMeta = function (data, name, child) {\n      var continuous = child && child.type && child.type.continuous;\n      var style = child ? child.props && child.props.style : props.style;\n      return data.map(function (datum, index) {\n        var _Helpers$getPoint = helpers/* getPoint */.F8(datum),\n            x = _Helpers$getPoint.x,\n            y = _Helpers$getPoint.y,\n            y0 = _Helpers$getPoint.y0,\n            x0 = _Helpers$getPoint.x0;\n\n        var voronoiX = (Number(x) + Number(x0)) / 2;\n        var voronoiY = (Number(y) + Number(y0)) / 2;\n        return assign_default()({\n          _voronoiX: props.voronoiDimension === "y" ? minDomain.x : voronoiX,\n          _voronoiY: props.voronoiDimension === "x" ? minDomain.y : voronoiY,\n          eventKey: index,\n          childName: name,\n          continuous: continuous,\n          style: style\n        }, datum);\n      });\n    };\n\n    if (props.data) {\n      return addMeta(props.data);\n    }\n\n    var getData = function (childProps) {\n      var data = victory_util_data/* getData */.Yu(childProps);\n      return Array.isArray(data) && data.length > 0 ? data : undefined;\n    };\n\n    var iteratee = function (child, childName) {\n      var childProps = child.props || {};\n      var name = childProps.name || childName;\n      var blacklist = props.voronoiBlacklist || [];\n      var blacklistStr = blacklist.filter((isString_default()));\n      var blacklistRegExp = blacklist.filter((isRegExp_default()));\n      var isRegExpMatch = blacklistRegExp.some(function (regExp) {\n        return regExp.test(name);\n      });\n\n      if (!victory_util_data/* isDataComponent */.hi(child) || includes_default()(blacklistStr, name) || isRegExpMatch) {\n        return null;\n      }\n\n      var getChildData = child.type && isFunction_default()(child.type.getData) ? child.type.getData : getData;\n      var childData = getChildData(child.props);\n      return childData ? addMeta(childData, name, child) : null;\n    };\n\n    return helpers/* reduceChildren */.F1(children, iteratee, props);\n  },\n  findPoints: function (datasets, point) {\n    return datasets.filter(function (d) {\n      return point._voronoiX === d._voronoiX && point._voronoiY === d._voronoiY;\n    });\n  },\n  withinRadius: function (point, mousePosition, radius) {\n    if (!point) {\n      return false;\n    }\n\n    if (!radius) {\n      return true;\n    }\n\n    var x = mousePosition.x,\n        y = mousePosition.y;\n    var distanceSquared = Math.pow(x - point[0], 2) + Math.pow(y - point[1], 2);\n    return distanceSquared < Math.pow(radius, 2);\n  },\n  getVoronoiPoints: function (props, mousePosition) {\n    var datasets = this.getDatasets(props);\n    var scaledData = datasets.map(function (d) {\n      var _Helpers$scalePoint = helpers/* scalePoint */.q2(props, d),\n          x = _Helpers$scalePoint.x,\n          y = _Helpers$scalePoint.y;\n\n      return [x, y];\n    });\n    var delaunay = lib/* default.from */.Z.from(scaledData);\n    var index = delaunay.find(mousePosition.x, mousePosition.y);\n    var withinRadius = this.withinRadius(scaledData[index], mousePosition, props.radius);\n    var points = withinRadius ? this.findPoints(datasets, datasets[index]) : [];\n    return {\n      points: points,\n      index: index\n    };\n  },\n  getActiveMutations: function (props, point) {\n    var childName = point.childName,\n        continuous = point.continuous;\n    var activateData = props.activateData,\n        activateLabels = props.activateLabels,\n        labels = props.labels;\n\n    if (!activateData && !activateLabels) {\n      return [];\n    }\n\n    var defaultTarget = activateData ? ["data"] : [];\n    var targets = labels && !activateLabels ? defaultTarget : defaultTarget.concat("labels");\n\n    if (isEmpty_default()(targets)) {\n      return [];\n    }\n\n    return targets.map(function (target) {\n      var eventKey = continuous === true && target === "data" ? "all" : point.eventKey;\n      return {\n        childName: childName,\n        eventKey: eventKey,\n        target: target,\n        mutation: function () {\n          return {\n            active: true\n          };\n        }\n      };\n    });\n  },\n  getInactiveMutations: function (props, point) {\n    var childName = point.childName,\n        continuous = point.continuous;\n    var activateData = props.activateData,\n        activateLabels = props.activateLabels,\n        labels = props.labels;\n\n    if (!activateData && !activateLabels) {\n      return [];\n    }\n\n    var defaultTarget = activateData ? ["data"] : [];\n    var targets = labels && !activateLabels ? defaultTarget : defaultTarget.concat("labels");\n\n    if (isEmpty_default()(targets)) {\n      return [];\n    }\n\n    return targets.map(function (target) {\n      var eventKey = continuous && target === "data" ? "all" : point.eventKey;\n      return {\n        childName: childName,\n        eventKey: eventKey,\n        target: target,\n        mutation: function () {\n          return null;\n        }\n      };\n    });\n  },\n  // eslint-disable-next-line max-params\n  getParentMutation: function (activePoints, mousePosition, parentSVG, vIndex) {\n    return [{\n      target: "parent",\n      eventKey: "parent",\n      mutation: function () {\n        return {\n          activePoints: activePoints,\n          mousePosition: mousePosition,\n          parentSVG: parentSVG,\n          vIndex: vIndex\n        };\n      }\n    }];\n  },\n  onActivated: function (props, points) {\n    if (isFunction_default()(props.onActivated)) {\n      props.onActivated(points, props);\n    }\n  },\n  onDeactivated: function (props, points) {\n    if (isFunction_default()(props.onDeactivated)) {\n      props.onDeactivated(points, props);\n    }\n  },\n  onMouseLeave: function (evt, targetProps) {\n    var _this = this,\n        _this$getParentMutati;\n\n    var activePoints = targetProps.activePoints || [];\n    this.onDeactivated(targetProps, activePoints);\n    var inactiveMutations = activePoints.length ? activePoints.map(function (point) {\n      return _this.getInactiveMutations(targetProps, point);\n    }) : [];\n    return (_this$getParentMutati = this.getParentMutation([])).concat.apply(_this$getParentMutati, _toConsumableArray(inactiveMutations));\n  },\n  onMouseMove: function (evt, targetProps) {\n    var _this2 = this;\n\n    // eslint-disable-line max-statements\n    var activePoints = targetProps.activePoints || [];\n    var parentSVG = targetProps.parentSVG || selection/* getParentSVG */.IK(evt);\n    var mousePosition = selection/* getSVGEventCoordinates */.ZA(evt, parentSVG);\n\n    if (!this.withinBounds(targetProps, mousePosition)) {\n      var _this$getParentMutati2;\n\n      this.onDeactivated(targetProps, activePoints);\n\n      var _inactiveMutations = activePoints.length ? activePoints.map(function (point) {\n        return _this2.getInactiveMutations(targetProps, point);\n      }) : [];\n\n      return (_this$getParentMutati2 = this.getParentMutation([], mousePosition, parentSVG)).concat.apply(_this$getParentMutati2, _toConsumableArray(_inactiveMutations));\n    }\n\n    var _this$getVoronoiPoint = this.getVoronoiPoints(targetProps, mousePosition),\n        _this$getVoronoiPoint2 = _this$getVoronoiPoint.points,\n        points = _this$getVoronoiPoint2 === void 0 ? [] : _this$getVoronoiPoint2,\n        index = _this$getVoronoiPoint.index;\n\n    var parentMutations = this.getParentMutation(points, mousePosition, parentSVG, index);\n\n    if (activePoints.length && react_fast_compare_default()(points, activePoints)) {\n      return parentMutations;\n    }\n\n    this.onActivated(targetProps, points);\n    this.onDeactivated(targetProps, activePoints);\n    var activeMutations = points.length ? points.map(function (point) {\n      return _this2.getActiveMutations(targetProps, point);\n    }) : [];\n    var inactiveMutations = activePoints.length ? activePoints.map(function (point) {\n      return _this2.getInactiveMutations(targetProps, point);\n    }) : [];\n    return parentMutations.concat.apply(parentMutations, _toConsumableArray(inactiveMutations).concat(_toConsumableArray(activeMutations)));\n  }\n};\n/* harmony default export */ const voronoi_helpers = ({\n  onMouseLeave: VoronoiHelpers.onMouseLeave.bind(VoronoiHelpers),\n  onMouseMove: throttle_default()(VoronoiHelpers.onMouseMove.bind(VoronoiHelpers), 32, // eslint-disable-line no-magic-numbers\n  {\n    leading: true,\n    trailing: false\n  })\n});\n;// CONCATENATED MODULE: ./node_modules/victory-voronoi-container/es/victory-voronoi-container.js\n\n\n\nvar _excluded = ["childName", "eventKey", "style", "continuous"];\n\nfunction victory_voronoi_container_toConsumableArray(arr) { return victory_voronoi_container_arrayWithoutHoles(arr) || victory_voronoi_container_iterableToArray(arr) || victory_voronoi_container_unsupportedIterableToArray(arr) || victory_voronoi_container_nonIterableSpread(); }\n\nfunction victory_voronoi_container_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction victory_voronoi_container_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return victory_voronoi_container_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return victory_voronoi_container_arrayLikeToArray(o, minLen); }\n\nfunction victory_voronoi_container_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction victory_voronoi_container_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return victory_voronoi_container_arrayLikeToArray(arr); }\n\nfunction victory_voronoi_container_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/* eslint-disable react/no-multi-comp */\n\n\n\n\n\nvar voronoiContainerMixin = function (base) {\n  var _class;\n\n  return _class = /*#__PURE__*/function (_base) {\n    _inherits(VictoryVoronoiContainer, _base);\n\n    var _super = _createSuper(VictoryVoronoiContainer);\n\n    function VictoryVoronoiContainer() {\n      _classCallCheck(this, VictoryVoronoiContainer);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(VictoryVoronoiContainer, [{\n      key: "getDimension",\n      value: function getDimension(props) {\n        var horizontal = props.horizontal,\n            voronoiDimension = props.voronoiDimension;\n\n        if (!horizontal || !voronoiDimension) {\n          return voronoiDimension;\n        }\n\n        return voronoiDimension === "x" ? "y" : "x";\n      }\n    }, {\n      key: "getPoint",\n      value: function getPoint(point) {\n        var whitelist = ["_x", "_x1", "_x0", "_y", "_y1", "_y0"];\n        return pick_default()(point, whitelist);\n      }\n    }, {\n      key: "getLabelPosition",\n      value: function getLabelPosition(props, labelProps, points) {\n        var mousePosition = props.mousePosition,\n            mouseFollowTooltips = props.mouseFollowTooltips;\n        var voronoiDimension = this.getDimension(props);\n        var point = this.getPoint(points[0]);\n        var basePosition = helpers/* scalePoint */.q2(props, point);\n        var center = mouseFollowTooltips ? mousePosition : undefined;\n\n        if (!voronoiDimension || points.length < 2) {\n          return _objectSpread(_objectSpread({}, basePosition), {}, {\n            center: defaults_default()({}, labelProps.center, center)\n          });\n        }\n\n        var x = voronoiDimension === "y" ? mousePosition.x : basePosition.x;\n        var y = voronoiDimension === "x" ? mousePosition.y : basePosition.y;\n        center = mouseFollowTooltips ? mousePosition : {\n          x: x,\n          y: y\n        };\n        return {\n          x: x,\n          y: y,\n          center: defaults_default()({}, labelProps.center, center)\n        };\n      }\n    }, {\n      key: "getStyle",\n      value: function getStyle(props, points, type) {\n        var labels = props.labels,\n            labelComponent = props.labelComponent,\n            theme = props.theme;\n        var componentProps = labelComponent.props || {};\n        var themeStyles = theme && theme.voronoi && theme.voronoi.style ? theme.voronoi.style : {};\n        var componentStyleArray = type === "flyout" ? componentProps.flyoutStyle : componentProps.style;\n        return points.reduce(function (memo, datum, index) {\n          var labelProps = defaults_default()({}, componentProps, {\n            datum: datum,\n            active: true\n          });\n\n          var text = isFunction_default()(labels) ? labels(labelProps) : undefined;\n          var textArray = text !== undefined ? "".concat(text).split("\\n") : [];\n          var baseStyle = datum.style && datum.style[type] || {};\n          var componentStyle = Array.isArray(componentStyleArray) ? componentStyleArray[index] : componentStyleArray;\n          var style = helpers/* evaluateStyle */.F3(defaults_default()({}, componentStyle, baseStyle, themeStyles[type]), labelProps);\n          var styleArray = textArray.length ? textArray.map(function () {\n            return style;\n          }) : [style];\n          memo = memo.concat(styleArray);\n          return memo;\n        }, []);\n      }\n    }, {\n      key: "getDefaultLabelProps",\n      value: function getDefaultLabelProps(props, points) {\n        var voronoiDimension = props.voronoiDimension,\n            horizontal = props.horizontal,\n            mouseFollowTooltips = props.mouseFollowTooltips;\n        var point = this.getPoint(points[0]);\n        var multiPoint = voronoiDimension && points.length > 1;\n        var y = point._y1 !== undefined ? point._y1 : point._y;\n        var defaultHorizontalOrientation = y < 0 ? "left" : "right";\n        var defaultOrientation = y < 0 ? "bottom" : "top";\n        var labelOrientation = horizontal ? defaultHorizontalOrientation : defaultOrientation;\n        var orientation = mouseFollowTooltips ? undefined : labelOrientation;\n        return {\n          orientation: orientation,\n          pointerLength: multiPoint ? 0 : undefined,\n          constrainToVisibleArea: multiPoint || mouseFollowTooltips ? true : undefined\n        };\n      }\n    }, {\n      key: "getLabelProps",\n      value: function getLabelProps(props, points) {\n        var labels = props.labels,\n            scale = props.scale,\n            labelComponent = props.labelComponent,\n            theme = props.theme,\n            width = props.width,\n            height = props.height;\n        var componentProps = labelComponent.props || {};\n        var text = points.reduce(function (memo, datum) {\n          var labelProps = defaults_default()({}, componentProps, {\n            datum: datum,\n            active: true\n          });\n\n          var t = isFunction_default()(labels) ? labels(labelProps) : null;\n\n          if (t === null || t === undefined) {\n            return memo;\n          }\n\n          memo = memo.concat("".concat(t).split("\\n"));\n          return memo;\n        }, []); // remove properties from first point to make datum\n        // eslint-disable-next-line no-unused-vars\n\n        var _points$ = points[0],\n            childName = _points$.childName,\n            eventKey = _points$.eventKey,\n            style = _points$.style,\n            continuous = _points$.continuous,\n            datum = _objectWithoutProperties(_points$, _excluded);\n\n        var name = props.name === childName ? childName : "".concat(props.name, "-").concat(childName);\n\n        var labelProps = defaults_default()({\n          key: "".concat(name, "-").concat(eventKey, "-voronoi-tooltip"),\n          id: "".concat(name, "-").concat(eventKey, "-voronoi-tooltip"),\n          active: true,\n          renderInPortal: false,\n          activePoints: points,\n          datum: datum,\n          scale: scale,\n          theme: theme\n        }, componentProps, {\n          text: text,\n          width: width,\n          height: height,\n          style: this.getStyle(props, points, "labels"),\n          flyoutStyle: this.getStyle(props, points, "flyout")[0]\n        }, this.getDefaultLabelProps(props, points));\n\n        var labelPosition = this.getLabelPosition(props, labelProps, points);\n        return defaults_default()({}, labelPosition, labelProps);\n      }\n    }, {\n      key: "getTooltip",\n      value: function getTooltip(props) {\n        var labels = props.labels,\n            activePoints = props.activePoints,\n            labelComponent = props.labelComponent;\n\n        if (!labels) {\n          return null;\n        }\n\n        if (Array.isArray(activePoints) && activePoints.length) {\n          var labelProps = this.getLabelProps(props, activePoints);\n          var text = labelProps.text;\n          var showLabel = Array.isArray(text) ? text.filter(Boolean).length : text;\n          return showLabel ? /*#__PURE__*/react.cloneElement(labelComponent, labelProps) : null;\n        }\n\n        return null;\n      } // Overrides method in VictoryContainer\n\n    }, {\n      key: "getChildren",\n      value: function getChildren(props) {\n        return [].concat(victory_voronoi_container_toConsumableArray(react.Children.toArray(props.children)), [this.getTooltip(props)]);\n      }\n    }]);\n\n    return VictoryVoronoiContainer;\n  }(base), _class.displayName = "VictoryVoronoiContainer", _class.propTypes = _objectSpread(_objectSpread({}, victory_container/* VictoryContainer.propTypes */._.propTypes), {}, {\n    activateData: (prop_types_default()).bool,\n    activateLabels: (prop_types_default()).bool,\n    disable: (prop_types_default()).bool,\n    labelComponent: (prop_types_default()).element,\n    labels: (prop_types_default()).func,\n    mouseFollowTooltips: (prop_types_default()).bool,\n    onActivated: (prop_types_default()).func,\n    onDeactivated: (prop_types_default()).func,\n    radius: (prop_types_default()).number,\n    voronoiBlacklist: prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).string, victory_util_prop_types/* regExp */.bO])),\n    voronoiDimension: prop_types_default().oneOf(["x", "y"]),\n    voronoiPadding: prop_types_default().oneOfType([(prop_types_default()).number, prop_types_default().shape({\n      top: (prop_types_default()).number,\n      bottom: (prop_types_default()).number,\n      left: (prop_types_default()).number,\n      right: (prop_types_default()).number\n    })])\n  }), _class.defaultProps = _objectSpread(_objectSpread({}, victory_container/* VictoryContainer.defaultProps */._.defaultProps), {}, {\n    activateData: true,\n    activateLabels: true,\n    labelComponent: /*#__PURE__*/react.createElement(victory_tooltip/* default */.Z, null),\n    voronoiPadding: 5\n  }), _class.defaultEvents = function (props) {\n    return [{\n      target: "parent",\n      eventHandlers: {\n        onMouseLeave: function (evt, targetProps) {\n          return props.disable ? {} : voronoi_helpers.onMouseLeave(evt, targetProps);\n        },\n        onTouchCancel: function (evt, targetProps) {\n          return props.disable ? {} : voronoi_helpers.onMouseLeave(evt, targetProps);\n        },\n        onMouseMove: function (evt, targetProps) {\n          return props.disable ? {} : voronoi_helpers.onMouseMove(evt, targetProps);\n        },\n        onTouchMove: function (evt, targetProps) {\n          return props.disable ? {} : voronoi_helpers.onMouseMove(evt, targetProps);\n        }\n      }\n    }, {\n      target: "data",\n      eventHandlers: props.disable ? {} : {\n        onMouseOver: function () {\n          return null;\n        },\n        onMouseOut: function () {\n          return null;\n        },\n        onMouseMove: function () {\n          return null;\n        }\n      }\n    }];\n  }, _class;\n};\n/* harmony default export */ const victory_voronoi_container = (voronoiContainerMixin(victory_container/* VictoryContainer */._)); // @ts-expect-error IMPORTANT: when converting this file to TypeScript, you must export the type as well:\n// export const VictoryVoronoiContainer = voronoiContainerMixin(VictoryContainer);\n// export type VictoryVoronoiContainer = typeof VictoryVoronoiContainer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW1CLDJCQUFjO0FBQ2pDLFlBQVksNkJBQWdCO0FBQzVCLHNCQUFzQiw0QkFBaUIsQ0FBQyw4QkFBbUIsRUFBRSw2QkFBZ0IsRUFBRSxzQ0FBc0I7QUFDckcsc0JBQXNCLDBCQUFlO0FBQ3JDLG9CQUFvQiw4QkFBbUIsRUFBRSw2QkFBZ0IsRUFBRSwwQkFBZTtBQUMxRSxXQUFXLDZCQUFnQjtBQUMzQixjQUFjLDZCQUFnQjtBQUM5QixZQUFZLDZCQUFnQjtBQUM1QixhQUFhLDZCQUFnQjtBQUM3QixLQUFLO0FBQ0wsR0FBRyx1REFBdUQsRUFBRSxtRUFBNkIsS0FBSztBQUM5RjtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQixDQUFDLDhCQUFjO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsNEJBQTJCO0FBQ2pFLFNBQVM7QUFDVDtBQUNBLG9DQUFvQyxFQUFFLDRCQUEyQjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQSxvQ0FBb0MsRUFBRSwyQkFBMEI7QUFDaEUsU0FBUztBQUNUO0FBQ0Esb0NBQW9DLEVBQUUsMkJBQTBCO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLGdFQUFlLHNCQUFzQix5Q0FBZ0IsQ0FBQyxFQUFDLENBQUM7QUFDeEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LXZvcm9ub2ktY29udGFpbmVyL2VzL3Zvcm9ub2ktaGVscGVycy5qcz9hNWQ0Iiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LXZvcm9ub2ktY29udGFpbmVyL2VzL3ZpY3Rvcnktdm9yb25vaS1jb250YWluZXIuanM/OGI4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2lzUmVnRXhwIGZyb20gXCJsb2Rhc2gvaXNSZWdFeHBcIjtcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSBcImxvZGFzaC9pc1N0cmluZ1wiO1xuaW1wb3J0IF9pbmNsdWRlcyBmcm9tIFwibG9kYXNoL2luY2x1ZGVzXCI7XG5pbXBvcnQgX2lzRW1wdHkgZnJvbSBcImxvZGFzaC9pc0VtcHR5XCI7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSBcImxvZGFzaC9pc0Z1bmN0aW9uXCI7XG5pbXBvcnQgX3Rocm90dGxlIGZyb20gXCJsb2Rhc2gvdGhyb3R0bGVcIjtcbmltcG9ydCBfYXNzaWduIGZyb20gXCJsb2Rhc2gvYXNzaWduXCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuaW1wb3J0IHsgQ29sbGVjdGlvbiwgU2VsZWN0aW9uLCBEYXRhLCBIZWxwZXJzIH0gZnJvbSBcInZpY3RvcnktY29yZVwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcInJlYWN0LWZhc3QtY29tcGFyZVwiO1xuaW1wb3J0IERlbGF1bmF5IGZyb20gXCJkZWxhdW5heS1maW5kL2xpYi9pbmRleC5qc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIFZvcm9ub2lIZWxwZXJzID0ge1xuICB3aXRoaW5Cb3VuZHM6IGZ1bmN0aW9uIChwcm9wcywgcG9pbnQpIHtcbiAgICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgICBwb2xhciA9IHByb3BzLnBvbGFyLFxuICAgICAgICBvcmlnaW4gPSBwcm9wcy5vcmlnaW4sXG4gICAgICAgIHNjYWxlID0gcHJvcHMuc2NhbGU7XG4gICAgdmFyIHBhZGRpbmcgPSBIZWxwZXJzLmdldFBhZGRpbmcocHJvcHMsIFwidm9yb25vaVBhZGRpbmdcIik7XG4gICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICB5ID0gcG9pbnQueTtcblxuICAgIGlmIChwb2xhcikge1xuICAgICAgdmFyIGRpc3RhbmNlU3F1YXJlZCA9IE1hdGgucG93KHggLSBvcmlnaW4ueCwgMikgKyBNYXRoLnBvdyh5IC0gb3JpZ2luLnksIDIpO1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShzY2FsZS55LnJhbmdlKCkpKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZVNxdWFyZWQgPCBNYXRoLnBvdyhyYWRpdXMsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiB4ID49IHBhZGRpbmcubGVmdCAmJiB4IDw9IHdpZHRoIC0gcGFkZGluZy5yaWdodCAmJiB5ID49IHBhZGRpbmcudG9wICYmIHkgPD0gaGVpZ2h0IC0gcGFkZGluZy5ib3R0b207XG4gIH0sXG4gIGdldERhdGFzZXRzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbWluRG9tYWluID0ge1xuICAgICAgeDogQ29sbGVjdGlvbi5nZXRNaW5WYWx1ZShwcm9wcy5kb21haW4ueCksXG4gICAgICB5OiBDb2xsZWN0aW9uLmdldE1pblZhbHVlKHByb3BzLmRvbWFpbi55KVxuICAgIH07XG4gICAgdmFyIGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG5cbiAgICB2YXIgYWRkTWV0YSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lLCBjaGlsZCkge1xuICAgICAgdmFyIGNvbnRpbnVvdXMgPSBjaGlsZCAmJiBjaGlsZC50eXBlICYmIGNoaWxkLnR5cGUuY29udGludW91cztcbiAgICAgIHZhciBzdHlsZSA9IGNoaWxkID8gY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuc3R5bGUgOiBwcm9wcy5zdHlsZTtcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZGF0dW0sIGluZGV4KSB7XG4gICAgICAgIHZhciBfSGVscGVycyRnZXRQb2ludCA9IEhlbHBlcnMuZ2V0UG9pbnQoZGF0dW0pLFxuICAgICAgICAgICAgeCA9IF9IZWxwZXJzJGdldFBvaW50LngsXG4gICAgICAgICAgICB5ID0gX0hlbHBlcnMkZ2V0UG9pbnQueSxcbiAgICAgICAgICAgIHkwID0gX0hlbHBlcnMkZ2V0UG9pbnQueTAsXG4gICAgICAgICAgICB4MCA9IF9IZWxwZXJzJGdldFBvaW50LngwO1xuXG4gICAgICAgIHZhciB2b3Jvbm9pWCA9IChOdW1iZXIoeCkgKyBOdW1iZXIoeDApKSAvIDI7XG4gICAgICAgIHZhciB2b3Jvbm9pWSA9IChOdW1iZXIoeSkgKyBOdW1iZXIoeTApKSAvIDI7XG4gICAgICAgIHJldHVybiBfYXNzaWduKHtcbiAgICAgICAgICBfdm9yb25vaVg6IHByb3BzLnZvcm9ub2lEaW1lbnNpb24gPT09IFwieVwiID8gbWluRG9tYWluLnggOiB2b3Jvbm9pWCxcbiAgICAgICAgICBfdm9yb25vaVk6IHByb3BzLnZvcm9ub2lEaW1lbnNpb24gPT09IFwieFwiID8gbWluRG9tYWluLnkgOiB2b3Jvbm9pWSxcbiAgICAgICAgICBldmVudEtleTogaW5kZXgsXG4gICAgICAgICAgY2hpbGROYW1lOiBuYW1lLFxuICAgICAgICAgIGNvbnRpbnVvdXM6IGNvbnRpbnVvdXMsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgIH0sIGRhdHVtKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAocHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuIGFkZE1ldGEocHJvcHMuZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGdldERhdGEgPSBmdW5jdGlvbiAoY2hpbGRQcm9wcykge1xuICAgICAgdmFyIGRhdGEgPSBEYXRhLmdldERhdGEoY2hpbGRQcm9wcyk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA+IDAgPyBkYXRhIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICB2YXIgaXRlcmF0ZWUgPSBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkTmFtZSkge1xuICAgICAgdmFyIGNoaWxkUHJvcHMgPSBjaGlsZC5wcm9wcyB8fCB7fTtcbiAgICAgIHZhciBuYW1lID0gY2hpbGRQcm9wcy5uYW1lIHx8IGNoaWxkTmFtZTtcbiAgICAgIHZhciBibGFja2xpc3QgPSBwcm9wcy52b3Jvbm9pQmxhY2tsaXN0IHx8IFtdO1xuICAgICAgdmFyIGJsYWNrbGlzdFN0ciA9IGJsYWNrbGlzdC5maWx0ZXIoX2lzU3RyaW5nKTtcbiAgICAgIHZhciBibGFja2xpc3RSZWdFeHAgPSBibGFja2xpc3QuZmlsdGVyKF9pc1JlZ0V4cCk7XG4gICAgICB2YXIgaXNSZWdFeHBNYXRjaCA9IGJsYWNrbGlzdFJlZ0V4cC5zb21lKGZ1bmN0aW9uIChyZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cC50ZXN0KG5hbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghRGF0YS5pc0RhdGFDb21wb25lbnQoY2hpbGQpIHx8IF9pbmNsdWRlcyhibGFja2xpc3RTdHIsIG5hbWUpIHx8IGlzUmVnRXhwTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRDaGlsZERhdGEgPSBjaGlsZC50eXBlICYmIF9pc0Z1bmN0aW9uKGNoaWxkLnR5cGUuZ2V0RGF0YSkgPyBjaGlsZC50eXBlLmdldERhdGEgOiBnZXREYXRhO1xuICAgICAgdmFyIGNoaWxkRGF0YSA9IGdldENoaWxkRGF0YShjaGlsZC5wcm9wcyk7XG4gICAgICByZXR1cm4gY2hpbGREYXRhID8gYWRkTWV0YShjaGlsZERhdGEsIG5hbWUsIGNoaWxkKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBIZWxwZXJzLnJlZHVjZUNoaWxkcmVuKGNoaWxkcmVuLCBpdGVyYXRlZSwgcHJvcHMpO1xuICB9LFxuICBmaW5kUG9pbnRzOiBmdW5jdGlvbiAoZGF0YXNldHMsIHBvaW50KSB7XG4gICAgcmV0dXJuIGRhdGFzZXRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHBvaW50Ll92b3Jvbm9pWCA9PT0gZC5fdm9yb25vaVggJiYgcG9pbnQuX3Zvcm9ub2lZID09PSBkLl92b3Jvbm9pWTtcbiAgICB9KTtcbiAgfSxcbiAgd2l0aGluUmFkaXVzOiBmdW5jdGlvbiAocG9pbnQsIG1vdXNlUG9zaXRpb24sIHJhZGl1cykge1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXJhZGl1cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHggPSBtb3VzZVBvc2l0aW9uLngsXG4gICAgICAgIHkgPSBtb3VzZVBvc2l0aW9uLnk7XG4gICAgdmFyIGRpc3RhbmNlU3F1YXJlZCA9IE1hdGgucG93KHggLSBwb2ludFswXSwgMikgKyBNYXRoLnBvdyh5IC0gcG9pbnRbMV0sIDIpO1xuICAgIHJldHVybiBkaXN0YW5jZVNxdWFyZWQgPCBNYXRoLnBvdyhyYWRpdXMsIDIpO1xuICB9LFxuICBnZXRWb3Jvbm9pUG9pbnRzOiBmdW5jdGlvbiAocHJvcHMsIG1vdXNlUG9zaXRpb24pIHtcbiAgICB2YXIgZGF0YXNldHMgPSB0aGlzLmdldERhdGFzZXRzKHByb3BzKTtcbiAgICB2YXIgc2NhbGVkRGF0YSA9IGRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIF9IZWxwZXJzJHNjYWxlUG9pbnQgPSBIZWxwZXJzLnNjYWxlUG9pbnQocHJvcHMsIGQpLFxuICAgICAgICAgIHggPSBfSGVscGVycyRzY2FsZVBvaW50LngsXG4gICAgICAgICAgeSA9IF9IZWxwZXJzJHNjYWxlUG9pbnQueTtcblxuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9KTtcbiAgICB2YXIgZGVsYXVuYXkgPSBEZWxhdW5heS5mcm9tKHNjYWxlZERhdGEpO1xuICAgIHZhciBpbmRleCA9IGRlbGF1bmF5LmZpbmQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuICAgIHZhciB3aXRoaW5SYWRpdXMgPSB0aGlzLndpdGhpblJhZGl1cyhzY2FsZWREYXRhW2luZGV4XSwgbW91c2VQb3NpdGlvbiwgcHJvcHMucmFkaXVzKTtcbiAgICB2YXIgcG9pbnRzID0gd2l0aGluUmFkaXVzID8gdGhpcy5maW5kUG9pbnRzKGRhdGFzZXRzLCBkYXRhc2V0c1tpbmRleF0pIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfTtcbiAgfSxcbiAgZ2V0QWN0aXZlTXV0YXRpb25zOiBmdW5jdGlvbiAocHJvcHMsIHBvaW50KSB7XG4gICAgdmFyIGNoaWxkTmFtZSA9IHBvaW50LmNoaWxkTmFtZSxcbiAgICAgICAgY29udGludW91cyA9IHBvaW50LmNvbnRpbnVvdXM7XG4gICAgdmFyIGFjdGl2YXRlRGF0YSA9IHByb3BzLmFjdGl2YXRlRGF0YSxcbiAgICAgICAgYWN0aXZhdGVMYWJlbHMgPSBwcm9wcy5hY3RpdmF0ZUxhYmVscyxcbiAgICAgICAgbGFiZWxzID0gcHJvcHMubGFiZWxzO1xuXG4gICAgaWYgKCFhY3RpdmF0ZURhdGEgJiYgIWFjdGl2YXRlTGFiZWxzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRUYXJnZXQgPSBhY3RpdmF0ZURhdGEgPyBbXCJkYXRhXCJdIDogW107XG4gICAgdmFyIHRhcmdldHMgPSBsYWJlbHMgJiYgIWFjdGl2YXRlTGFiZWxzID8gZGVmYXVsdFRhcmdldCA6IGRlZmF1bHRUYXJnZXQuY29uY2F0KFwibGFiZWxzXCIpO1xuXG4gICAgaWYgKF9pc0VtcHR5KHRhcmdldHMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciBldmVudEtleSA9IGNvbnRpbnVvdXMgPT09IHRydWUgJiYgdGFyZ2V0ID09PSBcImRhdGFcIiA/IFwiYWxsXCIgOiBwb2ludC5ldmVudEtleTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkTmFtZTogY2hpbGROYW1lLFxuICAgICAgICBldmVudEtleTogZXZlbnRLZXksXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBtdXRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICBnZXRJbmFjdGl2ZU11dGF0aW9uczogZnVuY3Rpb24gKHByb3BzLCBwb2ludCkge1xuICAgIHZhciBjaGlsZE5hbWUgPSBwb2ludC5jaGlsZE5hbWUsXG4gICAgICAgIGNvbnRpbnVvdXMgPSBwb2ludC5jb250aW51b3VzO1xuICAgIHZhciBhY3RpdmF0ZURhdGEgPSBwcm9wcy5hY3RpdmF0ZURhdGEsXG4gICAgICAgIGFjdGl2YXRlTGFiZWxzID0gcHJvcHMuYWN0aXZhdGVMYWJlbHMsXG4gICAgICAgIGxhYmVscyA9IHByb3BzLmxhYmVscztcblxuICAgIGlmICghYWN0aXZhdGVEYXRhICYmICFhY3RpdmF0ZUxhYmVscykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VGFyZ2V0ID0gYWN0aXZhdGVEYXRhID8gW1wiZGF0YVwiXSA6IFtdO1xuICAgIHZhciB0YXJnZXRzID0gbGFiZWxzICYmICFhY3RpdmF0ZUxhYmVscyA/IGRlZmF1bHRUYXJnZXQgOiBkZWZhdWx0VGFyZ2V0LmNvbmNhdChcImxhYmVsc1wiKTtcblxuICAgIGlmIChfaXNFbXB0eSh0YXJnZXRzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB2YXIgZXZlbnRLZXkgPSBjb250aW51b3VzICYmIHRhcmdldCA9PT0gXCJkYXRhXCIgPyBcImFsbFwiIDogcG9pbnQuZXZlbnRLZXk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZE5hbWU6IGNoaWxkTmFtZSxcbiAgICAgICAgZXZlbnRLZXk6IGV2ZW50S2V5LFxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgbXV0YXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgZ2V0UGFyZW50TXV0YXRpb246IGZ1bmN0aW9uIChhY3RpdmVQb2ludHMsIG1vdXNlUG9zaXRpb24sIHBhcmVudFNWRywgdkluZGV4KSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB0YXJnZXQ6IFwicGFyZW50XCIsXG4gICAgICBldmVudEtleTogXCJwYXJlbnRcIixcbiAgICAgIG11dGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aXZlUG9pbnRzOiBhY3RpdmVQb2ludHMsXG4gICAgICAgICAgbW91c2VQb3NpdGlvbjogbW91c2VQb3NpdGlvbixcbiAgICAgICAgICBwYXJlbnRTVkc6IHBhcmVudFNWRyxcbiAgICAgICAgICB2SW5kZXg6IHZJbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dO1xuICB9LFxuICBvbkFjdGl2YXRlZDogZnVuY3Rpb24gKHByb3BzLCBwb2ludHMpIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24ocHJvcHMub25BY3RpdmF0ZWQpKSB7XG4gICAgICBwcm9wcy5vbkFjdGl2YXRlZChwb2ludHMsIHByb3BzKTtcbiAgICB9XG4gIH0sXG4gIG9uRGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIChwcm9wcywgcG9pbnRzKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKHByb3BzLm9uRGVhY3RpdmF0ZWQpKSB7XG4gICAgICBwcm9wcy5vbkRlYWN0aXZhdGVkKHBvaW50cywgcHJvcHMpO1xuICAgIH1cbiAgfSxcbiAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiAoZXZ0LCB0YXJnZXRQcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIF90aGlzJGdldFBhcmVudE11dGF0aTtcblxuICAgIHZhciBhY3RpdmVQb2ludHMgPSB0YXJnZXRQcm9wcy5hY3RpdmVQb2ludHMgfHwgW107XG4gICAgdGhpcy5vbkRlYWN0aXZhdGVkKHRhcmdldFByb3BzLCBhY3RpdmVQb2ludHMpO1xuICAgIHZhciBpbmFjdGl2ZU11dGF0aW9ucyA9IGFjdGl2ZVBvaW50cy5sZW5ndGggPyBhY3RpdmVQb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldEluYWN0aXZlTXV0YXRpb25zKHRhcmdldFByb3BzLCBwb2ludCk7XG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4gKF90aGlzJGdldFBhcmVudE11dGF0aSA9IHRoaXMuZ2V0UGFyZW50TXV0YXRpb24oW10pKS5jb25jYXQuYXBwbHkoX3RoaXMkZ2V0UGFyZW50TXV0YXRpLCBfdG9Db25zdW1hYmxlQXJyYXkoaW5hY3RpdmVNdXRhdGlvbnMpKTtcbiAgfSxcbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChldnQsIHRhcmdldFByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1zdGF0ZW1lbnRzXG4gICAgdmFyIGFjdGl2ZVBvaW50cyA9IHRhcmdldFByb3BzLmFjdGl2ZVBvaW50cyB8fCBbXTtcbiAgICB2YXIgcGFyZW50U1ZHID0gdGFyZ2V0UHJvcHMucGFyZW50U1ZHIHx8IFNlbGVjdGlvbi5nZXRQYXJlbnRTVkcoZXZ0KTtcbiAgICB2YXIgbW91c2VQb3NpdGlvbiA9IFNlbGVjdGlvbi5nZXRTVkdFdmVudENvb3JkaW5hdGVzKGV2dCwgcGFyZW50U1ZHKTtcblxuICAgIGlmICghdGhpcy53aXRoaW5Cb3VuZHModGFyZ2V0UHJvcHMsIG1vdXNlUG9zaXRpb24pKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UGFyZW50TXV0YXRpMjtcblxuICAgICAgdGhpcy5vbkRlYWN0aXZhdGVkKHRhcmdldFByb3BzLCBhY3RpdmVQb2ludHMpO1xuXG4gICAgICB2YXIgX2luYWN0aXZlTXV0YXRpb25zID0gYWN0aXZlUG9pbnRzLmxlbmd0aCA/IGFjdGl2ZVBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZ2V0SW5hY3RpdmVNdXRhdGlvbnModGFyZ2V0UHJvcHMsIHBvaW50KTtcbiAgICAgIH0pIDogW107XG5cbiAgICAgIHJldHVybiAoX3RoaXMkZ2V0UGFyZW50TXV0YXRpMiA9IHRoaXMuZ2V0UGFyZW50TXV0YXRpb24oW10sIG1vdXNlUG9zaXRpb24sIHBhcmVudFNWRykpLmNvbmNhdC5hcHBseShfdGhpcyRnZXRQYXJlbnRNdXRhdGkyLCBfdG9Db25zdW1hYmxlQXJyYXkoX2luYWN0aXZlTXV0YXRpb25zKSk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJGdldFZvcm9ub2lQb2ludCA9IHRoaXMuZ2V0Vm9yb25vaVBvaW50cyh0YXJnZXRQcm9wcywgbW91c2VQb3NpdGlvbiksXG4gICAgICAgIF90aGlzJGdldFZvcm9ub2lQb2ludDIgPSBfdGhpcyRnZXRWb3Jvbm9pUG9pbnQucG9pbnRzLFxuICAgICAgICBwb2ludHMgPSBfdGhpcyRnZXRWb3Jvbm9pUG9pbnQyID09PSB2b2lkIDAgPyBbXSA6IF90aGlzJGdldFZvcm9ub2lQb2ludDIsXG4gICAgICAgIGluZGV4ID0gX3RoaXMkZ2V0Vm9yb25vaVBvaW50LmluZGV4O1xuXG4gICAgdmFyIHBhcmVudE11dGF0aW9ucyA9IHRoaXMuZ2V0UGFyZW50TXV0YXRpb24ocG9pbnRzLCBtb3VzZVBvc2l0aW9uLCBwYXJlbnRTVkcsIGluZGV4KTtcblxuICAgIGlmIChhY3RpdmVQb2ludHMubGVuZ3RoICYmIGlzRXF1YWwocG9pbnRzLCBhY3RpdmVQb2ludHMpKSB7XG4gICAgICByZXR1cm4gcGFyZW50TXV0YXRpb25zO1xuICAgIH1cblxuICAgIHRoaXMub25BY3RpdmF0ZWQodGFyZ2V0UHJvcHMsIHBvaW50cyk7XG4gICAgdGhpcy5vbkRlYWN0aXZhdGVkKHRhcmdldFByb3BzLCBhY3RpdmVQb2ludHMpO1xuICAgIHZhciBhY3RpdmVNdXRhdGlvbnMgPSBwb2ludHMubGVuZ3RoID8gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZ2V0QWN0aXZlTXV0YXRpb25zKHRhcmdldFByb3BzLCBwb2ludCk7XG4gICAgfSkgOiBbXTtcbiAgICB2YXIgaW5hY3RpdmVNdXRhdGlvbnMgPSBhY3RpdmVQb2ludHMubGVuZ3RoID8gYWN0aXZlUG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZ2V0SW5hY3RpdmVNdXRhdGlvbnModGFyZ2V0UHJvcHMsIHBvaW50KTtcbiAgICB9KSA6IFtdO1xuICAgIHJldHVybiBwYXJlbnRNdXRhdGlvbnMuY29uY2F0LmFwcGx5KHBhcmVudE11dGF0aW9ucywgX3RvQ29uc3VtYWJsZUFycmF5KGluYWN0aXZlTXV0YXRpb25zKS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjdGl2ZU11dGF0aW9ucykpKTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25Nb3VzZUxlYXZlOiBWb3Jvbm9pSGVscGVycy5vbk1vdXNlTGVhdmUuYmluZChWb3Jvbm9pSGVscGVycyksXG4gIG9uTW91c2VNb3ZlOiBfdGhyb3R0bGUoVm9yb25vaUhlbHBlcnMub25Nb3VzZU1vdmUuYmluZChWb3Jvbm9pSGVscGVycyksIDMyLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAge1xuICAgIGxlYWRpbmc6IHRydWUsXG4gICAgdHJhaWxpbmc6IGZhbHNlXG4gIH0pXG59OyIsImltcG9ydCBfcGljayBmcm9tIFwibG9kYXNoL3BpY2tcIjtcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tIFwibG9kYXNoL2lzRnVuY3Rpb25cIjtcbmltcG9ydCBfZGVmYXVsdHMgZnJvbSBcImxvZGFzaC9kZWZhdWx0c1wiO1xudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkTmFtZVwiLCBcImV2ZW50S2V5XCIsIFwic3R5bGVcIiwgXCJjb250aW51b3VzXCJdO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLW11bHRpLWNvbXAgKi9cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFZpY3RvcnlUb29sdGlwIH0gZnJvbSBcInZpY3RvcnktdG9vbHRpcFwiO1xuaW1wb3J0IHsgVmljdG9yeUNvbnRhaW5lciwgSGVscGVycywgUHJvcFR5cGVzIGFzIEN1c3RvbVByb3BUeXBlcyB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbmltcG9ydCBWb3Jvbm9pSGVscGVycyBmcm9tIFwiLi92b3Jvbm9pLWhlbHBlcnNcIjtcbmV4cG9ydCB2YXIgdm9yb25vaUNvbnRhaW5lck1peGluID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgdmFyIF9jbGFzcztcblxuICByZXR1cm4gX2NsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYmFzZSkge1xuICAgIF9pbmhlcml0cyhWaWN0b3J5Vm9yb25vaUNvbnRhaW5lciwgX2Jhc2UpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihWaWN0b3J5Vm9yb25vaUNvbnRhaW5lcik7XG5cbiAgICBmdW5jdGlvbiBWaWN0b3J5Vm9yb25vaUNvbnRhaW5lcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWN0b3J5Vm9yb25vaUNvbnRhaW5lcik7XG5cbiAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVmljdG9yeVZvcm9ub2lDb250YWluZXIsIFt7XG4gICAgICBrZXk6IFwiZ2V0RGltZW5zaW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9uKHByb3BzKSB7XG4gICAgICAgIHZhciBob3Jpem9udGFsID0gcHJvcHMuaG9yaXpvbnRhbCxcbiAgICAgICAgICAgIHZvcm9ub2lEaW1lbnNpb24gPSBwcm9wcy52b3Jvbm9pRGltZW5zaW9uO1xuXG4gICAgICAgIGlmICghaG9yaXpvbnRhbCB8fCAhdm9yb25vaURpbWVuc2lvbikge1xuICAgICAgICAgIHJldHVybiB2b3Jvbm9pRGltZW5zaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZvcm9ub2lEaW1lbnNpb24gPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb2ludCkge1xuICAgICAgICB2YXIgd2hpdGVsaXN0ID0gW1wiX3hcIiwgXCJfeDFcIiwgXCJfeDBcIiwgXCJfeVwiLCBcIl95MVwiLCBcIl95MFwiXTtcbiAgICAgICAgcmV0dXJuIF9waWNrKHBvaW50LCB3aGl0ZWxpc3QpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMYWJlbFBvc2l0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxQb3NpdGlvbihwcm9wcywgbGFiZWxQcm9wcywgcG9pbnRzKSB7XG4gICAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gcHJvcHMubW91c2VQb3NpdGlvbixcbiAgICAgICAgICAgIG1vdXNlRm9sbG93VG9vbHRpcHMgPSBwcm9wcy5tb3VzZUZvbGxvd1Rvb2x0aXBzO1xuICAgICAgICB2YXIgdm9yb25vaURpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKHByb3BzKTtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5nZXRQb2ludChwb2ludHNbMF0pO1xuICAgICAgICB2YXIgYmFzZVBvc2l0aW9uID0gSGVscGVycy5zY2FsZVBvaW50KHByb3BzLCBwb2ludCk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBtb3VzZUZvbGxvd1Rvb2x0aXBzID8gbW91c2VQb3NpdGlvbiA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIXZvcm9ub2lEaW1lbnNpb24gfHwgcG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBiYXNlUG9zaXRpb24pLCB7fSwge1xuICAgICAgICAgICAgY2VudGVyOiBfZGVmYXVsdHMoe30sIGxhYmVsUHJvcHMuY2VudGVyLCBjZW50ZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHZvcm9ub2lEaW1lbnNpb24gPT09IFwieVwiID8gbW91c2VQb3NpdGlvbi54IDogYmFzZVBvc2l0aW9uLng7XG4gICAgICAgIHZhciB5ID0gdm9yb25vaURpbWVuc2lvbiA9PT0gXCJ4XCIgPyBtb3VzZVBvc2l0aW9uLnkgOiBiYXNlUG9zaXRpb24ueTtcbiAgICAgICAgY2VudGVyID0gbW91c2VGb2xsb3dUb29sdGlwcyA/IG1vdXNlUG9zaXRpb24gOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGNlbnRlcjogX2RlZmF1bHRzKHt9LCBsYWJlbFByb3BzLmNlbnRlciwgY2VudGVyKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTdHlsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlKHByb3BzLCBwb2ludHMsIHR5cGUpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IHByb3BzLmxhYmVscyxcbiAgICAgICAgICAgIGxhYmVsQ29tcG9uZW50ID0gcHJvcHMubGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgICB0aGVtZSA9IHByb3BzLnRoZW1lO1xuICAgICAgICB2YXIgY29tcG9uZW50UHJvcHMgPSBsYWJlbENvbXBvbmVudC5wcm9wcyB8fCB7fTtcbiAgICAgICAgdmFyIHRoZW1lU3R5bGVzID0gdGhlbWUgJiYgdGhlbWUudm9yb25vaSAmJiB0aGVtZS52b3Jvbm9pLnN0eWxlID8gdGhlbWUudm9yb25vaS5zdHlsZSA6IHt9O1xuICAgICAgICB2YXIgY29tcG9uZW50U3R5bGVBcnJheSA9IHR5cGUgPT09IFwiZmx5b3V0XCIgPyBjb21wb25lbnRQcm9wcy5mbHlvdXRTdHlsZSA6IGNvbXBvbmVudFByb3BzLnN0eWxlO1xuICAgICAgICByZXR1cm4gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSBfZGVmYXVsdHMoe30sIGNvbXBvbmVudFByb3BzLCB7XG4gICAgICAgICAgICBkYXR1bTogZGF0dW0sXG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciB0ZXh0ID0gX2lzRnVuY3Rpb24obGFiZWxzKSA/IGxhYmVscyhsYWJlbFByb3BzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgdGV4dEFycmF5ID0gdGV4dCAhPT0gdW5kZWZpbmVkID8gXCJcIi5jb25jYXQodGV4dCkuc3BsaXQoXCJcXG5cIikgOiBbXTtcbiAgICAgICAgICB2YXIgYmFzZVN0eWxlID0gZGF0dW0uc3R5bGUgJiYgZGF0dW0uc3R5bGVbdHlwZV0gfHwge307XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFN0eWxlID0gQXJyYXkuaXNBcnJheShjb21wb25lbnRTdHlsZUFycmF5KSA/IGNvbXBvbmVudFN0eWxlQXJyYXlbaW5kZXhdIDogY29tcG9uZW50U3R5bGVBcnJheTtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBIZWxwZXJzLmV2YWx1YXRlU3R5bGUoX2RlZmF1bHRzKHt9LCBjb21wb25lbnRTdHlsZSwgYmFzZVN0eWxlLCB0aGVtZVN0eWxlc1t0eXBlXSksIGxhYmVsUHJvcHMpO1xuICAgICAgICAgIHZhciBzdHlsZUFycmF5ID0gdGV4dEFycmF5Lmxlbmd0aCA/IHRleHRBcnJheS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgIH0pIDogW3N0eWxlXTtcbiAgICAgICAgICBtZW1vID0gbWVtby5jb25jYXQoc3R5bGVBcnJheSk7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RGVmYXVsdExhYmVsUHJvcHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0TGFiZWxQcm9wcyhwcm9wcywgcG9pbnRzKSB7XG4gICAgICAgIHZhciB2b3Jvbm9pRGltZW5zaW9uID0gcHJvcHMudm9yb25vaURpbWVuc2lvbixcbiAgICAgICAgICAgIGhvcml6b250YWwgPSBwcm9wcy5ob3Jpem9udGFsLFxuICAgICAgICAgICAgbW91c2VGb2xsb3dUb29sdGlwcyA9IHByb3BzLm1vdXNlRm9sbG93VG9vbHRpcHM7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQocG9pbnRzWzBdKTtcbiAgICAgICAgdmFyIG11bHRpUG9pbnQgPSB2b3Jvbm9pRGltZW5zaW9uICYmIHBvaW50cy5sZW5ndGggPiAxO1xuICAgICAgICB2YXIgeSA9IHBvaW50Ll95MSAhPT0gdW5kZWZpbmVkID8gcG9pbnQuX3kxIDogcG9pbnQuX3k7XG4gICAgICAgIHZhciBkZWZhdWx0SG9yaXpvbnRhbE9yaWVudGF0aW9uID0geSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgdmFyIGRlZmF1bHRPcmllbnRhdGlvbiA9IHkgPCAwID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgICAgIHZhciBsYWJlbE9yaWVudGF0aW9uID0gaG9yaXpvbnRhbCA/IGRlZmF1bHRIb3Jpem9udGFsT3JpZW50YXRpb24gOiBkZWZhdWx0T3JpZW50YXRpb247XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IG1vdXNlRm9sbG93VG9vbHRpcHMgPyB1bmRlZmluZWQgOiBsYWJlbE9yaWVudGF0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgICBwb2ludGVyTGVuZ3RoOiBtdWx0aVBvaW50ID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjb25zdHJhaW5Ub1Zpc2libGVBcmVhOiBtdWx0aVBvaW50IHx8IG1vdXNlRm9sbG93VG9vbHRpcHMgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldExhYmVsUHJvcHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFByb3BzKHByb3BzLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IHByb3BzLmxhYmVscyxcbiAgICAgICAgICAgIHNjYWxlID0gcHJvcHMuc2NhbGUsXG4gICAgICAgICAgICBsYWJlbENvbXBvbmVudCA9IHByb3BzLmxhYmVsQ29tcG9uZW50LFxuICAgICAgICAgICAgdGhlbWUgPSBwcm9wcy50aGVtZSxcbiAgICAgICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb21wb25lbnRQcm9wcyA9IGxhYmVsQ29tcG9uZW50LnByb3BzIHx8IHt9O1xuICAgICAgICB2YXIgdGV4dCA9IHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGRhdHVtKSB7XG4gICAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSBfZGVmYXVsdHMoe30sIGNvbXBvbmVudFByb3BzLCB7XG4gICAgICAgICAgICBkYXR1bTogZGF0dW0sXG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciB0ID0gX2lzRnVuY3Rpb24obGFiZWxzKSA/IGxhYmVscyhsYWJlbFByb3BzKSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAodCA9PT0gbnVsbCB8fCB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1lbW8gPSBtZW1vLmNvbmNhdChcIlwiLmNvbmNhdCh0KS5zcGxpdChcIlxcblwiKSk7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTsgLy8gcmVtb3ZlIHByb3BlcnRpZXMgZnJvbSBmaXJzdCBwb2ludCB0byBtYWtlIGRhdHVtXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICAgIHZhciBfcG9pbnRzJCA9IHBvaW50c1swXSxcbiAgICAgICAgICAgIGNoaWxkTmFtZSA9IF9wb2ludHMkLmNoaWxkTmFtZSxcbiAgICAgICAgICAgIGV2ZW50S2V5ID0gX3BvaW50cyQuZXZlbnRLZXksXG4gICAgICAgICAgICBzdHlsZSA9IF9wb2ludHMkLnN0eWxlLFxuICAgICAgICAgICAgY29udGludW91cyA9IF9wb2ludHMkLmNvbnRpbnVvdXMsXG4gICAgICAgICAgICBkYXR1bSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcG9pbnRzJCwgX2V4Y2x1ZGVkKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWUgPT09IGNoaWxkTmFtZSA/IGNoaWxkTmFtZSA6IFwiXCIuY29uY2F0KHByb3BzLm5hbWUsIFwiLVwiKS5jb25jYXQoY2hpbGROYW1lKTtcblxuICAgICAgICB2YXIgbGFiZWxQcm9wcyA9IF9kZWZhdWx0cyh7XG4gICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChuYW1lLCBcIi1cIikuY29uY2F0KGV2ZW50S2V5LCBcIi12b3Jvbm9pLXRvb2x0aXBcIiksXG4gICAgICAgICAgaWQ6IFwiXCIuY29uY2F0KG5hbWUsIFwiLVwiKS5jb25jYXQoZXZlbnRLZXksIFwiLXZvcm9ub2ktdG9vbHRpcFwiKSxcbiAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgcmVuZGVySW5Qb3J0YWw6IGZhbHNlLFxuICAgICAgICAgIGFjdGl2ZVBvaW50czogcG9pbnRzLFxuICAgICAgICAgIGRhdHVtOiBkYXR1bSxcbiAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgdGhlbWU6IHRoZW1lXG4gICAgICAgIH0sIGNvbXBvbmVudFByb3BzLCB7XG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgc3R5bGU6IHRoaXMuZ2V0U3R5bGUocHJvcHMsIHBvaW50cywgXCJsYWJlbHNcIiksXG4gICAgICAgICAgZmx5b3V0U3R5bGU6IHRoaXMuZ2V0U3R5bGUocHJvcHMsIHBvaW50cywgXCJmbHlvdXRcIilbMF1cbiAgICAgICAgfSwgdGhpcy5nZXREZWZhdWx0TGFiZWxQcm9wcyhwcm9wcywgcG9pbnRzKSk7XG5cbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLmdldExhYmVsUG9zaXRpb24ocHJvcHMsIGxhYmVsUHJvcHMsIHBvaW50cyk7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdHMoe30sIGxhYmVsUG9zaXRpb24sIGxhYmVsUHJvcHMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRUb29sdGlwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbHRpcChwcm9wcykge1xuICAgICAgICB2YXIgbGFiZWxzID0gcHJvcHMubGFiZWxzLFxuICAgICAgICAgICAgYWN0aXZlUG9pbnRzID0gcHJvcHMuYWN0aXZlUG9pbnRzLFxuICAgICAgICAgICAgbGFiZWxDb21wb25lbnQgPSBwcm9wcy5sYWJlbENvbXBvbmVudDtcblxuICAgICAgICBpZiAoIWxhYmVscykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWN0aXZlUG9pbnRzKSAmJiBhY3RpdmVQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSB0aGlzLmdldExhYmVsUHJvcHMocHJvcHMsIGFjdGl2ZVBvaW50cyk7XG4gICAgICAgICAgdmFyIHRleHQgPSBsYWJlbFByb3BzLnRleHQ7XG4gICAgICAgICAgdmFyIHNob3dMYWJlbCA9IEFycmF5LmlzQXJyYXkodGV4dCkgPyB0ZXh0LmZpbHRlcihCb29sZWFuKS5sZW5ndGggOiB0ZXh0O1xuICAgICAgICAgIHJldHVybiBzaG93TGFiZWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGxhYmVsQ29tcG9uZW50LCBsYWJlbFByb3BzKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gT3ZlcnJpZGVzIG1ldGhvZCBpbiBWaWN0b3J5Q29udGFpbmVyXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Q2hpbGRyZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZHJlbihwcm9wcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShSZWFjdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKSksIFt0aGlzLmdldFRvb2x0aXAocHJvcHMpXSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZpY3RvcnlWb3Jvbm9pQ29udGFpbmVyO1xuICB9KGJhc2UpLCBfY2xhc3MuZGlzcGxheU5hbWUgPSBcIlZpY3RvcnlWb3Jvbm9pQ29udGFpbmVyXCIsIF9jbGFzcy5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIFZpY3RvcnlDb250YWluZXIucHJvcFR5cGVzKSwge30sIHtcbiAgICBhY3RpdmF0ZURhdGE6IFByb3BUeXBlcy5ib29sLFxuICAgIGFjdGl2YXRlTGFiZWxzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsYWJlbENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgbGFiZWxzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBtb3VzZUZvbGxvd1Rvb2x0aXBzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkFjdGl2YXRlZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZWFjdGl2YXRlZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHZvcm9ub2lCbGFja2xpc3Q6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIEN1c3RvbVByb3BUeXBlcy5yZWdFeHBdKSksXG4gICAgdm9yb25vaURpbWVuc2lvbjogUHJvcFR5cGVzLm9uZU9mKFtcInhcIiwgXCJ5XCJdKSxcbiAgICB2b3Jvbm9pUGFkZGluZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIGJvdHRvbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICByaWdodDogUHJvcFR5cGVzLm51bWJlclxuICAgIH0pXSlcbiAgfSksIF9jbGFzcy5kZWZhdWx0UHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIFZpY3RvcnlDb250YWluZXIuZGVmYXVsdFByb3BzKSwge30sIHtcbiAgICBhY3RpdmF0ZURhdGE6IHRydWUsXG4gICAgYWN0aXZhdGVMYWJlbHM6IHRydWUsXG4gICAgbGFiZWxDb21wb25lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpY3RvcnlUb29sdGlwLCBudWxsKSxcbiAgICB2b3Jvbm9pUGFkZGluZzogNVxuICB9KSwgX2NsYXNzLmRlZmF1bHRFdmVudHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHRhcmdldDogXCJwYXJlbnRcIixcbiAgICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiAoZXZ0LCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5kaXNhYmxlID8ge30gOiBWb3Jvbm9pSGVscGVycy5vbk1vdXNlTGVhdmUoZXZ0LCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG91Y2hDYW5jZWw6IGZ1bmN0aW9uIChldnQsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmRpc2FibGUgPyB7fSA6IFZvcm9ub2lIZWxwZXJzLm9uTW91c2VMZWF2ZShldnQsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChldnQsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmRpc2FibGUgPyB7fSA6IFZvcm9ub2lIZWxwZXJzLm9uTW91c2VNb3ZlKGV2dCwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9LFxuICAgICAgICBvblRvdWNoTW92ZTogZnVuY3Rpb24gKGV2dCwgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMuZGlzYWJsZSA/IHt9IDogVm9yb25vaUhlbHBlcnMub25Nb3VzZU1vdmUoZXZ0LCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0YXJnZXQ6IFwiZGF0YVwiLFxuICAgICAgZXZlbnRIYW5kbGVyczogcHJvcHMuZGlzYWJsZSA/IHt9IDoge1xuICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XTtcbiAgfSwgX2NsYXNzO1xufTtcbmV4cG9ydCBkZWZhdWx0IHZvcm9ub2lDb250YWluZXJNaXhpbihWaWN0b3J5Q29udGFpbmVyKTsgLy8gQHRzLWV4cGVjdC1lcnJvciBJTVBPUlRBTlQ6IHdoZW4gY29udmVydGluZyB0aGlzIGZpbGUgdG8gVHlwZVNjcmlwdCwgeW91IG11c3QgZXhwb3J0IHRoZSB0eXBlIGFzIHdlbGw6XG4vLyBleHBvcnQgY29uc3QgVmljdG9yeVZvcm9ub2lDb250YWluZXIgPSB2b3Jvbm9pQ29udGFpbmVyTWl4aW4oVmljdG9yeUNvbnRhaW5lcik7XG4vLyBleHBvcnQgdHlwZSBWaWN0b3J5Vm9yb25vaUNvbnRhaW5lciA9IHR5cGVvZiBWaWN0b3J5Vm9yb25vaUNvbnRhaW5lcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10556\n')}}]);