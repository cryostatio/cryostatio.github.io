"use strict";(self.webpackChunkcryostat_web=self.webpackChunkcryostat_web||[]).push([[5561],{37541:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": () => (/* binding */ victory_legend)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(45697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n// EXTERNAL MODULE: ./node_modules/lodash/isNil.js\nvar isNil = __webpack_require__(14293);\nvar isNil_default = /*#__PURE__*/__webpack_require__.n(isNil);\n// EXTERNAL MODULE: ./node_modules/lodash/range.js\nvar range = __webpack_require__(96026);\nvar range_default = /*#__PURE__*/__webpack_require__.n(range);\n// EXTERNAL MODULE: ./node_modules/lodash/sum.js\nvar sum = __webpack_require__(12297);\nvar sum_default = /*#__PURE__*/__webpack_require__.n(sum);\n// EXTERNAL MODULE: ./node_modules/lodash/keys.js\nvar keys = __webpack_require__(3674);\nvar keys_default = /*#__PURE__*/__webpack_require__.n(keys);\n// EXTERNAL MODULE: ./node_modules/lodash/groupBy.js\nvar groupBy = __webpack_require__(7739);\nvar groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);\n// EXTERNAL MODULE: ./node_modules/lodash/assign.js\nvar lodash_assign = __webpack_require__(28583);\nvar assign_default = /*#__PURE__*/__webpack_require__.n(lodash_assign);\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(91747);\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/style.js\nvar style = __webpack_require__(38586);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/helpers.js\nvar helpers = __webpack_require__(95302);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/textsize.js\nvar textsize = __webpack_require__(82254);\n;// CONCATENATED MODULE: ./node_modules/victory-legend/es/helper-methods.js\n\n\n\n\n\n\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar getColorScale = function (props) {\n  var colorScale = props.colorScale;\n  return typeof colorScale === "string" ? style/* getColorScale */.p(colorScale) : colorScale || [];\n};\n\nvar getLabelStyles = function (props) {\n  var data = props.data,\n      style = props.style;\n  return data.map(function (datum, index) {\n    var baseLabelStyles = defaults_default()({}, datum.labels, style.labels);\n\n    return helpers/* evaluateStyle */.F3(baseLabelStyles, {\n      datum: datum,\n      index: index,\n      data: data\n    });\n  });\n};\n\nvar getStyles = function (props, styleObject) {\n  var style = props.style || {};\n  styleObject = styleObject || {};\n  var parentStyleProps = {\n    height: "100%",\n    width: "100%"\n  };\n  return {\n    parent: defaults_default()(style.parent, styleObject.parent, parentStyleProps),\n    data: defaults_default()({}, style.data, styleObject.data),\n    labels: defaults_default()({}, style.labels, styleObject.labels),\n    border: defaults_default()({}, style.border, styleObject.border),\n    title: defaults_default()({}, style.title, styleObject.title)\n  };\n};\n\nvar getCalculatedValues = function (props) {\n  var orientation = props.orientation,\n      theme = props.theme;\n  var defaultStyles = theme && theme.legend && theme.legend.style ? theme.legend.style : {};\n  var style = getStyles(props, defaultStyles);\n  var colorScale = getColorScale(props);\n  var isHorizontal = orientation === "horizontal";\n  var borderPadding = helpers/* getPadding */.tQ({\n    padding: props.borderPadding\n  });\n  return assign_default()({}, props, {\n    style: style,\n    isHorizontal: isHorizontal,\n    colorScale: colorScale,\n    borderPadding: borderPadding\n  });\n};\n\nvar getColumn = function (props, index) {\n  var itemsPerRow = props.itemsPerRow,\n      isHorizontal = props.isHorizontal;\n\n  if (!itemsPerRow) {\n    return isHorizontal ? index : 0;\n  }\n\n  return isHorizontal ? index % itemsPerRow : Math.floor(index / itemsPerRow);\n};\n\nvar getRow = function (props, index) {\n  var itemsPerRow = props.itemsPerRow,\n      isHorizontal = props.isHorizontal;\n\n  if (!itemsPerRow) {\n    return isHorizontal ? 0 : index;\n  }\n\n  return isHorizontal ? Math.floor(index / itemsPerRow) : index % itemsPerRow;\n};\n\nvar groupData = function (props) {\n  var data = props.data;\n  var style = props.style && props.style.data || {};\n  var labelStyles = getLabelStyles(props);\n  return data.map(function (datum, index) {\n    var symbol = datum.symbol || {};\n    var fontSize = labelStyles[index].fontSize; // eslint-disable-next-line no-magic-numbers\n\n    var size = symbol.size || style.size || fontSize / 2.5;\n    var symbolSpacer = props.symbolSpacer || Math.max(size, fontSize);\n    return _objectSpread(_objectSpread({}, datum), {}, {\n      size: size,\n      symbolSpacer: symbolSpacer,\n      fontSize: fontSize,\n      textSize: textsize/* approximateTextSize */.Z9(datum.name, labelStyles[index]),\n      column: getColumn(props, index),\n      row: getRow(props, index)\n    });\n  });\n};\n\nvar getColumnWidths = function (props, data) {\n  var gutter = props.gutter || {};\n  var gutterWidth = typeof gutter === "object" ? (gutter.left || 0) + (gutter.right || 0) : gutter || 0;\n\n  var dataByColumn = groupBy_default()(data, "column");\n\n  var columns = keys_default()(dataByColumn);\n\n  return columns.reduce(function (memo, curr, index) {\n    var lengths = dataByColumn[curr].map(function (d) {\n      return d.textSize.width + d.size + d.symbolSpacer + gutterWidth;\n    });\n    memo[index] = Math.max.apply(Math, _toConsumableArray(lengths));\n    return memo;\n  }, []);\n};\n\nvar getRowHeights = function (props, data) {\n  var gutter = props.rowGutter || {};\n  var gutterHeight = typeof gutter === "object" ? (gutter.top || 0) + (gutter.bottom || 0) : gutter || 0;\n\n  var dataByRow = groupBy_default()(data, "row");\n\n  return keys_default()(dataByRow).reduce(function (memo, curr, index) {\n    var rows = dataByRow[curr];\n    var lengths = rows.map(function (d) {\n      return d.textSize.height + d.symbolSpacer + gutterHeight;\n    });\n    memo[index] = Math.max.apply(Math, _toConsumableArray(lengths));\n    return memo;\n  }, []);\n};\n\nvar getTitleDimensions = function (props) {\n  var style = props.style && props.style.title || {};\n  var textSize = textsize/* approximateTextSize */.Z9(props.title, style);\n  var padding = style.padding || 0;\n  return {\n    height: textSize.height + 2 * padding || 0,\n    width: textSize.width + 2 * padding || 0\n  };\n};\n\nvar getOffset = function (datum, rowHeights, columnWidths) {\n  var column = datum.column,\n      row = datum.row;\n  return {\n    x: range_default()(column).reduce(function (memo, curr) {\n      memo += columnWidths[curr];\n      return memo;\n    }, 0),\n    y: range_default()(row).reduce(function (memo, curr) {\n      memo += rowHeights[curr];\n      return memo;\n    }, 0)\n  };\n};\n\nvar getAnchors = function (titleOrientation, centerTitle) {\n  var standardAnchors = {\n    textAnchor: titleOrientation === "right" ? "end" : "start",\n    verticalAnchor: titleOrientation === "bottom" ? "end" : "start"\n  };\n\n  if (centerTitle) {\n    var horizontal = titleOrientation === "top" || titleOrientation === "bottom";\n    return {\n      textAnchor: horizontal ? "middle" : standardAnchors.textAnchor,\n      verticalAnchor: horizontal ? standardAnchors.verticalAnchor : "middle"\n    };\n  }\n\n  return standardAnchors;\n};\n\nvar getTitleStyle = function (props) {\n  var titleOrientation = props.titleOrientation,\n      centerTitle = props.centerTitle,\n      titleComponent = props.titleComponent;\n  var baseStyle = props.style && props.style.title || {};\n  var componentStyle = titleComponent.props && titleComponent.props.style || {};\n  var anchors = getAnchors(titleOrientation, centerTitle);\n  return Array.isArray(componentStyle) ? componentStyle.map(function (obj) {\n    return defaults_default()({}, obj, baseStyle, anchors);\n  }) : defaults_default()({}, componentStyle, baseStyle, anchors);\n}; // eslint-disable-next-line complexity\n\n\nvar getTitleProps = function (props, borderProps) {\n  var title = props.title,\n      titleOrientation = props.titleOrientation,\n      centerTitle = props.centerTitle,\n      borderPadding = props.borderPadding;\n  var height = borderProps.height,\n      width = borderProps.width;\n  var style = getTitleStyle(props);\n  var padding = Array.isArray(style) ? style[0].padding : style.padding;\n  var horizontal = titleOrientation === "top" || titleOrientation === "bottom";\n  var xOrientation = titleOrientation === "bottom" ? "bottom" : "top";\n  var yOrientation = titleOrientation === "right" ? "right" : "left";\n  var standardPadding = {\n    x: centerTitle ? width / 2 : borderPadding[xOrientation] + (padding || 0),\n    y: centerTitle ? height / 2 : borderPadding[yOrientation] + (padding || 0)\n  };\n\n  var getPadding = function () {\n    return borderPadding[titleOrientation] + (padding || 0);\n  };\n\n  var xOffset = horizontal ? standardPadding.x : getPadding();\n  var yOffset = horizontal ? getPadding() : standardPadding.y;\n  return {\n    x: titleOrientation === "right" ? props.x + width - xOffset : props.x + xOffset,\n    y: titleOrientation === "bottom" ? props.y + height - yOffset : props.y + yOffset,\n    style: style,\n    text: title\n  };\n};\n\nvar getBorderProps = function (props, contentHeight, contentWidth) {\n  var x = props.x,\n      y = props.y,\n      borderPadding = props.borderPadding,\n      style = props.style;\n  var height = (contentHeight || 0) + borderPadding.top + borderPadding.bottom;\n  var width = (contentWidth || 0) + borderPadding.left + borderPadding.right;\n  return {\n    x: x,\n    y: y,\n    height: height,\n    width: width,\n    style: assign_default()({\n      fill: "none"\n    }, style.border)\n  };\n};\n\nvar getDimensions = function (props, fallbackProps) {\n  var modifiedProps = helpers/* modifyProps */.TY(props, fallbackProps, "legend");\n  props = assign_default()({}, modifiedProps, getCalculatedValues(modifiedProps));\n  var _props = props,\n      title = _props.title,\n      titleOrientation = _props.titleOrientation;\n  var groupedData = groupData(props);\n  var columnWidths = getColumnWidths(props, groupedData);\n  var rowHeights = getRowHeights(props, groupedData);\n  var titleDimensions = title ? getTitleDimensions(props) : {\n    height: 0,\n    width: 0\n  };\n  return {\n    height: titleOrientation === "left" || titleOrientation === "right" ? Math.max(sum_default()(rowHeights), titleDimensions.height) : sum_default()(rowHeights) + titleDimensions.height,\n    width: titleOrientation === "left" || titleOrientation === "right" ? sum_default()(columnWidths) + titleDimensions.width : Math.max(sum_default()(columnWidths), titleDimensions.width)\n  };\n};\nvar getBaseProps = function (props, fallbackProps) {\n  var modifiedProps = helpers/* modifyProps */.TY(props, fallbackProps, "legend");\n  props = assign_default()({}, modifiedProps, getCalculatedValues(modifiedProps));\n  var _props2 = props,\n      data = _props2.data,\n      standalone = _props2.standalone,\n      theme = _props2.theme,\n      padding = _props2.padding,\n      style = _props2.style,\n      colorScale = _props2.colorScale,\n      gutter = _props2.gutter,\n      rowGutter = _props2.rowGutter,\n      borderPadding = _props2.borderPadding,\n      title = _props2.title,\n      titleOrientation = _props2.titleOrientation,\n      name = _props2.name,\n      _props2$x = _props2.x,\n      x = _props2$x === void 0 ? 0 : _props2$x,\n      _props2$y = _props2.y,\n      y = _props2$y === void 0 ? 0 : _props2$y;\n  var groupedData = groupData(props);\n  var columnWidths = getColumnWidths(props, groupedData);\n  var rowHeights = getRowHeights(props, groupedData);\n  var labelStyles = getLabelStyles(props);\n  var titleDimensions = title ? getTitleDimensions(props) : {\n    height: 0,\n    width: 0\n  };\n  var titleOffset = {\n    x: titleOrientation === "left" ? titleDimensions.width : 0,\n    y: titleOrientation === "top" ? titleDimensions.height : 0\n  };\n  var gutterOffset = {\n    x: gutter && typeof gutter === "object" ? gutter.left || 0 : 0,\n    y: rowGutter && typeof rowGutter === "object" ? rowGutter.top || 0 : 0\n  };\n\n  var _getDimensions = getDimensions(props, fallbackProps),\n      height = _getDimensions.height,\n      width = _getDimensions.width;\n\n  var borderProps = getBorderProps(props, height, width);\n  var titleProps = getTitleProps(props, borderProps);\n  var initialProps = {\n    parent: {\n      data: data,\n      standalone: standalone,\n      theme: theme,\n      padding: padding,\n      name: name,\n      height: props.height,\n      width: props.width,\n      style: style.parent\n    },\n    all: {\n      border: borderProps,\n      title: titleProps\n    }\n  };\n  return groupedData.reduce(function (childProps, datum, i) {\n    var color = colorScale[i % colorScale.length];\n\n    var dataStyle = defaults_default()({}, datum.symbol, style.data, {\n      fill: color\n    });\n\n    var eventKey = !isNil_default()(datum.eventKey) ? datum.eventKey : i;\n    var offset = getOffset(datum, rowHeights, columnWidths);\n    var originY = y + borderPadding.top + datum.symbolSpacer;\n    var originX = x + borderPadding.left + datum.symbolSpacer;\n    var dataProps = {\n      index: i,\n      data: data,\n      datum: datum,\n      symbol: dataStyle.type || dataStyle.symbol || "circle",\n      size: datum.size,\n      style: dataStyle,\n      y: originY + offset.y + titleOffset.y + gutterOffset.y,\n      x: originX + offset.x + titleOffset.x + gutterOffset.x\n    };\n    var labelProps = {\n      datum: datum,\n      data: data,\n      text: datum.name,\n      style: labelStyles[i],\n      y: dataProps.y,\n      x: dataProps.x + datum.symbolSpacer + datum.size / 2\n    };\n    childProps[eventKey] = {\n      data: dataProps,\n      labels: labelProps\n    };\n    return childProps;\n  }, initialProps);\n};\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/prop-types.js\nvar victory_util_prop_types = __webpack_require__(99733);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/border.js\nvar border = __webpack_require__(49514);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-container/victory-container.js + 1 modules\nvar victory_container = __webpack_require__(3532);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-primitives/point.js + 1 modules\nvar point = __webpack_require__(22602);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-label/victory-label.js + 2 modules\nvar victory_label = __webpack_require__(41248);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-theme/victory-theme.js + 2 modules\nvar victory_theme = __webpack_require__(6673);\n// EXTERNAL MODULE: ./node_modules/victory-core/es/victory-util/add-events.js + 3 modules\nvar add_events = __webpack_require__(73247);\n;// CONCATENATED MODULE: ./node_modules/victory-legend/es/victory-legend.js\nfunction victory_legend_toConsumableArray(arr) { return victory_legend_arrayWithoutHoles(arr) || victory_legend_iterableToArray(arr) || victory_legend_unsupportedIterableToArray(arr) || victory_legend_nonIterableSpread(); }\n\nfunction victory_legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction victory_legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return victory_legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return victory_legend_arrayLikeToArray(o, minLen); }\n\nfunction victory_legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction victory_legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return victory_legend_arrayLikeToArray(arr); }\n\nfunction victory_legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar fallbackProps = {\n  orientation: "vertical",\n  titleOrientation: "top",\n  width: 450,\n  height: 300,\n  x: 0,\n  y: 0\n};\nvar defaultLegendData = [{\n  name: "Series 1"\n}, {\n  name: "Series 2"\n}];\n\nvar VictoryLegend = /*#__PURE__*/function (_React$Component) {\n  _inherits(VictoryLegend, _React$Component);\n\n  var _super = _createSuper(VictoryLegend);\n\n  function VictoryLegend() {\n    _classCallCheck(this, VictoryLegend);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VictoryLegend, [{\n    key: "renderChildren",\n    value: function renderChildren(props) {\n      var _this = this;\n\n      var dataComponent = props.dataComponent,\n          labelComponent = props.labelComponent,\n          title = props.title;\n      var dataComponents = this.dataKeys.map(function (_dataKey, index) {\n        if (_dataKey === "all") {\n          return undefined;\n        }\n\n        var dataProps = _this.getComponentProps(dataComponent, "data", index);\n\n        return /*#__PURE__*/react.cloneElement(dataComponent, dataProps);\n      }).filter(Boolean);\n      var labelComponents = this.dataKeys.map(function (_dataKey, index) {\n        if (_dataKey === "all") {\n          return undefined;\n        }\n\n        var labelProps = _this.getComponentProps(labelComponent, "labels", index);\n\n        if (labelProps.text !== undefined && labelProps.text !== null) {\n          return /*#__PURE__*/react.cloneElement(labelComponent, labelProps);\n        }\n\n        return undefined;\n      }).filter(Boolean);\n      var borderProps = this.getComponentProps(props.borderComponent, "border", "all");\n      var borderComponent = /*#__PURE__*/react.cloneElement(props.borderComponent, borderProps);\n\n      if (title) {\n        var titleProps = this.getComponentProps(props.title, "title", "all");\n        var titleComponent = /*#__PURE__*/react.cloneElement(props.titleComponent, titleProps);\n        return [borderComponent].concat(victory_legend_toConsumableArray(dataComponents), [titleComponent], victory_legend_toConsumableArray(labelComponents));\n      }\n\n      return [borderComponent].concat(victory_legend_toConsumableArray(dataComponents), victory_legend_toConsumableArray(labelComponents));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var role = this.constructor.role;\n      var props = helpers/* modifyProps */.TY(this.props, fallbackProps, role);\n      var children = [this.renderChildren(props)];\n      return props.standalone ? this.renderContainer(props.containerComponent, children) : /*#__PURE__*/react.cloneElement(props.groupComponent, {}, children);\n    }\n  }]);\n\n  return VictoryLegend;\n}(react.Component);\n\nVictoryLegend.displayName = "VictoryLegend";\nVictoryLegend.role = "legend";\nVictoryLegend.propTypes = {\n  borderComponent: (prop_types_default()).element,\n  borderPadding: prop_types_default().oneOfType([(prop_types_default()).number, prop_types_default().shape({\n    top: (prop_types_default()).number,\n    bottom: (prop_types_default()).number,\n    left: (prop_types_default()).number,\n    right: (prop_types_default()).number\n  })]),\n  centerTitle: (prop_types_default()).bool,\n  colorScale: prop_types_default().oneOfType([prop_types_default().arrayOf((prop_types_default()).string), prop_types_default().oneOf(["grayscale", "qualitative", "heatmap", "warm", "cool", "red", "green", "blue"])]),\n  containerComponent: (prop_types_default()).element,\n  data: prop_types_default().arrayOf(prop_types_default().shape({\n    name: (prop_types_default()).string.isRequired,\n    label: (prop_types_default()).object,\n    symbol: (prop_types_default()).object\n  })),\n  dataComponent: (prop_types_default()).element,\n  eventKey: prop_types_default().oneOfType([(prop_types_default()).func, victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* nonNegative */.A7]), (prop_types_default()).string]),\n  events: prop_types_default().arrayOf(prop_types_default().shape({\n    target: prop_types_default().oneOf(["data", "labels", "parent"]),\n    eventKey: prop_types_default().oneOfType([(prop_types_default()).array, victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* nonNegative */.A7]), (prop_types_default()).string]),\n    eventHandlers: (prop_types_default()).object\n  })),\n  externalEventMutations: prop_types_default().arrayOf(prop_types_default().shape({\n    callback: (prop_types_default()).func,\n    childName: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).array]),\n    eventKey: prop_types_default().oneOfType([(prop_types_default()).array, victory_util_prop_types/* allOfType */.BO([victory_util_prop_types/* integer */._L, victory_util_prop_types/* nonNegative */.A7]), (prop_types_default()).string]),\n    mutation: (prop_types_default()).func,\n    target: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).array])\n  })),\n  groupComponent: (prop_types_default()).element,\n  gutter: prop_types_default().oneOfType([(prop_types_default()).number, prop_types_default().shape({\n    left: (prop_types_default()).number,\n    right: (prop_types_default()).number\n  })]),\n  height: victory_util_prop_types/* nonNegative */.A7,\n  itemsPerRow: victory_util_prop_types/* nonNegative */.A7,\n  labelComponent: (prop_types_default()).element,\n  name: (prop_types_default()).string,\n  orientation: prop_types_default().oneOf(["horizontal", "vertical"]),\n  padding: prop_types_default().oneOfType([(prop_types_default()).number, prop_types_default().shape({\n    top: (prop_types_default()).number,\n    bottom: (prop_types_default()).number,\n    left: (prop_types_default()).number,\n    right: (prop_types_default()).number\n  })]),\n  rowGutter: prop_types_default().oneOfType([(prop_types_default()).number, prop_types_default().shape({\n    top: (prop_types_default()).number,\n    bottom: (prop_types_default()).number\n  })]),\n  sharedEvents: prop_types_default().shape({\n    events: (prop_types_default()).array,\n    getEventState: (prop_types_default()).func\n  }),\n  standalone: (prop_types_default()).bool,\n  style: prop_types_default().shape({\n    border: (prop_types_default()).object,\n    data: (prop_types_default()).object,\n    labels: (prop_types_default()).object,\n    parent: (prop_types_default()).object,\n    title: (prop_types_default()).object\n  }),\n  symbolSpacer: (prop_types_default()).number,\n  theme: (prop_types_default()).object,\n  title: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).array]),\n  titleComponent: (prop_types_default()).element,\n  titleOrientation: prop_types_default().oneOf(["top", "bottom", "left", "right"]),\n  width: victory_util_prop_types/* nonNegative */.A7,\n  x: victory_util_prop_types/* nonNegative */.A7,\n  y: victory_util_prop_types/* nonNegative */.A7\n};\nVictoryLegend.defaultProps = {\n  borderComponent: /*#__PURE__*/react.createElement(border/* Border */.O, null),\n  data: defaultLegendData,\n  containerComponent: /*#__PURE__*/react.createElement(victory_container/* VictoryContainer */._, null),\n  dataComponent: /*#__PURE__*/react.createElement(point/* Point */.E, null),\n  groupComponent: /*#__PURE__*/react.createElement("g", null),\n  labelComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null),\n  standalone: true,\n  theme: victory_theme/* VictoryTheme.grayscale */.J.grayscale,\n  titleComponent: /*#__PURE__*/react.createElement(victory_label/* VictoryLabel */.X, null)\n};\n\nVictoryLegend.getBaseProps = function (props) {\n  return getBaseProps(props, fallbackProps);\n};\n\nVictoryLegend.getDimensions = function (props) {\n  return getDimensions(props, fallbackProps);\n};\n\nVictoryLegend.expectedComponents = ["borderComponent", "containerComponent", "dataComponent", "groupComponent", "labelComponent", "titleComponent"];\n/* harmony default export */ const victory_legend = ((0,add_events/* addEvents */.o)(VictoryLegend));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2hDLFNBQVMsNkJBQWdCO0FBQ3pCLFNBQVMsOEJBQW1CLEVBQUUsNkJBQWdCLEVBQUUsNEJBQWU7QUFDL0Qsa0JBQWtCLDhCQUFpQjtBQUNuQyxvQkFBb0IsMEJBQWU7QUFDbkMsU0FBUywyQ0FBMkI7QUFDcEMsS0FBSywyQ0FBMkI7QUFDaEMsS0FBSywyQ0FBMkI7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUIsQ0FBQyxvQkFBTTtBQUMxRDtBQUNBLG1DQUFtQyxtQkFBbUIsQ0FBQyx5Q0FBZ0I7QUFDdkUsOEJBQThCLG1CQUFtQixDQUFDLGtCQUFLO0FBQ3ZELCtCQUErQixtQkFBbUI7QUFDbEQsK0JBQStCLG1CQUFtQixDQUFDLGlDQUFZO0FBQy9EO0FBQ0EsU0FBUyxxREFBc0I7QUFDL0IsK0JBQStCLG1CQUFtQixDQUFDLGlDQUFZO0FBQy9EOztBQUVBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCOztBQUVBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCOztBQUVBO0FBQ0EscURBQWUsK0JBQVMsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LWxlZ2VuZC9lcy9oZWxwZXItbWV0aG9kcy5qcz9lNDMzIiwid2VicGFjazovL2NyeW9zdGF0LXdlYi8uL25vZGVfbW9kdWxlcy92aWN0b3J5LWxlZ2VuZC9lcy92aWN0b3J5LWxlZ2VuZC5qcz8xZTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfaXNOaWwgZnJvbSBcImxvZGFzaC9pc05pbFwiO1xuaW1wb3J0IF9yYW5nZSBmcm9tIFwibG9kYXNoL3JhbmdlXCI7XG5pbXBvcnQgX3N1bSBmcm9tIFwibG9kYXNoL3N1bVwiO1xuaW1wb3J0IF9rZXlzIGZyb20gXCJsb2Rhc2gva2V5c1wiO1xuaW1wb3J0IF9ncm91cEJ5IGZyb20gXCJsb2Rhc2gvZ3JvdXBCeVwiO1xuaW1wb3J0IF9hc3NpZ24gZnJvbSBcImxvZGFzaC9hc3NpZ25cIjtcbmltcG9ydCBfZGVmYXVsdHMgZnJvbSBcImxvZGFzaC9kZWZhdWx0c1wiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IEhlbHBlcnMsIFN0eWxlLCBUZXh0U2l6ZSB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcblxudmFyIGdldENvbG9yU2NhbGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIGNvbG9yU2NhbGUgPSBwcm9wcy5jb2xvclNjYWxlO1xuICByZXR1cm4gdHlwZW9mIGNvbG9yU2NhbGUgPT09IFwic3RyaW5nXCIgPyBTdHlsZS5nZXRDb2xvclNjYWxlKGNvbG9yU2NhbGUpIDogY29sb3JTY2FsZSB8fCBbXTtcbn07XG5cbnZhciBnZXRMYWJlbFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgZGF0YSA9IHByb3BzLmRhdGEsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdHVtLCBpbmRleCkge1xuICAgIHZhciBiYXNlTGFiZWxTdHlsZXMgPSBfZGVmYXVsdHMoe30sIGRhdHVtLmxhYmVscywgc3R5bGUubGFiZWxzKTtcblxuICAgIHJldHVybiBIZWxwZXJzLmV2YWx1YXRlU3R5bGUoYmFzZUxhYmVsU3R5bGVzLCB7XG4gICAgICBkYXR1bTogZGF0dW0sXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcywgc3R5bGVPYmplY3QpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIHN0eWxlT2JqZWN0ID0gc3R5bGVPYmplY3QgfHwge307XG4gIHZhciBwYXJlbnRTdHlsZVByb3BzID0ge1xuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgcGFyZW50OiBfZGVmYXVsdHMoc3R5bGUucGFyZW50LCBzdHlsZU9iamVjdC5wYXJlbnQsIHBhcmVudFN0eWxlUHJvcHMpLFxuICAgIGRhdGE6IF9kZWZhdWx0cyh7fSwgc3R5bGUuZGF0YSwgc3R5bGVPYmplY3QuZGF0YSksXG4gICAgbGFiZWxzOiBfZGVmYXVsdHMoe30sIHN0eWxlLmxhYmVscywgc3R5bGVPYmplY3QubGFiZWxzKSxcbiAgICBib3JkZXI6IF9kZWZhdWx0cyh7fSwgc3R5bGUuYm9yZGVyLCBzdHlsZU9iamVjdC5ib3JkZXIpLFxuICAgIHRpdGxlOiBfZGVmYXVsdHMoe30sIHN0eWxlLnRpdGxlLCBzdHlsZU9iamVjdC50aXRsZSlcbiAgfTtcbn07XG5cbnZhciBnZXRDYWxjdWxhdGVkVmFsdWVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgdGhlbWUgPSBwcm9wcy50aGVtZTtcbiAgdmFyIGRlZmF1bHRTdHlsZXMgPSB0aGVtZSAmJiB0aGVtZS5sZWdlbmQgJiYgdGhlbWUubGVnZW5kLnN0eWxlID8gdGhlbWUubGVnZW5kLnN0eWxlIDoge307XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlcyhwcm9wcywgZGVmYXVsdFN0eWxlcyk7XG4gIHZhciBjb2xvclNjYWxlID0gZ2V0Q29sb3JTY2FsZShwcm9wcyk7XG4gIHZhciBpc0hvcml6b250YWwgPSBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIHZhciBib3JkZXJQYWRkaW5nID0gSGVscGVycy5nZXRQYWRkaW5nKHtcbiAgICBwYWRkaW5nOiBwcm9wcy5ib3JkZXJQYWRkaW5nXG4gIH0pO1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgaXNIb3Jpem9udGFsOiBpc0hvcml6b250YWwsXG4gICAgY29sb3JTY2FsZTogY29sb3JTY2FsZSxcbiAgICBib3JkZXJQYWRkaW5nOiBib3JkZXJQYWRkaW5nXG4gIH0pO1xufTtcblxudmFyIGdldENvbHVtbiA9IGZ1bmN0aW9uIChwcm9wcywgaW5kZXgpIHtcbiAgdmFyIGl0ZW1zUGVyUm93ID0gcHJvcHMuaXRlbXNQZXJSb3csXG4gICAgICBpc0hvcml6b250YWwgPSBwcm9wcy5pc0hvcml6b250YWw7XG5cbiAgaWYgKCFpdGVtc1BlclJvdykge1xuICAgIHJldHVybiBpc0hvcml6b250YWwgPyBpbmRleCA6IDA7XG4gIH1cblxuICByZXR1cm4gaXNIb3Jpem9udGFsID8gaW5kZXggJSBpdGVtc1BlclJvdyA6IE1hdGguZmxvb3IoaW5kZXggLyBpdGVtc1BlclJvdyk7XG59O1xuXG52YXIgZ2V0Um93ID0gZnVuY3Rpb24gKHByb3BzLCBpbmRleCkge1xuICB2YXIgaXRlbXNQZXJSb3cgPSBwcm9wcy5pdGVtc1BlclJvdyxcbiAgICAgIGlzSG9yaXpvbnRhbCA9IHByb3BzLmlzSG9yaXpvbnRhbDtcblxuICBpZiAoIWl0ZW1zUGVyUm93KSB7XG4gICAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IDAgOiBpbmRleDtcbiAgfVxuXG4gIHJldHVybiBpc0hvcml6b250YWwgPyBNYXRoLmZsb29yKGluZGV4IC8gaXRlbXNQZXJSb3cpIDogaW5kZXggJSBpdGVtc1BlclJvdztcbn07XG5cbnZhciBncm91cERhdGEgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIGRhdGEgPSBwcm9wcy5kYXRhO1xuICB2YXIgc3R5bGUgPSBwcm9wcy5zdHlsZSAmJiBwcm9wcy5zdHlsZS5kYXRhIHx8IHt9O1xuICB2YXIgbGFiZWxTdHlsZXMgPSBnZXRMYWJlbFN0eWxlcyhwcm9wcyk7XG4gIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoZGF0dW0sIGluZGV4KSB7XG4gICAgdmFyIHN5bWJvbCA9IGRhdHVtLnN5bWJvbCB8fCB7fTtcbiAgICB2YXIgZm9udFNpemUgPSBsYWJlbFN0eWxlc1tpbmRleF0uZm9udFNpemU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG5cbiAgICB2YXIgc2l6ZSA9IHN5bWJvbC5zaXplIHx8IHN0eWxlLnNpemUgfHwgZm9udFNpemUgLyAyLjU7XG4gICAgdmFyIHN5bWJvbFNwYWNlciA9IHByb3BzLnN5bWJvbFNwYWNlciB8fCBNYXRoLm1heChzaXplLCBmb250U2l6ZSk7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0dW0pLCB7fSwge1xuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIHN5bWJvbFNwYWNlcjogc3ltYm9sU3BhY2VyLFxuICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgdGV4dFNpemU6IFRleHRTaXplLmFwcHJveGltYXRlVGV4dFNpemUoZGF0dW0ubmFtZSwgbGFiZWxTdHlsZXNbaW5kZXhdKSxcbiAgICAgIGNvbHVtbjogZ2V0Q29sdW1uKHByb3BzLCBpbmRleCksXG4gICAgICByb3c6IGdldFJvdyhwcm9wcywgaW5kZXgpXG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIGdldENvbHVtbldpZHRocyA9IGZ1bmN0aW9uIChwcm9wcywgZGF0YSkge1xuICB2YXIgZ3V0dGVyID0gcHJvcHMuZ3V0dGVyIHx8IHt9O1xuICB2YXIgZ3V0dGVyV2lkdGggPSB0eXBlb2YgZ3V0dGVyID09PSBcIm9iamVjdFwiID8gKGd1dHRlci5sZWZ0IHx8IDApICsgKGd1dHRlci5yaWdodCB8fCAwKSA6IGd1dHRlciB8fCAwO1xuXG4gIHZhciBkYXRhQnlDb2x1bW4gPSBfZ3JvdXBCeShkYXRhLCBcImNvbHVtblwiKTtcblxuICB2YXIgY29sdW1ucyA9IF9rZXlzKGRhdGFCeUNvbHVtbik7XG5cbiAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyLCBpbmRleCkge1xuICAgIHZhciBsZW5ndGhzID0gZGF0YUJ5Q29sdW1uW2N1cnJdLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQudGV4dFNpemUud2lkdGggKyBkLnNpemUgKyBkLnN5bWJvbFNwYWNlciArIGd1dHRlcldpZHRoO1xuICAgIH0pO1xuICAgIG1lbW9baW5kZXhdID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGxlbmd0aHMpKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwgW10pO1xufTtcblxudmFyIGdldFJvd0hlaWdodHMgPSBmdW5jdGlvbiAocHJvcHMsIGRhdGEpIHtcbiAgdmFyIGd1dHRlciA9IHByb3BzLnJvd0d1dHRlciB8fCB7fTtcbiAgdmFyIGd1dHRlckhlaWdodCA9IHR5cGVvZiBndXR0ZXIgPT09IFwib2JqZWN0XCIgPyAoZ3V0dGVyLnRvcCB8fCAwKSArIChndXR0ZXIuYm90dG9tIHx8IDApIDogZ3V0dGVyIHx8IDA7XG5cbiAgdmFyIGRhdGFCeVJvdyA9IF9ncm91cEJ5KGRhdGEsIFwicm93XCIpO1xuXG4gIHJldHVybiBfa2V5cyhkYXRhQnlSb3cpLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3VyciwgaW5kZXgpIHtcbiAgICB2YXIgcm93cyA9IGRhdGFCeVJvd1tjdXJyXTtcbiAgICB2YXIgbGVuZ3RocyA9IHJvd3MubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC50ZXh0U2l6ZS5oZWlnaHQgKyBkLnN5bWJvbFNwYWNlciArIGd1dHRlckhlaWdodDtcbiAgICB9KTtcbiAgICBtZW1vW2luZGV4XSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShsZW5ndGhzKSk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIFtdKTtcbn07XG5cbnZhciBnZXRUaXRsZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUgJiYgcHJvcHMuc3R5bGUudGl0bGUgfHwge307XG4gIHZhciB0ZXh0U2l6ZSA9IFRleHRTaXplLmFwcHJveGltYXRlVGV4dFNpemUocHJvcHMudGl0bGUsIHN0eWxlKTtcbiAgdmFyIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nIHx8IDA7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiB0ZXh0U2l6ZS5oZWlnaHQgKyAyICogcGFkZGluZyB8fCAwLFxuICAgIHdpZHRoOiB0ZXh0U2l6ZS53aWR0aCArIDIgKiBwYWRkaW5nIHx8IDBcbiAgfTtcbn07XG5cbnZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiAoZGF0dW0sIHJvd0hlaWdodHMsIGNvbHVtbldpZHRocykge1xuICB2YXIgY29sdW1uID0gZGF0dW0uY29sdW1uLFxuICAgICAgcm93ID0gZGF0dW0ucm93O1xuICByZXR1cm4ge1xuICAgIHg6IF9yYW5nZShjb2x1bW4pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3Vycikge1xuICAgICAgbWVtbyArPSBjb2x1bW5XaWR0aHNbY3Vycl07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCAwKSxcbiAgICB5OiBfcmFuZ2Uocm93KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnIpIHtcbiAgICAgIG1lbW8gKz0gcm93SGVpZ2h0c1tjdXJyXTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApXG4gIH07XG59O1xuXG52YXIgZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICh0aXRsZU9yaWVudGF0aW9uLCBjZW50ZXJUaXRsZSkge1xuICB2YXIgc3RhbmRhcmRBbmNob3JzID0ge1xuICAgIHRleHRBbmNob3I6IHRpdGxlT3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsXG4gICAgdmVydGljYWxBbmNob3I6IHRpdGxlT3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgPyBcImVuZFwiIDogXCJzdGFydFwiXG4gIH07XG5cbiAgaWYgKGNlbnRlclRpdGxlKSB7XG4gICAgdmFyIGhvcml6b250YWwgPSB0aXRsZU9yaWVudGF0aW9uID09PSBcInRvcFwiIHx8IHRpdGxlT3JpZW50YXRpb24gPT09IFwiYm90dG9tXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRBbmNob3I6IGhvcml6b250YWwgPyBcIm1pZGRsZVwiIDogc3RhbmRhcmRBbmNob3JzLnRleHRBbmNob3IsXG4gICAgICB2ZXJ0aWNhbEFuY2hvcjogaG9yaXpvbnRhbCA/IHN0YW5kYXJkQW5jaG9ycy52ZXJ0aWNhbEFuY2hvciA6IFwibWlkZGxlXCJcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YW5kYXJkQW5jaG9ycztcbn07XG5cbnZhciBnZXRUaXRsZVN0eWxlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciB0aXRsZU9yaWVudGF0aW9uID0gcHJvcHMudGl0bGVPcmllbnRhdGlvbixcbiAgICAgIGNlbnRlclRpdGxlID0gcHJvcHMuY2VudGVyVGl0bGUsXG4gICAgICB0aXRsZUNvbXBvbmVudCA9IHByb3BzLnRpdGxlQ29tcG9uZW50O1xuICB2YXIgYmFzZVN0eWxlID0gcHJvcHMuc3R5bGUgJiYgcHJvcHMuc3R5bGUudGl0bGUgfHwge307XG4gIHZhciBjb21wb25lbnRTdHlsZSA9IHRpdGxlQ29tcG9uZW50LnByb3BzICYmIHRpdGxlQ29tcG9uZW50LnByb3BzLnN0eWxlIHx8IHt9O1xuICB2YXIgYW5jaG9ycyA9IGdldEFuY2hvcnModGl0bGVPcmllbnRhdGlvbiwgY2VudGVyVGl0bGUpO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjb21wb25lbnRTdHlsZSkgPyBjb21wb25lbnRTdHlsZS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBfZGVmYXVsdHMoe30sIG9iaiwgYmFzZVN0eWxlLCBhbmNob3JzKTtcbiAgfSkgOiBfZGVmYXVsdHMoe30sIGNvbXBvbmVudFN0eWxlLCBiYXNlU3R5bGUsIGFuY2hvcnMpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG52YXIgZ2V0VGl0bGVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgYm9yZGVyUHJvcHMpIHtcbiAgdmFyIHRpdGxlID0gcHJvcHMudGl0bGUsXG4gICAgICB0aXRsZU9yaWVudGF0aW9uID0gcHJvcHMudGl0bGVPcmllbnRhdGlvbixcbiAgICAgIGNlbnRlclRpdGxlID0gcHJvcHMuY2VudGVyVGl0bGUsXG4gICAgICBib3JkZXJQYWRkaW5nID0gcHJvcHMuYm9yZGVyUGFkZGluZztcbiAgdmFyIGhlaWdodCA9IGJvcmRlclByb3BzLmhlaWdodCxcbiAgICAgIHdpZHRoID0gYm9yZGVyUHJvcHMud2lkdGg7XG4gIHZhciBzdHlsZSA9IGdldFRpdGxlU3R5bGUocHJvcHMpO1xuICB2YXIgcGFkZGluZyA9IEFycmF5LmlzQXJyYXkoc3R5bGUpID8gc3R5bGVbMF0ucGFkZGluZyA6IHN0eWxlLnBhZGRpbmc7XG4gIHZhciBob3Jpem9udGFsID0gdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJ0b3BcIiB8fCB0aXRsZU9yaWVudGF0aW9uID09PSBcImJvdHRvbVwiO1xuICB2YXIgeE9yaWVudGF0aW9uID0gdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJib3R0b21cIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICB2YXIgeU9yaWVudGF0aW9uID0gdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gIHZhciBzdGFuZGFyZFBhZGRpbmcgPSB7XG4gICAgeDogY2VudGVyVGl0bGUgPyB3aWR0aCAvIDIgOiBib3JkZXJQYWRkaW5nW3hPcmllbnRhdGlvbl0gKyAocGFkZGluZyB8fCAwKSxcbiAgICB5OiBjZW50ZXJUaXRsZSA/IGhlaWdodCAvIDIgOiBib3JkZXJQYWRkaW5nW3lPcmllbnRhdGlvbl0gKyAocGFkZGluZyB8fCAwKVxuICB9O1xuXG4gIHZhciBnZXRQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBib3JkZXJQYWRkaW5nW3RpdGxlT3JpZW50YXRpb25dICsgKHBhZGRpbmcgfHwgMCk7XG4gIH07XG5cbiAgdmFyIHhPZmZzZXQgPSBob3Jpem9udGFsID8gc3RhbmRhcmRQYWRkaW5nLnggOiBnZXRQYWRkaW5nKCk7XG4gIHZhciB5T2Zmc2V0ID0gaG9yaXpvbnRhbCA/IGdldFBhZGRpbmcoKSA6IHN0YW5kYXJkUGFkZGluZy55O1xuICByZXR1cm4ge1xuICAgIHg6IHRpdGxlT3JpZW50YXRpb24gPT09IFwicmlnaHRcIiA/IHByb3BzLnggKyB3aWR0aCAtIHhPZmZzZXQgOiBwcm9wcy54ICsgeE9mZnNldCxcbiAgICB5OiB0aXRsZU9yaWVudGF0aW9uID09PSBcImJvdHRvbVwiID8gcHJvcHMueSArIGhlaWdodCAtIHlPZmZzZXQgOiBwcm9wcy55ICsgeU9mZnNldCxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdGV4dDogdGl0bGVcbiAgfTtcbn07XG5cbnZhciBnZXRCb3JkZXJQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcywgY29udGVudEhlaWdodCwgY29udGVudFdpZHRoKSB7XG4gIHZhciB4ID0gcHJvcHMueCxcbiAgICAgIHkgPSBwcm9wcy55LFxuICAgICAgYm9yZGVyUGFkZGluZyA9IHByb3BzLmJvcmRlclBhZGRpbmcsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlO1xuICB2YXIgaGVpZ2h0ID0gKGNvbnRlbnRIZWlnaHQgfHwgMCkgKyBib3JkZXJQYWRkaW5nLnRvcCArIGJvcmRlclBhZGRpbmcuYm90dG9tO1xuICB2YXIgd2lkdGggPSAoY29udGVudFdpZHRoIHx8IDApICsgYm9yZGVyUGFkZGluZy5sZWZ0ICsgYm9yZGVyUGFkZGluZy5yaWdodDtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIHN0eWxlOiBfYXNzaWduKHtcbiAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgfSwgc3R5bGUuYm9yZGVyKVxuICB9O1xufTtcblxuZXhwb3J0IHZhciBnZXREaW1lbnNpb25zID0gZnVuY3Rpb24gKHByb3BzLCBmYWxsYmFja1Byb3BzKSB7XG4gIHZhciBtb2RpZmllZFByb3BzID0gSGVscGVycy5tb2RpZnlQcm9wcyhwcm9wcywgZmFsbGJhY2tQcm9wcywgXCJsZWdlbmRcIik7XG4gIHByb3BzID0gX2Fzc2lnbih7fSwgbW9kaWZpZWRQcm9wcywgZ2V0Q2FsY3VsYXRlZFZhbHVlcyhtb2RpZmllZFByb3BzKSk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIHRpdGxlID0gX3Byb3BzLnRpdGxlLFxuICAgICAgdGl0bGVPcmllbnRhdGlvbiA9IF9wcm9wcy50aXRsZU9yaWVudGF0aW9uO1xuICB2YXIgZ3JvdXBlZERhdGEgPSBncm91cERhdGEocHJvcHMpO1xuICB2YXIgY29sdW1uV2lkdGhzID0gZ2V0Q29sdW1uV2lkdGhzKHByb3BzLCBncm91cGVkRGF0YSk7XG4gIHZhciByb3dIZWlnaHRzID0gZ2V0Um93SGVpZ2h0cyhwcm9wcywgZ3JvdXBlZERhdGEpO1xuICB2YXIgdGl0bGVEaW1lbnNpb25zID0gdGl0bGUgPyBnZXRUaXRsZURpbWVuc2lvbnMocHJvcHMpIDoge1xuICAgIGhlaWdodDogMCxcbiAgICB3aWR0aDogMFxuICB9O1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gTWF0aC5tYXgoX3N1bShyb3dIZWlnaHRzKSwgdGl0bGVEaW1lbnNpb25zLmhlaWdodCkgOiBfc3VtKHJvd0hlaWdodHMpICsgdGl0bGVEaW1lbnNpb25zLmhlaWdodCxcbiAgICB3aWR0aDogdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJsZWZ0XCIgfHwgdGl0bGVPcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gX3N1bShjb2x1bW5XaWR0aHMpICsgdGl0bGVEaW1lbnNpb25zLndpZHRoIDogTWF0aC5tYXgoX3N1bShjb2x1bW5XaWR0aHMpLCB0aXRsZURpbWVuc2lvbnMud2lkdGgpXG4gIH07XG59O1xuZXhwb3J0IHZhciBnZXRCYXNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGZhbGxiYWNrUHJvcHMpIHtcbiAgdmFyIG1vZGlmaWVkUHJvcHMgPSBIZWxwZXJzLm1vZGlmeVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzLCBcImxlZ2VuZFwiKTtcbiAgcHJvcHMgPSBfYXNzaWduKHt9LCBtb2RpZmllZFByb3BzLCBnZXRDYWxjdWxhdGVkVmFsdWVzKG1vZGlmaWVkUHJvcHMpKTtcbiAgdmFyIF9wcm9wczIgPSBwcm9wcyxcbiAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICBzdGFuZGFsb25lID0gX3Byb3BzMi5zdGFuZGFsb25lLFxuICAgICAgdGhlbWUgPSBfcHJvcHMyLnRoZW1lLFxuICAgICAgcGFkZGluZyA9IF9wcm9wczIucGFkZGluZyxcbiAgICAgIHN0eWxlID0gX3Byb3BzMi5zdHlsZSxcbiAgICAgIGNvbG9yU2NhbGUgPSBfcHJvcHMyLmNvbG9yU2NhbGUsXG4gICAgICBndXR0ZXIgPSBfcHJvcHMyLmd1dHRlcixcbiAgICAgIHJvd0d1dHRlciA9IF9wcm9wczIucm93R3V0dGVyLFxuICAgICAgYm9yZGVyUGFkZGluZyA9IF9wcm9wczIuYm9yZGVyUGFkZGluZyxcbiAgICAgIHRpdGxlID0gX3Byb3BzMi50aXRsZSxcbiAgICAgIHRpdGxlT3JpZW50YXRpb24gPSBfcHJvcHMyLnRpdGxlT3JpZW50YXRpb24sXG4gICAgICBuYW1lID0gX3Byb3BzMi5uYW1lLFxuICAgICAgX3Byb3BzMiR4ID0gX3Byb3BzMi54LFxuICAgICAgeCA9IF9wcm9wczIkeCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wczIkeCxcbiAgICAgIF9wcm9wczIkeSA9IF9wcm9wczIueSxcbiAgICAgIHkgPSBfcHJvcHMyJHkgPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMyJHk7XG4gIHZhciBncm91cGVkRGF0YSA9IGdyb3VwRGF0YShwcm9wcyk7XG4gIHZhciBjb2x1bW5XaWR0aHMgPSBnZXRDb2x1bW5XaWR0aHMocHJvcHMsIGdyb3VwZWREYXRhKTtcbiAgdmFyIHJvd0hlaWdodHMgPSBnZXRSb3dIZWlnaHRzKHByb3BzLCBncm91cGVkRGF0YSk7XG4gIHZhciBsYWJlbFN0eWxlcyA9IGdldExhYmVsU3R5bGVzKHByb3BzKTtcbiAgdmFyIHRpdGxlRGltZW5zaW9ucyA9IHRpdGxlID8gZ2V0VGl0bGVEaW1lbnNpb25zKHByb3BzKSA6IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDBcbiAgfTtcbiAgdmFyIHRpdGxlT2Zmc2V0ID0ge1xuICAgIHg6IHRpdGxlT3JpZW50YXRpb24gPT09IFwibGVmdFwiID8gdGl0bGVEaW1lbnNpb25zLndpZHRoIDogMCxcbiAgICB5OiB0aXRsZU9yaWVudGF0aW9uID09PSBcInRvcFwiID8gdGl0bGVEaW1lbnNpb25zLmhlaWdodCA6IDBcbiAgfTtcbiAgdmFyIGd1dHRlck9mZnNldCA9IHtcbiAgICB4OiBndXR0ZXIgJiYgdHlwZW9mIGd1dHRlciA9PT0gXCJvYmplY3RcIiA/IGd1dHRlci5sZWZ0IHx8IDAgOiAwLFxuICAgIHk6IHJvd0d1dHRlciAmJiB0eXBlb2Ygcm93R3V0dGVyID09PSBcIm9iamVjdFwiID8gcm93R3V0dGVyLnRvcCB8fCAwIDogMFxuICB9O1xuXG4gIHZhciBfZ2V0RGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMocHJvcHMsIGZhbGxiYWNrUHJvcHMpLFxuICAgICAgaGVpZ2h0ID0gX2dldERpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBfZ2V0RGltZW5zaW9ucy53aWR0aDtcblxuICB2YXIgYm9yZGVyUHJvcHMgPSBnZXRCb3JkZXJQcm9wcyhwcm9wcywgaGVpZ2h0LCB3aWR0aCk7XG4gIHZhciB0aXRsZVByb3BzID0gZ2V0VGl0bGVQcm9wcyhwcm9wcywgYm9yZGVyUHJvcHMpO1xuICB2YXIgaW5pdGlhbFByb3BzID0ge1xuICAgIHBhcmVudDoge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHN0YW5kYWxvbmU6IHN0YW5kYWxvbmUsXG4gICAgICB0aGVtZTogdGhlbWUsXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgICAgd2lkdGg6IHByb3BzLndpZHRoLFxuICAgICAgc3R5bGU6IHN0eWxlLnBhcmVudFxuICAgIH0sXG4gICAgYWxsOiB7XG4gICAgICBib3JkZXI6IGJvcmRlclByb3BzLFxuICAgICAgdGl0bGU6IHRpdGxlUHJvcHNcbiAgICB9XG4gIH07XG4gIHJldHVybiBncm91cGVkRGF0YS5yZWR1Y2UoZnVuY3Rpb24gKGNoaWxkUHJvcHMsIGRhdHVtLCBpKSB7XG4gICAgdmFyIGNvbG9yID0gY29sb3JTY2FsZVtpICUgY29sb3JTY2FsZS5sZW5ndGhdO1xuXG4gICAgdmFyIGRhdGFTdHlsZSA9IF9kZWZhdWx0cyh7fSwgZGF0dW0uc3ltYm9sLCBzdHlsZS5kYXRhLCB7XG4gICAgICBmaWxsOiBjb2xvclxuICAgIH0pO1xuXG4gICAgdmFyIGV2ZW50S2V5ID0gIV9pc05pbChkYXR1bS5ldmVudEtleSkgPyBkYXR1bS5ldmVudEtleSA6IGk7XG4gICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChkYXR1bSwgcm93SGVpZ2h0cywgY29sdW1uV2lkdGhzKTtcbiAgICB2YXIgb3JpZ2luWSA9IHkgKyBib3JkZXJQYWRkaW5nLnRvcCArIGRhdHVtLnN5bWJvbFNwYWNlcjtcbiAgICB2YXIgb3JpZ2luWCA9IHggKyBib3JkZXJQYWRkaW5nLmxlZnQgKyBkYXR1bS5zeW1ib2xTcGFjZXI7XG4gICAgdmFyIGRhdGFQcm9wcyA9IHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGRhdHVtOiBkYXR1bSxcbiAgICAgIHN5bWJvbDogZGF0YVN0eWxlLnR5cGUgfHwgZGF0YVN0eWxlLnN5bWJvbCB8fCBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogZGF0dW0uc2l6ZSxcbiAgICAgIHN0eWxlOiBkYXRhU3R5bGUsXG4gICAgICB5OiBvcmlnaW5ZICsgb2Zmc2V0LnkgKyB0aXRsZU9mZnNldC55ICsgZ3V0dGVyT2Zmc2V0LnksXG4gICAgICB4OiBvcmlnaW5YICsgb2Zmc2V0LnggKyB0aXRsZU9mZnNldC54ICsgZ3V0dGVyT2Zmc2V0LnhcbiAgICB9O1xuICAgIHZhciBsYWJlbFByb3BzID0ge1xuICAgICAgZGF0dW06IGRhdHVtLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHRleHQ6IGRhdHVtLm5hbWUsXG4gICAgICBzdHlsZTogbGFiZWxTdHlsZXNbaV0sXG4gICAgICB5OiBkYXRhUHJvcHMueSxcbiAgICAgIHg6IGRhdGFQcm9wcy54ICsgZGF0dW0uc3ltYm9sU3BhY2VyICsgZGF0dW0uc2l6ZSAvIDJcbiAgICB9O1xuICAgIGNoaWxkUHJvcHNbZXZlbnRLZXldID0ge1xuICAgICAgZGF0YTogZGF0YVByb3BzLFxuICAgICAgbGFiZWxzOiBsYWJlbFByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gY2hpbGRQcm9wcztcbiAgfSwgaW5pdGlhbFByb3BzKTtcbn07IiwiZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBnZXRCYXNlUHJvcHMsIGdldERpbWVuc2lvbnMgfSBmcm9tIFwiLi9oZWxwZXItbWV0aG9kc1wiO1xuaW1wb3J0IHsgUHJvcFR5cGVzIGFzIEN1c3RvbVByb3BUeXBlcywgYWRkRXZlbnRzLCBIZWxwZXJzLCBWaWN0b3J5TGFiZWwsIFZpY3RvcnlDb250YWluZXIsIFZpY3RvcnlUaGVtZSwgUG9pbnQsIEJvcmRlciB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbnZhciBmYWxsYmFja1Byb3BzID0ge1xuICBvcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICB0aXRsZU9yaWVudGF0aW9uOiBcInRvcFwiLFxuICB3aWR0aDogNDUwLFxuICBoZWlnaHQ6IDMwMCxcbiAgeDogMCxcbiAgeTogMFxufTtcbnZhciBkZWZhdWx0TGVnZW5kRGF0YSA9IFt7XG4gIG5hbWU6IFwiU2VyaWVzIDFcIlxufSwge1xuICBuYW1lOiBcIlNlcmllcyAyXCJcbn1dO1xuXG52YXIgVmljdG9yeUxlZ2VuZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVmljdG9yeUxlZ2VuZCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihWaWN0b3J5TGVnZW5kKTtcblxuICBmdW5jdGlvbiBWaWN0b3J5TGVnZW5kKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWN0b3J5TGVnZW5kKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaWN0b3J5TGVnZW5kLCBbe1xuICAgIGtleTogXCJyZW5kZXJDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihwcm9wcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGRhdGFDb21wb25lbnQgPSBwcm9wcy5kYXRhQ29tcG9uZW50LFxuICAgICAgICAgIGxhYmVsQ29tcG9uZW50ID0gcHJvcHMubGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgdGl0bGUgPSBwcm9wcy50aXRsZTtcbiAgICAgIHZhciBkYXRhQ29tcG9uZW50cyA9IHRoaXMuZGF0YUtleXMubWFwKGZ1bmN0aW9uIChfZGF0YUtleSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKF9kYXRhS2V5ID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhUHJvcHMgPSBfdGhpcy5nZXRDb21wb25lbnRQcm9wcyhkYXRhQ29tcG9uZW50LCBcImRhdGFcIiwgaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGRhdGFDb21wb25lbnQsIGRhdGFQcm9wcyk7XG4gICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB2YXIgbGFiZWxDb21wb25lbnRzID0gdGhpcy5kYXRhS2V5cy5tYXAoZnVuY3Rpb24gKF9kYXRhS2V5LCBpbmRleCkge1xuICAgICAgICBpZiAoX2RhdGFLZXkgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsUHJvcHMgPSBfdGhpcy5nZXRDb21wb25lbnRQcm9wcyhsYWJlbENvbXBvbmVudCwgXCJsYWJlbHNcIiwgaW5kZXgpO1xuXG4gICAgICAgIGlmIChsYWJlbFByb3BzLnRleHQgIT09IHVuZGVmaW5lZCAmJiBsYWJlbFByb3BzLnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChsYWJlbENvbXBvbmVudCwgbGFiZWxQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdmFyIGJvcmRlclByb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhwcm9wcy5ib3JkZXJDb21wb25lbnQsIFwiYm9yZGVyXCIsIFwiYWxsXCIpO1xuICAgICAgdmFyIGJvcmRlckNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJvcHMuYm9yZGVyQ29tcG9uZW50LCBib3JkZXJQcm9wcyk7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB2YXIgdGl0bGVQcm9wcyA9IHRoaXMuZ2V0Q29tcG9uZW50UHJvcHMocHJvcHMudGl0bGUsIFwidGl0bGVcIiwgXCJhbGxcIik7XG4gICAgICAgIHZhciB0aXRsZUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJvcHMudGl0bGVDb21wb25lbnQsIHRpdGxlUHJvcHMpO1xuICAgICAgICByZXR1cm4gW2JvcmRlckNvbXBvbmVudF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShkYXRhQ29tcG9uZW50cyksIFt0aXRsZUNvbXBvbmVudF0sIF90b0NvbnN1bWFibGVBcnJheShsYWJlbENvbXBvbmVudHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtib3JkZXJDb21wb25lbnRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZGF0YUNvbXBvbmVudHMpLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxDb21wb25lbnRzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcm9sZSA9IHRoaXMuY29uc3RydWN0b3Iucm9sZTtcbiAgICAgIHZhciBwcm9wcyA9IEhlbHBlcnMubW9kaWZ5UHJvcHModGhpcy5wcm9wcywgZmFsbGJhY2tQcm9wcywgcm9sZSk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbdGhpcy5yZW5kZXJDaGlsZHJlbihwcm9wcyldO1xuICAgICAgcmV0dXJuIHByb3BzLnN0YW5kYWxvbmUgPyB0aGlzLnJlbmRlckNvbnRhaW5lcihwcm9wcy5jb250YWluZXJDb21wb25lbnQsIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJvcHMuZ3JvdXBDb21wb25lbnQsIHt9LCBjaGlsZHJlbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpY3RvcnlMZWdlbmQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblZpY3RvcnlMZWdlbmQuZGlzcGxheU5hbWUgPSBcIlZpY3RvcnlMZWdlbmRcIjtcblZpY3RvcnlMZWdlbmQucm9sZSA9IFwibGVnZW5kXCI7XG5WaWN0b3J5TGVnZW5kLnByb3BUeXBlcyA9IHtcbiAgYm9yZGVyQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgYm9yZGVyUGFkZGluZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5udW1iZXJcbiAgfSldKSxcbiAgY2VudGVyVGl0bGU6IFByb3BUeXBlcy5ib29sLFxuICBjb2xvclNjYWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSwgUHJvcFR5cGVzLm9uZU9mKFtcImdyYXlzY2FsZVwiLCBcInF1YWxpdGF0aXZlXCIsIFwiaGVhdG1hcFwiLCBcIndhcm1cIiwgXCJjb29sXCIsIFwicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdKV0pLFxuICBjb250YWluZXJDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBsYWJlbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzeW1ib2w6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkpLFxuICBkYXRhQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgZXZlbnRLZXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBDdXN0b21Qcm9wVHlwZXMuYWxsT2ZUeXBlKFtDdXN0b21Qcm9wVHlwZXMuaW50ZWdlciwgQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlXSksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHRhcmdldDogUHJvcFR5cGVzLm9uZU9mKFtcImRhdGFcIiwgXCJsYWJlbHNcIiwgXCJwYXJlbnRcIl0pLFxuICAgIGV2ZW50S2V5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIEN1c3RvbVByb3BUeXBlcy5hbGxPZlR5cGUoW0N1c3RvbVByb3BUeXBlcy5pbnRlZ2VyLCBDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmVdKSwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIGV2ZW50SGFuZGxlcnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkpLFxuICBleHRlcm5hbEV2ZW50TXV0YXRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGNhbGxiYWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBjaGlsZE5hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pLFxuICAgIGV2ZW50S2V5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIEN1c3RvbVByb3BUeXBlcy5hbGxPZlR5cGUoW0N1c3RvbVByb3BUeXBlcy5pbnRlZ2VyLCBDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmVdKSwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIG11dGF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB0YXJnZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheV0pXG4gIH0pKSxcbiAgZ3JvdXBDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBndXR0ZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgICByaWdodDogUHJvcFR5cGVzLm51bWJlclxuICB9KV0pLFxuICBoZWlnaHQ6IEN1c3RvbVByb3BUeXBlcy5ub25OZWdhdGl2ZSxcbiAgaXRlbXNQZXJSb3c6IEN1c3RvbVByb3BUeXBlcy5ub25OZWdhdGl2ZSxcbiAgbGFiZWxDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSksXG4gIHBhZGRpbmc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGJvdHRvbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG4gIHJvd0d1dHRlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG4gIHNoYXJlZEV2ZW50czogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBldmVudHM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBnZXRFdmVudFN0YXRlOiBQcm9wVHlwZXMuZnVuY1xuICB9KSxcbiAgc3RhbmRhbG9uZTogUHJvcFR5cGVzLmJvb2wsXG4gIHN0eWxlOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGJvcmRlcjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkYXRhOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGxhYmVsczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBwYXJlbnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdGl0bGU6IFByb3BUeXBlcy5vYmplY3RcbiAgfSksXG4gIHN5bWJvbFNwYWNlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgdGhlbWU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgdGl0bGVDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50LFxuICB0aXRsZU9yaWVudGF0aW9uOiBQcm9wVHlwZXMub25lT2YoW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKSxcbiAgd2lkdGg6IEN1c3RvbVByb3BUeXBlcy5ub25OZWdhdGl2ZSxcbiAgeDogQ3VzdG9tUHJvcFR5cGVzLm5vbk5lZ2F0aXZlLFxuICB5OiBDdXN0b21Qcm9wVHlwZXMubm9uTmVnYXRpdmVcbn07XG5WaWN0b3J5TGVnZW5kLmRlZmF1bHRQcm9wcyA9IHtcbiAgYm9yZGVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCb3JkZXIsIG51bGwpLFxuICBkYXRhOiBkZWZhdWx0TGVnZW5kRGF0YSxcbiAgY29udGFpbmVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5Q29udGFpbmVyLCBudWxsKSxcbiAgZGF0YUNvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9pbnQsIG51bGwpLFxuICBncm91cENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwpLFxuICBsYWJlbENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUxhYmVsLCBudWxsKSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgdGhlbWU6IFZpY3RvcnlUaGVtZS5ncmF5c2NhbGUsXG4gIHRpdGxlQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5TGFiZWwsIG51bGwpXG59O1xuXG5WaWN0b3J5TGVnZW5kLmdldEJhc2VQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gZ2V0QmFzZVByb3BzKHByb3BzLCBmYWxsYmFja1Byb3BzKTtcbn07XG5cblZpY3RvcnlMZWdlbmQuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gZ2V0RGltZW5zaW9ucyhwcm9wcywgZmFsbGJhY2tQcm9wcyk7XG59O1xuXG5WaWN0b3J5TGVnZW5kLmV4cGVjdGVkQ29tcG9uZW50cyA9IFtcImJvcmRlckNvbXBvbmVudFwiLCBcImNvbnRhaW5lckNvbXBvbmVudFwiLCBcImRhdGFDb21wb25lbnRcIiwgXCJncm91cENvbXBvbmVudFwiLCBcImxhYmVsQ29tcG9uZW50XCIsIFwidGl0bGVDb21wb25lbnRcIl07XG5leHBvcnQgZGVmYXVsdCBhZGRFdmVudHMoVmljdG9yeUxlZ2VuZCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37541\n')}}]);